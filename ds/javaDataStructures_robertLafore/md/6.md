6
=

Recursion
---------

> Recursion is a programming technique in which a method (function)
> calls itself. This may sound like a strange thing to do, or even a
> catastrophic mistake.
>
> Recursion is, however, one of the most interesting, and one of the
> most surprisingly effective, techniques in programming. Like pulling
> yourself up by your bootstraps (you do have bootstraps, don't you?),
> recursion seems incredible when you first encounter it. However, it
> not only works, it also provides a unique conceptual frame- work for
> solving many problems.
>
> In this chapter we'll examine numerous examples to show the wide
> variety of situations to which recursion can be applied. We will
> calculate triangular numbers and factori- als, generate anagrams,
> perform a recursive binary search, solve the Towers of Hanoi puzzle,
> and investigate a sorting technique called mergesort. Workshop applets
> are provided to demonstrate the Towers of Hanoi and mergesort.
>
> We'll also discuss the strengths and weaknesses of recur- sion, and
> show how a recursive approach can be trans- formed into a stack-based
> approach.

#### Triangular Numbers

> It's said that the Pythagorians, a band of mathematicians in ancient
> Greece who worked under Pythagoras (of Pythagorian theorem fame), felt
> a mystical connection with the series of numbers 1, 3, 6, 10, 15, 21,
> ... (where the
>
> ... means the series continues indefinitely). Can you find the next
> member of this series?
>
> The nth term in the series is obtained by adding n to the previous
> term. Thus, the second term is found by adding 2 to the first term
> (which is 1), giving 3. The third term is 3 added to the second term
> (which is 3) giving 6, and so on.

##### IN THIS CHAPTER

-   Triangular Numbers

-   Factorials

-   Anagrams

-   A Recursive Binary Search

-   The Towers of Hanoi

-   Mergesort

-   Eliminating Recursion

-   Some Interesting Recursive Applications

> 252 **CHAPTER 6** Recursion
>
> The numbers in this series are called *triangular numbers* because
> they can be visual- ized as a triangular arrangement of objects, shown
> as little squares in Figure 6.1.

![](media/image1.png)

> ![](media/image2.png) ![](media/image3.png) ![](media/image4.png)
>
> ![](media/image5.png) ![](media/image6.png) ![](media/image7.png)
> ![](media/image8.png) ![](media/image9.png) ![](media/image10.png)
>
> ![](media/image11.png) ![](media/image12.png) ![](media/image13.png)
> ![](media/image14.png) ![](media/image15.png) ![](media/image16.png)
> ![](media/image17.png) ![](media/image18.png) ![](media/image19.png)
> ![](media/image16.png)
>
> \#1 = 1 \#2 = 3 \#3 = 6 \#4 = 10

![](media/image20.png)

> ![](media/image21.png) ![](media/image22.png) ![](media/image23.png)
>
> ![](media/image24.png) ![](media/image25.png) ![](media/image26.png)
> ![](media/image27.png) ![](media/image28.png) ![](media/image29.png)
>
> ![](media/image30.png) ![](media/image31.png) ![](media/image32.png)
> ![](media/image33.png) ![](media/image34.png) ![](media/image35.png)
> ![](media/image36.png) ![](media/image37.png) ![](media/image38.png)
>
> ![](media/image39.png) ![](media/image40.png) ![](media/image40.png)
> ![](media/image41.png) ![](media/image42.png) ![](media/image43.png)
> ![](media/image44.png) ![](media/image45.png) ![](media/image46.png)
> ![](media/image47.png) ![](media/image48.png)
>
> ![](media/image49.png)![](media/image50.png)![](media/image51.png)![](media/image52.png)![](media/image53.png)![](media/image53.png)![](media/image54.png)![](media/image55.png)![](media/image56.png)![](media/image57.png)![](media/image58.png)![](media/image59.png)![](media/image60.png)![](media/image61.png)![](media/image61.png)![](media/image62.png)![](media/image63.png)![](media/image64.png)![](media/image66.png)![](media/image67.png)![](media/image68.png)![](media/image69.png)![](media/image70.png)![](media/image71.png)![](media/image68.png)![](media/image73.png)![](media/image74.png)![](media/image75.png)![](media/image76.png)![](media/image77.png)![](media/image74.png)![](media/image78.png)\#5
> = 15 \#6 = 21 \#7 = 28
>
> ***FIGURE 6.1*** The triangular numbers.

##### Finding the nth Term Using a Loop

> Suppose you wanted to find the value of some arbitrary nth term in the
> series---say the fourth term (whose value is 10). How would you
> calculate it? Looking at Figure 6.2, you might decide that the value
> of any term can be obtained by adding up all the vertical columns of
> squares.
>
> ![](media/image79.png)1 in this column 2 in this column 3 in this
> column 4 in this column
>
> Total: 10
>
> ***FIGURE 6.2*** Triangular number as columns.
>
> In the fourth term, the first column has four little squares, the
> second column has three, and so on. Adding 4+3+2+1 gives 10.

Triangular Numbers 253

> The following triangle() method uses this column-based technique to
> find a trian- gular number. It sums all the columns, from a height of
> n to a height of 1:
>
> int triangle(int n)
>
> {
>
> int total = 0;
>
> while(n \> 0) // until n is 1
>
> {
>
> total = total + n; // add n (column height) to total
>
> \--n; // decrement column height
>
> }
>
> return total;
>
> }
>
> The method cycles around the loop n times, adding n to total the first
> time, n-1 the second time, and so on down to 1, quitting the loop when
> n becomes 0.

##### Finding the nth Term Using Recursion

> The loop approach may seem straightforward, but there's another way to
> look at this problem. The value of the nth term can be thought of as
> the sum of only two things, instead of a whole series. They are

1.  The first (tallest) column, which has the value n.

2.  The sum of all the remaining columns.

> This is shown in Figure 6.3.
>
> ![](media/image88.png)6 in the remaining columns
>
> [4]{.underline} in the first column Total: 10
>
> ***FIGURE 6.3*** Triangular number as column plus triangle.
>
> 254 **CHAPTER 6** Recursion

####### Finding the Remaining Columns

> If we knew about a method that found the sum of all the remaining
> columns, we could write our triangle() method, which returns the value
> of the nth triangular number, like this:
>
> int triangle(int n)
>
> {
>
> return( n + sumRemainingColumns(n) ); // (incomplete version)
>
> }
>
> But what have we gained here? It looks like writing the
> sumRemainingColumns()
>
> method is just as hard as writing the triangle() method in the first
> place.
>
> Notice in Figure 6.3, however, that the sum of all the remaining
> columns for term n is the same as the sum of *all* the columns for
> term n-1. Thus, if we knew about a method that summed all the columns
> for term n, we could call it with an argument of n-1 to find the sum
> of all the remaining columns for term n:
>
> int triangle(int n)
>
> {
>
> return( n + sumAllColumns(n-1) ); // (incomplete version)
>
> }
>
> But when you think about it, the sumAllColumns() method is doing
> exactly the same thing the triangle() method is: summing all the
> columns for some number n passed as an argument. So why not use the
> triangle() method itself, instead of some other method? That would
> look like this:
>
> int triangle(int n)
>
> {
>
> return( n + triangle(n-1) ); // (incomplete version)
>
> }
>
> You may be amazed that a method can call itself, but why shouldn't it
> be able to? A method call is (among other things) a transfer of
> control to the start of the method. This transfer of control can take
> place from within the method as well as from outside.

####### Passing the Buck

> All these approaches may seem like passing the buck. Someone tells me
> to find the 9th triangular number. I know this is 9 plus the 8th
> triangular number, so I call Harry and ask him to find the 8th
> triangular number. When I hear back from him, I'll add 9 to whatever
> he tells me, and that will be the answer.

Triangular Numbers 255

> Harry knows the 8th triangular number is 8 plus the 7th triangular
> number, so he calls Sally and asks her to find the 7th triangular
> number. This process continues with each person passing the buck to
> another one.
>
> Where does this buck-passing end? Someone at some point must be able
> to figure out an answer that doesn't involve asking another person to
> help. If this didn't happen, there would be an infinite chain of
> people asking other people questions---a sort of arithmetic Ponzi
> scheme that would never end. In the case of triangle(), this would
> mean the method calling itself over and over in an infinite series
> that would eventually crash the program.

####### The Buck Stops Here

> To prevent an infinite regress, the person who is asked to find the
> first triangular number of the series, when n is 1, must know, without
> asking anyone else, that the answer is 1. There are no smaller numbers
> to ask anyone about, there's nothing left to add to anything else, so
> the buck stops there. We can express this by adding a condition to the
> triangle() method:
>
> int triangle(int n)
>
> {
>
> if(n==1)
>
> return 1; else
>
> return( n + triangle(n-1) );
>
> }
>
> The condition that leads to a recursive method returning without
> making another recursive call is referred to as the *base case*. It's
> critical that every recursive method have a base case to prevent
> infinite recursion and the consequent demise of the program.
>
> **The** triangle.java **Program**
>
> Does recursion actually work? If you run the triangle.java program,
> you'll see that it does. Enter a value for the term number, n, and the
> program will display the value of the corresponding triangular number.
> Listing 6.1 shows the triangle.java program.
>
> ***LISTING 6.1*** The triangle.java Program
>
> // triangle.java
>
> // evaluates triangular numbers
>
> // to run this program: C\>java TriangleApp import java.io.\*; // for
> I/O
>
> ////////////////////////////////////////////////////////////////
>
> 256 **CHAPTER 6** Recursion
>
> ***LISTING 6.1*** Continued
>
> class TriangleApp
>
> {
>
> static int theNumber;
>
> public static void main(String\[\] args) throws IOException
>
> {
>
> System.out.print("Enter a number: "); theNumber = getInt();
>
> int theAnswer = triangle(theNumber);
> System.out.println("Triangle="+theAnswer);
>
> } // end main()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static int triangle(int n)
>
> {
>
> if(n==1)
>
> return 1; else
>
> return( n + triangle(n-1) );
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static String getString() throws IOException
>
> {
>
> InputStreamReader isr = new InputStreamReader(System.in);
> BufferedReader br = new BufferedReader(isr);
>
> String s = br.readLine(); return s;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static int getInt() throws IOException
>
> {
>
> String s = getString(); return Integer.parseInt(s);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class TriangleApp
>
> ////////////////////////////////////////////////////////////////
>
> The main() routine prompts the user for a value for n, calls
> triangle(), and displays the return value. The triangle() method calls
> itself repeatedly to do all the work.

Triangular Numbers 257

> Here's some sample output:
>
> Enter a number: 1000 Triangle = 500500
>
> Incidentally, if you're skeptical of the results returned from
> triangle(), you can check them by using the following formula:
>
> nth triangular number = (n2+n)/2

##### What's Really Happening?

> Let's modify the triangle() method to provide an insight into what's
> happening when it executes. We'll insert some output statements to
> keep track of the arguments and return values:
>
> public static int triangle(int n)
>
> {
>
> System.out.println("Entering: n=" + n); if(n==1)
>
> {
>
> System.out.println("Returning 1");
>
> return 1;
>
> }
>
> else
>
> {
>
> int temp = n + triangle(n-1); System.out.println("Returning " + temp);
> return temp;
>
> }
>
> }
>
> Here's the interaction when this method is substituted for the earlier
> triangle()
>
> method and the user enters 5:
>
> Enter a number: 5
>
> Entering: n=5 Entering: n=4 Entering: n=3 Entering: n=2 Entering: n=1
> Returning 1
>
> Returning 3
>
> Returning 6
>
> 258 **CHAPTER 6** Recursion
>
> Returning 10
>
> Returning 15
>
> Triangle = 15
>
> Each time the triangle() method calls itself, its argument, which
> starts at 5, is reduced by 1. The method plunges down into itself
> again and again until its argu- ment is reduced to 1. Then it returns.
> This triggers an entire series of returns. The method rises back up,
> phoenix-like, out of the discarded versions of itself. Each time it
> returns, it adds the value of n it was called with to the return value
> from the method it called.
>
> The return values recapitulate the series of triangular numbers, until
> the answer is returned to main(). Figure 6.4 shows how each invocation
> of the triangle() method can be imagined as being "inside" the
> previous one.

![](media/image97.png)

> Version 1
>
> ![](media/image99.png)n=5
>
> Version 2 n=4
>
> Version 3 n=3
>
> Version 4 n=2
>
> Version 5
>
> n=1 Returns 1
>
> Adds 2
>
> Returns 3
>
> Adds 3
>
> Returns 6
>
> Adds 4
>
> Returns 10
>
> Adds 5
>
> Returns 15
>
> Returns 15
>
> ***FIGURE 6.4*** The recursive triangle() method.

Triangular Numbers 259

> Notice that, just before the innermost version returns a 1, there are
> actually five different incarnations of triangle() in existence at the
> same time. The outer one was passed the argument 5; the inner one was
> passed the argument 1.

##### Characteristics of Recursive Methods

> Although it's short, the triangle() method possesses the key features
> common to all recursive routines:

-   It calls itself.

-   When it calls itself, it does so to solve a smaller problem.

-   There's some version of the problem that is simple enough that the
    routine can solve it, and return, without calling itself.

> In each successive call of a recursive method to itself, the argument
> becomes smaller (or perhaps a range described by multiple arguments
> becomes smaller), reflecting the fact that the problem has become
> "smaller" or easier. When the argument or range reaches a certain
> minimum size, a condition is triggered and the method returns without
> calling itself.

##### Is Recursion Efficient?

> Calling a method involves certain overhead. Control must be
> transferred from the location of the call to the beginning of the
> method. In addition, the arguments to the method and the address to
> which the method should return must be pushed onto an internal stack
> so that the method can access the argument values and know where to
> return.
>
> In the case of the triangle() method, it's probable that, as a result
> of this overhead, the while loop approach executes more quickly than
> the recursive approach. The penalty may not be significant, but if
> there are a large number of method calls as a result of a recursive
> method, it might be desirable to eliminate the recursion. We'll talk
> about this issue more at the end of this chapter.
>
> Another inefficiency is that memory is used to store all the
> intermediate arguments and return values on the system's internal
> stack. This may cause problems if there is a large amount of data,
> leading to stack overflow.
>
> Recursion is usually used because it simplifies a problem
> conceptually, not because it's inherently more efficient.

##### Mathematical Induction

> Recursion is the programming equivalent of mathematical induction.
> Mathematical induction is a way of defining something in terms of
> itself. (The term is also used to
>
> 260 **CHAPTER 6** Recursion
>
> describe a related approach to proving theorems.) Using induction, we
> could define the triangular numbers mathematically by saying
>
> tri(n) = 1 if n = 1
>
> tri(n) = n + tri(n--1) if n \> 1
>
> Defining something in terms of itself may seem circular, but in fact
> it's perfectly valid (provided there's a base case).

#### Factorials

> Factorials are similar in concept to triangular numbers, except that
> multiplication is used instead of addition. The triangular number
> corresponding to n is found by adding n to the triangular number of
> n-1, while the factorial of n is found by multi- plying n by the
> factorial of n-1. That is, the fifth triangular number is 5+4+3+2+1,
> while the factorial of 5 is 5\*4\*3\*2\*1, which equals 120. Table 6.1
> shows the factorials of the first 10 numbers.

+-----------------+-------------------+-----------------+
| ***TABLE 6.1*** | > Factorials      |                 |
+=================+===================+=================+
| **Number**      | > **Calculation** | > **Factorial** |
+-----------------+-------------------+-----------------+
| 0               | > by definition   | > 1             |
+-----------------+-------------------+-----------------+
| 1               | > 1 \* 1          | > 1             |
+-----------------+-------------------+-----------------+
| 2               | > 2 \* 1          | > 2             |
+-----------------+-------------------+-----------------+
| 3               | > 3 \* 2          | > 6             |
+-----------------+-------------------+-----------------+
| 4               | > 4 \* 6          | > 24            |
+-----------------+-------------------+-----------------+
| 5               | > 5 \* 24         | > 120           |
+-----------------+-------------------+-----------------+
| 6               | > 6 \* 120        | > 720           |
+-----------------+-------------------+-----------------+
| 7               | > 7 \* 720        | > 5,040         |
+-----------------+-------------------+-----------------+
| 8               | > 8 \* 5,040      | > 40,320        |
+-----------------+-------------------+-----------------+
| 9               | > 9 \* 40,320     | > 362,880       |
+-----------------+-------------------+-----------------+

> The factorial of 0 is defined to be 1. Factorial numbers grow large
> very rapidly, as you can see.
>
> A recursive method similar to triangle() can be used to calculate
> factorials. It looks like this:
>
> int factorial(int n)
>
> {
>
> if(n==0)
>
> return 1; else
>
> return (n \* factorial(n-1) );
>
> }

Factorials 261

> There are only two differences between factorial() and triangle().
> First, factorial()
>
> uses a \* instead of a + in the expression
>
> n \* factorial(n-1)
>
> Second, the base condition occurs when n is 0, not 1. Here's some
> sample interaction when this method is used in a program similar to
> triangle.java:
>
> Enter a number: 6 Factorial =720
>
> Figure 6.5 shows how the various incarnations of factorial() call
> themselves when initially entered with n=4.
>
> ![](media/image101.png)![](media/image103.png)Version 1 n=4
>
> Version 2 n=3
>
> Version 3 n=2
>
> Version 4 n=1
>
> Version 5 n=0 Return 1
>
> Multiply by 1
>
> Return 1
>
> Multiply by 2
>
> Return 2
>
> Multiply by 3
>
> Return 6
>
> Multiply by 4
>
> Return 24
>
> Returns 24
>
> ***FIGURE 6.5*** The recursive factorial() method.
>
> Calculating factorials is the classic demonstration of recursion,
> although factorials aren't as easy to visualize as triangular numbers.
>
> 262 **CHAPTER 6** Recursion
>
> Various other numerological entities lend themselves to calculation
> using recursion in a similar way, such as finding the greatest common
> denominator of two numbers (which is used to reduce a fraction to
> lowest terms), raising a number to a power, and so on. Again, while
> these calculations are interesting for demonstrating recur- sion, they
> probably wouldn't be used in practice because a loop-based approach is
> more efficient.

#### Anagrams

> Here's a different kind of situation in which recursion provides a
> neat solution to a problem. A permutation is an arrangement of things
> in a definite order. Suppose you want to list all the anagrams of a
> specified word---that is, all possible permutations (whether they make
> a real English word or not) that can be made from the letters of the
> original word. We'll call this *anagramming* a word. Anagramming cat,
> for example, would produce

-   cat

-   cta

-   atc

-   act

-   tca

-   tac

> Try anagramming some words yourself. You'll find that the number of
> possibilities is the factorial of the number of letters. For 3 letters
> there are 6 possible words; for 4 letters there are 24 words; for 5
> letters, 120; and so on. (This assumes that all letters are distinct;
> if there are multiple instances of the same letter, there will be
> fewer possible words.)
>
> How would you write a program to anagram a word? Here's one approach.
> Assume the word has n letters.

1.  Anagram the rightmost n-1 letters.

2.  Rotate all n letters.

3.  Repeat these steps n times.

> To *rotate* the word means to shift all the letters one position left,
> except for the leftmost letter, which "rotates" back to the right, as
> shown in Figure 6.6.

Anagrams 263

![](media/image105.png)![](media/image107.png)![](media/image109.png)![](media/image111.png)Temp
Word

+-----+-----+-----+---+---+
| > o | > d | > e | o | r |
+-----+-----+-----+---+---+

> ![](media/image114.png){width="0.9416611986001749in"
> height="0.22916666666666666in"}![](media/image111.png)***FIGURE 6.6***
> Rotating a word.
>
> Rotating the word n times gives each letter a chance to begin the
> word. While the selected letter occupies this first position, all the
> other letters are then anagrammed (arranged in every possible
> position). For cat, which has only three letters, rotating the
> remaining two letters simply switches them. The sequence is shown in
> Table 6.2.
>
> ***TABLE 6.2*** Anagramming the Word cat

+----------+---------------+--------------+-----------------+--------------+
| **Word** | > **Display** | > **First**  | > **Remaining** | > **Action** |
|          | >             | >            | >               |              |
|          | > **Word?**   | > **Letter** | > **Letters**   |              |
+==========+===============+==============+=================+==============+
| cat      | > Yes         | > c          | > at            | > Rotate at  |
+----------+---------------+--------------+-----------------+--------------+
| cta      | > Yes         | > c          | > ta            | > Rotate ta  |
+----------+---------------+--------------+-----------------+--------------+
| cat      | > No          | > c          | > at            | > Rotate cat |
+----------+---------------+--------------+-----------------+--------------+
| atc      | > Yes         | > a          | > tc            | > Rotate tc  |
+----------+---------------+--------------+-----------------+--------------+
| act      | > Yes         | > a          | > ct            | > Rotate ct  |
+----------+---------------+--------------+-----------------+--------------+
| atc      | > No          | > a          | > tc            | > Rotate atc |
+----------+---------------+--------------+-----------------+--------------+
| tca      | > Yes         | > t          | > ca            | > Rotate ca  |
+----------+---------------+--------------+-----------------+--------------+
| tac      | > Yes         | > t          | > ac            | > Rotate ac  |
+----------+---------------+--------------+-----------------+--------------+
| tca      | > No          | > t          | > ca            | > Rotate tca |
+----------+---------------+--------------+-----------------+--------------+
| cat      | > No          | > c          | > at            | > Done       |
+----------+---------------+--------------+-----------------+--------------+

> Notice that we must rotate back to the starting point with two letters
> before performing a three-letter rotation. This leads to sequences
> like cat, cta, cat. The redundant sequences aren't displayed.
>
> How do we anagram the rightmost n-1 letters? By calling ourselves. The
> recursive doAnagram() method takes the size of the word to be
> anagrammed as its only parame- ter. This word is understood to be the
> rightmost n letters of the complete word. Each
>
> 264 **CHAPTER 6** Recursion
>
> time doAnagram() calls itself, it does so with a word one letter
> smaller than before, as shown in Figure 6.7.
>
> ![](media/image115.png)Display cat
>
> Display cta
>
> Display atc
>
> Display act
>
> Display tca
>
> Display tac
>
> ***FIGURE 6.7*** The recursive doAnagram() method.
>
> The base case occurs when the size of the word to be anagrammed is
> only one letter. There's no way to rearrange one letter, so the method
> returns immediately.
>
> Otherwise, it anagrams all but the first letter of the word it was
> given and then rotates the entire word. These two actions are
> performed n times, where n is the size of the word. Here's the
> recursive routine doAnagram():

Anagrams 265

> public static void doAnagram(int newSize)
>
> {
>
> if(newSize == 1) // if too small, return; // go no further
>
> for(int j=0; j\<newSize; j++) // for each position,
>
> {
>
> doAnagram(newSize-1); // anagram remaining
>
> if(newSize==2) // if innermost, displayWord(); // display it
>
> rotate(newSize); // rotate word
>
> }
>
> }
>
> Each time the doAnagram() method calls itself, the size of the word is
> one letter smaller, and the starting position is one cell further to
> the right, as shown in Figure 6.8.

+-----+-----+-----+-----+
| > n | > e | > t | > s |
+-----+-----+-----+-----+

![](media/image124.png){width="0.8420833333333333in"
height="0.2968744531933508in"}0 1 2 3

> Level 4
>
> Level 3
>
> newSize = 1
>
> position = 3
>
> newSize = 2
>
> position = 2

Level 2

Level 1

***FIGURE 6.8*** Smaller and smaller words.

> newSize = 3
>
> position = 1
>
> newSize = 4
>
> position = 0
>
> Listing 6.2 shows the complete anagram.java program. The main()
> routine gets a word from the user, inserts it into a character array
> so it can be dealt with conveniently, and then calls doAnagram().
>
> ***LISTING 6.2*** The anagram.java Program
>
> // anagram.java
>
> // creates anagrams
>
> // to run this program: C\>java AnagramApp import java.io.\*;
>
> //////////////////////////////////////////////////////////////// class
> AnagramApp
>
> {
>
> 266 **CHAPTER 6** Recursion
>
> ***LISTING 6.2*** Continued static int size; static int count;
>
> static char\[\] arrChar = new char\[100\];
>
> public static void main(String\[\] args) throws IOException
>
> {
>
> System.out.print("Enter a word: "); // get word String input =
> getString();
>
> size = input.length(); // find its size count = 0;
>
> for(int j=0; j\<size; j++) // put it in array arrChar\[j\] =
> input.charAt(j);
>
> doAnagram(size); // anagram it
>
> } // end main()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static void doAnagram(int newSize)
>
> {
>
> if(newSize == 1) // if too small, return; // go no further
>
> for(int j=0; j\<newSize; j++) // for each position,
>
> {
>
> doAnagram(newSize-1); // anagram remaining
>
> if(newSize==2) // if innermost, displayWord(); // display it
>
> rotate(newSize); // rotate word
>
> }
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // rotate left all chars from position to end public static void
> rotate(int newSize)
>
> {
>
> int j;
>
> int position = size - newSize;
>
> char temp = arrChar\[position\]; // save first letter
> for(j=position+1; j\<size; j++) // shift others left

arrChar\[j-1\] = arrChar\[j\];

> arrChar\[j-1\] = temp; // put first on right
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static void displayWord()
>
> {

Anagrams 267

> ***LISTING 6.2*** Continued
>
> if(count \< 99) System.out.print(" ");
>
> if(count \< 9) System.out.print(" ");
>
> System.out.print(++count + " "); for(int j=0; j\<size; j++)
>
> System.out.print( arrChar\[j\] ); System.out.print(" ");
> System.out.flush();
>
> if(count%6 == 0) System.out.println("");
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static String getString() throws IOException
>
> {
>
> InputStreamReader isr = new InputStreamReader(System.in);
> BufferedReader br = new BufferedReader(isr);
>
> String s = br.readLine(); return s;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class AnagramApp
>
> ////////////////////////////////////////////////////////////////
>
> The rotate() method rotates the word one position left as described
> earlier. The displayWord() method displays the entire word and adds a
> count to make it easy to see how many words have been displayed.
> Here's some sample interaction with the program:
>
> Enter a word: cats

+---------+---------+---------+-----------+---------+---------+
| 1 cats  | 2 cast  | 3 ctsa  | > 4 ctas  | 5 csat  | 6 csta  |
+=========+=========+=========+===========+=========+=========+
| 7 atsc  | 8 atcs  | 9 asct  | > 10 astc | 11 acts | 12 acst |
+---------+---------+---------+-----------+---------+---------+
| 13 tsca | 14 tsac | 15 tcas | > 16 tcsa | 17 tasc | 18 tacs |
+---------+---------+---------+-----------+---------+---------+
| 19 scat | 20 scta | 21 satc | > 22 sact | 23 stca | 24 stac |
+---------+---------+---------+-----------+---------+---------+

> (Is it only coincidence that *scat* is an anagram of *cats*?) You can
> use the program to anagram five-letter or even six-letter words.
> However, because the factorial of 6 is 720, anagramming such long
> sequences may generate more words than you want to know about.
>
> 268 **CHAPTER 6** Recursion

#### A Recursive Binary Search

> Remember the binary search we discussed in Chapter 2, "Arrays"? We
> wanted to find a given cell in an ordered array using the fewest
> number of comparisons. The solu- tion was to divide the array in half,
> see which half the desired cell lay in, divide that half in half
> again, and so on. Here's what the original find() method looked like:
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int find(long searchKey)
>
> {
>
> int lowerBound = 0;
>
> int upperBound = nElems-1; int curIn;
>
> while(true)
>
> {
>
> curIn = (lowerBound + upperBound ) / 2; if(a\[curIn\]==searchKey)
>
> return curIn; // found it else if(lowerBound \> upperBound)
>
> return nElems; // can't find it else // divide range
>
> {
>
> if(a\[curIn\] \< searchKey)
>
> lowerBound = curIn + 1; // it's in upper half else
>
> upperBound = curIn - 1; // it's in lower half
>
> } // end else divide range
>
> } // end while
>
> } // end find()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> You might want to reread the section on binary searches in ordered
> arrays in Chapter 2, which describes how this method works. Also, run
> the Ordered Workshop applet from that chapter if you want to see a
> binary search in action.
>
> We can transform this loop-based method into a recursive method quite
> easily. In the loop-based method, we change lowerBound or upperBound
> to specify a new range and then cycle through the loop again. Each
> time through the loop we divide the range (roughly) in half.

##### Recursion Replaces the Loop

> In the recursive approach, instead of changing lowerBound or
> upperBound, we call find() again with the new values of lowerBound or
> upperBound as arguments. The loop disappears, and its place is taken
> by the recursive calls. Here's how that looks:
>
> A Recursive Binary Search 269
>
> private int recFind(long searchKey, int lowerBound,
>
> int upperBound)
>
> {
>
> int curIn;
>
> curIn = (lowerBound + upperBound ) / 2; if(a\[curIn\]==searchKey)
>
> return curIn; // found it else if(lowerBound \> upperBound)
>
> return nElems; // can't find it else // divide range
>
> {
>
> if(a\[curIn\] \< searchKey) // it's in upper half return
> recFind(searchKey, curIn+1, upperBound);
>
> else // it's in lower half return recFind(searchKey, lowerBound,
> curIn-1);
>
> } // end else divide range
>
> } // end recFind()
>
> The class user, represented by main(), may not know how many items are
> in the array when it calls find(), and in any case shouldn't be
> burdened with having to know what values of upperBound and lowerBound
> to set initially. Therefore, we supply an intermediate public method,
> find(), which main() calls with only one argument, the value of the
> search key. The find() method supplies the proper initial values of
> lowerBound and upperBound (0 and nElems-1) and then calls the private,
> recursive method recFind(). The find() method looks like this:
>
> public int find(long searchKey)
>
> {
>
> return recFind(searchKey, 0, nElems-1);
>
> }
>
> Listing 6.3 shows the complete listing for the binarySearch.java
> program.
>
> ***LISTING 6.3*** The binarySearch.java Program
>
> // binarySearch.java
>
> // demonstrates recursive binary search
>
> // to run this program: C\>java BinarySearchApp
>
> //////////////////////////////////////////////////////////////// class
> ordArray
>
> {
>
> private long\[\] a; // ref to array a
>
> 270 **CHAPTER 6** Recursion

***LISTING 6.3*** Continued

> private int nElems; // number of data items
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public ordArray(int max) // constructor
>
> {
>
> a = new long\[max\]; // create array nElems = 0;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int size()
>
> { return nElems; }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int find(long searchKey)
>
> {
>
> return recFind(searchKey, 0, nElems-1);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> private int recFind(long searchKey, int lowerBound,
>
> int upperBound)
>
> {
>
> int curIn;
>
> curIn = (lowerBound + upperBound ) / 2; if(a\[curIn\]==searchKey)
>
> return curIn; // found it else if(lowerBound \> upperBound)
>
> return nElems; // can't find it else // divide range
>
> {
>
> if(a\[curIn\] \< searchKey) // it's in upper half return
> recFind(searchKey, curIn+1, upperBound);
>
> else // it's in lower half return recFind(searchKey, lowerBound,
> curIn-1);
>
> } // end else divide range
>
> } // end recFind()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void insert(long value) // put element into array

> {
>
> int j;
>
> for(j=0; j\<nElems; j++) // find where it goes if(a\[j\] \> value) //
> (linear search)

break;

> A Recursive Binary Search 271
>
> ***LISTING 6.3*** Continued
>
> for(int k=nElems; k\>j; k\--) // move bigger ones up a\[k\] =
> a\[k-1\];
>
> a\[j\] = value; // insert it
>
> nElems++; // increment size
>
> } // end insert()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void display() // displays array contents
>
> {
>
> for(int j=0; j\<nElems; j++) // for each element,
> System.out.print(a\[j\] + " "); // display it
>
> System.out.println("");
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class ordArray
>
> //////////////////////////////////////////////////////////////// class
> BinarySearchApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> int maxSize = 100; // array size
>
> ordArray arr; // reference to array arr = new ordArray(maxSize); //
> create the array
>
> arr.insert(72); // insert items arr.insert(90);
>
> arr.insert(45); arr.insert(126); arr.insert(54); arr.insert(99);
> arr.insert(144); arr.insert(27); arr.insert(135); arr.insert(81);
> arr.insert(18); arr.insert(108); arr.insert(9); arr.insert(117);
> arr.insert(63); arr.insert(36);
>
> 272 **CHAPTER 6** Recursion
>
> ***LISTING 6.3*** Continued
>
> arr.display(); // display array
>
> int searchKey = 27; // search for item if( arr.find(searchKey) !=
> arr.size() )
>
> System.out.println("Found " + searchKey); else
>
> System.out.println("Can't find " + searchKey);
>
> } // end main()
>
> } // end class BinarySearchApp
>
> ////////////////////////////////////////////////////////////////
>
> In main() we insert 16 items into the array. The insert() method
> arranges them in sorted order; they're then displayed. Finally, we use
> find() to try to find the item with a key value of 27. Here's some
> sample output:
>
> 9 18 27 36 45 54 63 72 81 90 99 108 117 126 135 144
>
> Found 27
>
> In binarySearch.java there are 16 items in an array. Figure 6.9 shows
> how the recFind() method in this program calls itself over and over,
> each time with a smaller range than before. When the innermost version
> of the method finds the desired item, which has the key value 27, it
> returns with the index value of the item, which is 2 (as can be seen
> in the display of ordered data). This value is then returned from each
> version of recFind() in turn; finally, find() returns it to the class
> user.
>
> The recursive binary search has the same big O efficiency as the
> non-recursive version: O(logN). It is somewhat more elegant, but may
> be slightly slower.

##### Divide-and-Conquer Algorithms

> The recursive binary search is an example of the *divide-and-conquer*
> approach. You divide the big problem into two smaller problems and
> solve each one separately. The solution to each smaller problem is the
> same: You divide it into two even smaller problems and solve them. The
> process continues until you get to the base case, which can be solved
> easily, with no further division into halves.
>
> The divide-and-conquer approach is commonly used with recursion,
> although, as we saw in the binary search in Chapter 2, you can also
> use a non-recursive approach.
>
> A divide-and-conquer approach usually involves a method that contains
> two recur- sive calls to itself, one for each half of the problem. In
> the binary search, there are two such calls, but only one of them is
> actually executed. (Which one depends on the value of the key.) The
> mergesort, which we'll encounter later in this chapter, actually
> executes both recursive calls (to sort two halves of an array).

The Towers of Hanoi 273

![](media/image125.png)

> ![](media/image129.png)
>
> ***FIGURE 6.9*** The recursive binarySearch() method.

#### The Towers of Hanoi

> The Towers of Hanoi is an ancient puzzle consisting of a number of
> disks placed on three columns, as shown in Figure 6.10.
>
> The disks all have different diameters and holes in the middle so they
> will fit over the columns. All the disks start out on column A. The
> object of the puzzle is to transfer all the disks from column A to
> column C. Only one disk can be moved at a time, and no disk can be
> placed on a disk that's smaller than itself.
>
> 274 **CHAPTER 6** Recursion

![](media/image133.png)

> ***FIGURE 6.10*** The Towers of Hanoi.
>
> There's an ancient myth that somewhere in India, in a remote temple,
> monks labor day and night to transfer 64 golden disks from one of
> three diamond-studded towers to another. When they are finished, the
> world will end. Any alarm you may feel, however, will be dispelled
> when you see how long it takes to solve the puzzle for far fewer than
> 64 disks.

##### The Towers Workshop Applet

> Start up the Towers Workshop applet. You can attempt to solve the
> puzzle yourself by using the mouse to drag the topmost disk to another
> tower. Figure 6.11 shows how the towers look after several moves have
> been made.

![](media/image156.png){width="2.7894641294838145in" height="2.44in"}

> ***FIGURE 6.11*** The Towers Workshop applet.

The Towers of Hanoi 275

> There are three ways to use the Workshop applet:

-   You can attempt to solve the puzzle manually, by dragging the disks
    from tower to tower.

-   You can repeatedly press the Step button to watch the algorithm
    solve the puzzle. At each step in the solution, a message is
    displayed, telling you what the algorithm is doing.

-   You can press the Run button and watch the algorithm solve the
    puzzle with no intervention on your part; the disks zip back and
    forth between the posts.

> To restart the puzzle, type in the number of disks you want to use,
> from 1 to 10, and press New twice. (After the first time, you're asked
> to verify that restarting is what you want to do.) The specified
> number of disks will be arranged on tower A. Once you drag a disk with
> the mouse, you can't use Step or Run; you must start over with New.
> However, you can switch to manual in the middle of stepping or
> running, and you can switch to Step when you're running, and Run when
> you're stepping.
>
> Try solving the puzzle manually with a small number of disks, say
> three or four. Work up to higher numbers. The applet gives you the
> opportunity to learn intu- itively how the problem is solved.

##### Moving Subtrees

> Let's call the initial tree-shaped (or pyramid-shaped) arrangement of
> disks on tower A a *tree*. (This kind of tree has nothing to do with
> the trees that are data storage struc- tures, described elsewhere in
> this book.) As you experiment with the applet, you'll begin to notice
> that smaller tree-shaped stacks of disks are generated as part of the
> solution process. Let's call these smaller trees, containing fewer
> than the total number of disks, *subtrees*. For example, if you're
> trying to transfer four disks, you'll find that one of the
> intermediate steps involves a subtree of three disks on tower B, as
> shown in Figure 6.12.

![](media/image157.png)

> ***FIGURE 6.12*** A subtree on tower B.
>
> These subtrees form many times in the solution of the puzzle. This
> happens because the creation of a subtree is the only way to transfer
> a larger disk from one tower to
>
> 276 **CHAPTER 6** Recursion
>
> another: All the smaller disks must be placed on an intermediate
> tower, where they naturally form a subtree.
>
> Here's a rule of thumb that may help when you try to solve the puzzle
> manually. If the subtree you're trying to move has an odd number of
> disks, start by moving the topmost disk directly to the tower where
> you want the subtree to go. If you're trying to move a subtree with an
> even number of disks, start by moving the topmost disk to the
> intermediate tower.

##### The Recursive Algorithm

> The solution to the Towers of Hanoi puzzle can be expressed
> recursively using the notion of subtrees. Suppose you want to move all
> the disks from a source tower (call it S) to a destination tower (call
> it D). You have an intermediate tower available (call it I). Assume
> there are n disks on tower S. Here's the algorithm:

1.  Move the subtree consisting of the top n-1 disks from S to I.

2.  Move the remaining (largest) disk from S to D.

3.  Move the subtree from I to D.

> When you begin, the source tower is A, the intermediate tower is B,
> and the destination tower is C. Figure 6.13 shows the three steps for
> this situation.
>
> First, the subtree consisting of disks 1, 2, and 3 is moved to the
> intermediate tower B. Then the largest disk, 4, is moved to tower C.
> Then the subtree is moved from
>
> B to C.
>
> Of course, this solution doesn't solve the problem of how to move the
> subtree consisting of disks 1, 2, and 3 to tower B, because you can't
> move a subtree all at once; you must move it one disk at a time.
> Moving the three-disk subtree is not so easy. However, it's easier
> than moving four disks.
>
> As it turns out, moving three disks from A to the destination tower B
> can be done with the same three steps as moving four disks. That is,
> move the subtree consisting of the top two disks from tower A to
> intermediate tower C; then move disk 3 from A to B. Then move the
> subtree back from C to B.
>
> How do you move a subtree of two disks from A to C? Move the subtree
> consisting of only one disk (1) from A to B. This is the base case:
> When you're moving only one disk, you just move it; there's nothing
> else to do. Then move the larger disk (2) from A to C, and replace the
> subtree (disk 1) on it.

The Towers of Hanoi 277

> ![](media/image166.png)Subtree
>
> a)
>
> ![](media/image176.png)b)
>
> ![](media/image183.png)c)
>
> A B C 1
>
> Puzzle is solved!
>
> 2
>
> 3
>
> 4
>
> d)
>
> ![](media/image189.png)***FIGURE 6.13*** Recursive solution to towers
> puzzle.
>
> **The** towers.java **Program**
>
> The towers.java program solves the Towers of Hanoi puzzle using this
> recursive approach. It communicates the moves by displaying them; this
> approach requires much less code than displaying the towers. It's up
> to the human reading the list to actually carry out the moves.
>
> The code is simplicity itself. The main() routine makes a single call
> to the recursive method doTowers(). This method then calls itself
> recursively until the puzzle is solved. In this version, shown in
> Listing 6.4, there are initially only three disks, but you can
> recompile the program with any number.
>
> 278 **CHAPTER 6** Recursion
>
> ***LISTING 6.4*** The towers.java Program
>
> // towers.java
>
> // solves the towers of Hanoi puzzle
>
> // to run this program: C\>java TowersApp
>
> //////////////////////////////////////////////////////////////// class
> TowersApp
>
> {
>
> static int nDisks = 3;
>
> public static void main(String\[\] args)
>
> {
>
> doTowers(nDisks, 'A', 'B', 'C');
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static void doTowers(int topN,
>
> char from, char inter, char to)
>
> {
>
> if(topN==1)
>
> System.out.println("Disk 1 from " + from + " to "+ to); else
>
> {
>
> doTowers(topN-1, from, to, inter); // from\--\>inter
>
> System.out.println("Disk " + topN +
>
> \" from " + from + " to "+ to); doTowers(topN-1, inter, from, to); //
> inter\--\>to
>
> }
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class TowersApp
>
> ////////////////////////////////////////////////////////////////
>
> Remember that three disks are moved from A to C. Here's the output
> from the program:
>
> Disk 1 from A to C Disk 2 from A to B Disk 1 from C to B Disk 3 from A
> to C Disk 1 from B to A Disk 2 from B to C Disk 1 from A to C

mergesort 279

> The arguments to doTowers() are the number of disks to be moved, and
> the source (from), intermediate (inter), and destination (to) towers
> to be used. The number of disks decreases by 1 each time the method
> calls itself. The source, intermediate, and destination towers also
> change.
>
> Here is the output with additional notations that show when the method
> is entered and when it returns, its arguments, and whether a disk is
> moved because it's the base case (a subtree consisting of only one
> disk) or because it's the remaining bottom disk after a subtree has
> been moved:
>
> Enter (3 disks): s=A, i=B, d=C Enter (2 disks): s=A, i=C, d=B
>
> Enter (1 disk): s=A, i=B, d=C
>
> Base case: move disk 1 from A to C Return (1 disk)
>
> Move bottom disk 2 from A to B Enter (1 disk): s=C, i=A, d=B
>
> Base case: move disk 1 from C to B Return (1 disk)
>
> Return (2 disks)
>
> Move bottom disk 3 from A to C Enter (2 disks): s=B, i=A, d=C
>
> Enter (1 disk): s=B, i=C, d=A
>
> Base case: move disk 1 from B to A Return (1 disk)
>
> Move bottom disk 2 from B to C Enter (1 disk): s=A, i=B, d=C
>
> Base case: move disk 1 from A to C Return (1 disk)
>
> Return (2 disks)
>
> Return (3 disks)
>
> If you study this output along with the source code for doTower(), it
> should become clear exactly how the method works. It's amazing that
> such a small amount of code can solve such a seemingly complicated
> problem.

#### mergesort {#mergesort-1}

> Our final example of recursion is the mergesort. This is a much more
> efficient sorting technique than those we saw in Chapter 3, "Simple
> Sorting," at least in terms of speed. While the bubble, insertion, and
> selection sorts take O(N2) time, the merge- sort is O(N\*logN). The
> graph in Figure 2.9 (in Chapter 2) shows how much faster this is. For
> example, if N (the number of items to be sorted) is 10,000, then N2 is
>
> 280 **CHAPTER 6** Recursion
>
> 100,000,000, while N\*logN is only 40,000. If sorting this many items
> required 40 seconds with the mergesort, it would take almost 28 hours
> for the insertion sort.
>
> The mergesort is also fairly easy to implement. It's conceptually
> easier than quicksort and the Shell short, which we'll encounter in
> the next chapter.
>
> The downside of the mergesort is that it requires an additional array
> in memory, equal in size to the one being sorted. If your original
> array barely fits in memory, the mergesort won't work. However, if you
> have enough space, it's a good choice.

##### Merging Two Sorted Arrays

> The heart of the mergesort algorithm is the merging of two
> already-sorted arrays. Merging two sorted arrays A and B creates a
> third array, C, that contains all the elements of A and B, also
> arranged in sorted order. We'll examine the merging process first;
> later we'll see how it's used in sorting.
>
> Imagine two sorted arrays. They don't need to be the same size. Let's
> say array A has 4 elements and array B has 6. They will be merged into
> an array C that starts with 10 empty cells. Figure 6.14 shows these
> arrays.

+------+------+------+------+
| > 23 | > 47 | > 81 | > 95 |
| >    | >    | >    | >    |
| > 0  | > 1  | > 2  | > 3  |
+------+------+------+------+

![](media/image196.png)C

+-----+------+------+------+------+------+
| > 7 | > 14 | > 39 | > 55 | > 62 | > 74 |
+=====+======+======+======+======+======+
| > 0 | > 1  | > 2  | > 3  | > 4  | > 5  |
+-----+------+------+------+------+------+

a)  Before Merge

> C ![](media/image200.png){width="2.0172386264216975in"
> height="0.23061023622047244in"}

b)  After Merge

> ***FIGURE 6.14*** Merging two arrays.
>
> In the figure, the circled numbers indicate the order in which
> elements are trans- ferred from A and B to C. Table 6.3 shows the
> comparisons necessary to determine which element will be copied. The
> steps in the table correspond to the steps in the figure. Following
> each comparison, the smaller element is copied to A.

mergesort 281

+-----------------+---------------------------+-----------------------+
| ***TABLE 6.3*** | > Merging Operations      |                       |
+=================+===========================+=======================+
| **Step**        | > **Comparison (If Any)** | > **Copy**            |
+-----------------+---------------------------+-----------------------+
| 1               | > Compare 23 and 7        | > Copy 7 from B to C  |
+-----------------+---------------------------+-----------------------+
| 2               | > Compare 23 and 14       | > Copy 14 from B to C |
+-----------------+---------------------------+-----------------------+
| 3               | > Compare 23 and 39       | > Copy 23 from A to C |
+-----------------+---------------------------+-----------------------+
| 4               | > Compare 39 and 47       | > Copy 39 from B to C |
+-----------------+---------------------------+-----------------------+
| 5               | > Compare 55 and 47       | > Copy 47 from A to C |
+-----------------+---------------------------+-----------------------+
| 6               | > Compare 55 and 81       | > Copy 55 from B to C |
+-----------------+---------------------------+-----------------------+
| 7               | > Compare 62 and 81       | > Copy 62 from B to C |
+-----------------+---------------------------+-----------------------+
| 8               | > Compare 74 and 81       | > Copy 74 from B to C |
+-----------------+---------------------------+-----------------------+
| 9               |                           | > Copy 81 from A to C |
+-----------------+---------------------------+-----------------------+
| 10              |                           | > Copy 95 from A to C |
+-----------------+---------------------------+-----------------------+

> Notice that, because B is empty following step 8, no more comparisons
> are necessary; all the remaining elements are simply copied from A
> into C.
>
> Listing 6.5 shows a Java program that carries out the merge shown in
> Figure 6.14 and Table 6.3. This is not a recursive program; it is a
> prelude to understanding mergesort.
>
> ***LISTING 6.5*** The merge.java Program
>
> // merge.java
>
> // demonstrates merging two arrays into a third
>
> // to run this program: C\>java MergeApp
>
> //////////////////////////////////////////////////////////////// class
> MergeApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> int\[\] arrayA = {23, 47, 81, 95};
>
> int\[\] arrayB = {7, 14, 39, 55, 62, 74};
>
> int\[\] arrayC = new int\[10\];
>
> merge(arrayA, 4, arrayB, 6, arrayC);
>
> display(arrayC, 10);
>
> } // end main()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // merge A and B into C public static void merge( int\[\] arrayA, int
> sizeA,
>
> int\[\] arrayB, int sizeB, int\[\] arrayC )
>
> {
>
> 282 **CHAPTER 6** Recursion
>
> ***LISTING 6.5*** Continued
>
> int aDex=0, bDex=0, cDex=0;
>
> while(aDex \< sizeA && bDex \< sizeB) // neither array empty if(
> arrayA\[aDex\] \< arrayB\[bDex\] )
>
> arrayC\[cDex++\] = arrayA\[aDex++\]; else
>
> arrayC\[cDex++\] = arrayB\[bDex++\];
>
> while(aDex \< sizeA) // arrayB is empty, arrayC\[cDex++\] =
> arrayA\[aDex++\]; // but arrayA isn't
>
> while(bDex \< sizeB) // arrayA is empty, arrayC\[cDex++\] =
> arrayB\[bDex++\]; // but arrayB isn't
>
> } // end merge()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // display array public static void display(int\[\] theArray, int
> size)
>
> {
>
> for(int j=0; j\<size; j++) System.out.print(theArray\[j\] + " ");
>
> System.out.println("");
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class MergeApp
>
> ////////////////////////////////////////////////////////////////
>
> In main() the arrays arrayA, arrayB, and arrayC are created; then the
> merge() method is called to merge arrayA and arrayB into arrayC, and
> the resulting contents of arrayC are displayed. Here's the output:
>
> 7 14 23 39 47 55 62 74 81 95
>
> The merge() method has three while loops. The first steps along both
> arrayA and
>
> arrayB, comparing elements and copying the smaller of the two into
> arrayC.
>
> The second while loop deals with the situation when all the elements
> have been transferred out of arrayB, but arrayA still has remaining
> elements. (This is what happens in the example, where 81 and 95 remain
> in arrayA.) The loop simply copies the remaining elements from arrayA
> into arrayC.
>
> The third loop handles the similar situation when all the elements
> have been trans- ferred out of arrayA, but arrayB still has remaining
> elements; they are copied to arrayC.

mergesort 283

##### Sorting by Merging

> The idea in the mergesort is to divide an array in half, sort each
> half, and then use the merge() method to merge the two halves into a
> single sorted array. How do you sort each half? This chapter is about
> recursion, so you probably already know the answer: You divide the
> half into two quarters, sort each of the quarters, and merge them to
> make a sorted half.
>
> Similarly, each pair of 8ths is merged to make a sorted quarter, each
> pair of 16ths is merged to make a sorted 8th, and so on. You divide
> the array again and again until you reach a subarray with only one
> element. This is the base case; it's assumed an array with one element
> is already sorted.
>
> We've seen that generally something is reduced in size each time a
> recursive method calls itself, and built back up again each time the
> method returns. In mergeSort() the range is divided in half each time
> this method calls itself, and each time it returns it merges two
> smaller ranges into a larger one.
>
> As mergeSort() returns from finding two arrays of one element each, it
> merges them into a sorted array of two elements. Each pair of
> resulting 2-element arrays is then merged into a 4-element array. This
> process continues with larger and larger arrays until the entire array
> is sorted. This is easiest to see when the original array size is a
> power of 2, as shown in Figure 6.15.
>
> First, in the bottom half of the array, range 0-0 and range 1-1 are
> merged into range 0-1. Of course, 0-0 and 1-1 aren't really ranges;
> they're only one element, so they are base cases. Similarly, 2-2 and
> 3-3 are merged into 2-3. Then ranges 0-1 and 2-3 are
>
> merged into 0-3.
>
> In the top half of the array, 4-4 and 5-5 are merged into 4-5, 6-6 and
> 7-7 are merged into 6-7, and 4-5 and 6-7 are merged into 4-7. Finally,
> the top half, 0-3, and the bottom half, 4-7, are merged into the
> complete array, 0-7, which is now sorted.
>
> When the array size is not a power of 2, arrays of different sizes
> must be merged. For example, Figure 6.16 shows the situation when the
> array size is 12. Here an array of size 2 must be merged with an array
> of size 1 to form an array of size 3.
>
> First, the 1-element ranges 0-0 and 1-1 are merged into the 2-element
> range 0-1. Then range 0-1 is merged with the 1-element range 2-2. This
> creates a 3-element range 0-2. It's merged with the 3-element range
> 3-5. The process continues until the array is sorted.
>
> Notice that in mergesort we don't merge two separate arrays into a
> third one, as we demonstrated in the merge.java program. Instead, we
> merge parts of a single array into itself.
>
> 284 **CHAPTER 6** Recursion

+----+------+------+------+------+------+------+---+
| 0  | > 1  | 2    | > 3  | 4    | 5    | > 6  | 7 |
+====+======+======+======+======+======+======+===+
| 64 | > 21 | > 33 | > 70 | > 12 | > 85 | > 44 | 3 |
+----+------+------+------+------+------+------+---+

> ![](media/image201.png)![](media/image202.png)❶
>
> ❸

+-----+------+------+------+
| > 3 | > 12 | > 44 | > 85 |
+-----+------+------+------+

> ❼
>
> ***FIGURE 6.15*** Merging larger and larger arrays.
>
> You may wonder where all these subarrays are located in memory. In the
> algorithm, a workspace array of the same size as the original array is
> created. The subarrays are stored in sections of the workspace array.
> This means that subarrays in the original array are copied to
> appropriate places in the workspace array. After each merge, the
> workspace array is copied back into the original array.

mergesort 285

0 1 2 3

> 4 5 6 7 8
>
> 9 10 11
>
> ![](media/image220.png){width="3.78630249343832in" height="0.375in"}
>
> ![](media/image221.png)❶
>
> ![](media/image222.png){width="0.9888188976377953in"
> height="0.3784580052493438in"}❷

![](media/image223.png){width="0.6616721347331583in"
height="0.375in"}![](media/image224.png){width="0.9934273840769904in"
height="0.3802077865266842in"}![](media/image225.png){width="0.6708869203849519in"
height="0.3802077865266842in"}![](media/image226.png){width="0.9934503499562555in"
height="0.3802077865266842in"}![](media/image227.png){width="0.6708475503062117in"
height="0.3802077865266842in"}![](media/image228.png){width="0.9933409886264217in"
height="0.3802077865266842in"}

> ![](media/image229.png){width="1.9476104549431321in"
> height="0.3784580052493438in"}❾

![](media/image230.png){width="1.9299693788276466in"
height="0.375in"}![](media/image231.png)

> ***FIGURE 6.16*** Array size not a power of 2.

##### The MergeSort Workshop Applet

> This sorting process is easier to appreciate when you see it happening
> before your very eyes. Start up the MergeSort Workshop applet.
> Repeatedly pressing the Step
>
> 286 **CHAPTER 6** Recursion
>
> button will execute mergesort step by step. Figure 6.17 shows what it
> looks like after the first three presses.

![](media/image232.png){width="2.355391513560805in"
height="2.2866655730533685in"}

> ***FIGURE 6.17*** The MergeSort Workshop applet.
>
> The Lower and Upper arrows show the range currently being considered
> by the algo- rithm, and the Mid arrow shows the middle part of the
> range. The range starts as the entire array and then is halved each
> time the mergeSort() method calls itself. When the range is one
> element, mergeSort() returns immediately; that's the base case.
>
> Otherwise, the two subarrays are merged. The applet provides messages,
> such as
>
> Entering mergeSort: 0-5, to tell you what it's doing and the range
> it's operating on.
>
> Many steps involve the mergeSort() method calling itself or returning.
> Comparisons and copies are performed only during the merge process,
> when you'll see messages like Merged 0-0 and 1-1 into workspace. You
> can't see the merge happening because the workspace isn't shown.
> However, you can see the result when the appropriate section of the
> workspace is copied back into the original (visible) array: The bars
> in the specified range will appear in sorted order.
>
> First, the first two bars will be sorted, then the first three bars,
> then the two bars in the range 3-4, then the three bars in the range
> 3-5, then the six bars in the range 0- 5, and so on, corresponding to
> the sequence shown in Figure 6.16. Eventually, all the bars will be
> sorted.
>
> You can cause the algorithm to run continuously by pressing the Run
> button. You can stop this process at any time by pressing Step,
> single-step as many times as you want, and resume running by pressing
> Run again.
>
> As in the other sorting Workshop applets, pressing New resets the
> array with a new group of unsorted bars, and toggles between random
> and inverse arrangements. The Size button toggles between 12 bars and
> 100 bars.

mergesort 287

> Watching the algorithm run with 100 inversely sorted bars is
> especially instructive. The resulting patterns show clearly how each
> range is sorted individually and merged with its other half, and how
> the ranges grow larger and larger.
>
> **The** mergeSort.java **Program**
>
> In a moment we'll look at the entire mergeSort.java program. First,
> let's focus on the method that carries out the mergesort. Here it is:
>
> private void recMergeSort(long\[\] workSpace, int lowerBound,
>
> int upperBound)
>
> {
>
> if(lowerBound == upperBound) // if range is 1, return; // no use
> sorting
>
> else
>
> { // find midpoint
>
> int mid = (lowerBound+upperBound) / 2;
>
> // sort low half recMergeSort(workSpace, lowerBound, mid);
>
> // sort high half recMergeSort(workSpace, mid+1, upperBound);
>
> // merge them merge(workSpace, lowerBound, mid+1, upperBound);
>
> } // end else
>
> } // end recMergeSort
>
> As you can see, besides the base case, there are only four statements
> in this method. One computes the midpoint, there are two recursive
> calls to recMergeSort() (one for each half of the array), and finally
> a call to merge() to merge the two sorted halves. The base case occurs
> when the range contains only one element (lowerBound==upperBound) and
> results in an immediate return.
>
> In the mergeSort.java program, the mergeSort() method is the one
> actually seen by the class user. It creates the array workSpace\[\]
> and then calls the recursive routine recMergeSort() to carry out the
> sort. The creation of the workspace array is handled in mergeSort()
> because doing it in recMergeSort() would cause the array to be created
> anew with each recursive call, an inefficiency.
>
> The merge() method in the previous merge.java program (Listing 6.5)
> operated on three separate arrays: two source arrays and a destination
> array. The merge() routine in the mergeSort.java program operates on a
> single array: the theArray member of the DArray class. The arguments
> to this merge() method are the starting point of the low- half
> subarray, the starting point of the high-half subarray, and the upper
> bound of the high-half subarray. The method calculates the sizes of
> the subarrays based on this information.
>
> 288 **CHAPTER 6** Recursion
>
> Listing 6.6 shows the complete mergeSort.java program, which uses a
> variant of the array classes from Chapter 2, adding the mergeSort()
> and recMergeSort() methods to the DArray class. The main() routine
> creates an array, inserts 12 items, displays the array, sorts the
> items with mergeSort(), and displays the array again.
>
> ***LISTING 6.6*** The mergeSort.java Program
>
> // mergeSort.java
>
> // demonstrates recursive merge sort
>
> // to run this program: C\>java MergeSortApp
>
> //////////////////////////////////////////////////////////////// class
> DArray
>
> {
>
> private long\[\] theArray; // ref to array theArray private int
> nElems; // number of data items
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public DArray(int max) // constructor
>
> {
>
> theArray = new long\[max\]; // create array nElems = 0;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insert(long value) // put element into array
>
> {
>
> theArray\[nElems\] = value; // insert it nElems++; // increment size
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void display() // displays array contents
>
> {
>
> for(int j=0; j\<nElems; j++) // for each element,
> System.out.print(theArray\[j\] + " "); // display it
>
> System.out.println("");
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void mergeSort() // called by main()
>
> { // provides workspace
>
> long\[\] workSpace = new long\[nElems\]; recMergeSort(workSpace, 0,
> nElems-1);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> private void recMergeSort(long\[\] workSpace, int lowerBound,
>
> int upperBound)
>
> {

mergesort 289

> ***LISTING 6.6*** Continued
>
> if(lowerBound == upperBound) // if range is 1, return; // no use
> sorting
>
> else
>
> { // find midpoint
>
> int mid = (lowerBound+upperBound) / 2;
>
> // sort low half recMergeSort(workSpace, lowerBound, mid);
>
> // sort high half recMergeSort(workSpace, mid+1, upperBound);
>
> // merge them merge(workSpace, lowerBound, mid+1, upperBound);
>
> } // end else
>
> } // end recMergeSort()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> private void merge(long\[\] workSpace, int lowPtr,
>
> int highPtr, int upperBound)
>
> {
>
> int j = 0; // workspace index
>
> int lowerBound = lowPtr; int mid = highPtr-1;
>
> int n = upperBound-lowerBound+1; // \# of items
>
> while(lowPtr \<= mid && highPtr \<= upperBound) if( theArray\[lowPtr\]
> \< theArray\[highPtr\] )
>
> workSpace\[j++\] = theArray\[lowPtr++\]; else
>
> workSpace\[j++\] = theArray\[highPtr++\];
>
> while(lowPtr \<= mid)
>
> workSpace\[j++\] = theArray\[lowPtr++\];
>
> while(highPtr \<= upperBound) workSpace\[j++\] =
> theArray\[highPtr++\];
>
> for(j=0; j\<n; j++) theArray\[lowerBound+j\] = workSpace\[j\];
>
> } // end merge()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class DArray
>
> //////////////////////////////////////////////////////////////// class
> MergeSortApp
>
> {
>
> 290 **CHAPTER 6** Recursion
>
> ***LISTING 6.6*** Continued
>
> public static void main(String\[\] args)
>
> {
>
> int maxSize = 100; // array size
>
> DArray arr; // reference to array arr = new DArray(maxSize); // create
> the array
>
> arr.insert(64); // insert items arr.insert(21);
>
> arr.insert(33); arr.insert(70); arr.insert(12); arr.insert(85);
> arr.insert(44); arr.insert(3); arr.insert(99); arr.insert(0);
> arr.insert(108); arr.insert(36);
>
> arr.display(); // display items
>
> arr.mergeSort(); // merge sort the array
>
> arr.display(); // display items again
>
> } // end main()
>
> } // end class MergeSortApp
>
> ////////////////////////////////////////////////////////////////
>
> The output from the program is simply the display of the unsorted and
> sorted arrays:
>
> 64 21 33 70 12 85 44 3 99 0 108 36
>
> 0 3 12 21 33 36 44 64 70 85 99 108
>
> If we put additional statements in the recMergeSort() method, we could
> generate a running commentary on what the program does during a sort.
> The following output shows how this might look for the four-item array
> {64, 21, 33, 70}. (You can think of this as the lower half of the
> array in Figure 6.15.)
>
> Entering 0-3
>
> Will sort low half of 0-3 Entering 0-1
>
> Will sort low half of 0-1

mergesort 291

> Entering 0-0
>
> Base-Case Return 0-0 Will sort high half of 0-1
>
> Entering 1-1
>
> Base-Case Return 1-1 Will merge halves into 0-1
>
> Return 0-1 theArray=21 64 33 70 Will sort high half of 0-3
>
> Entering 2-3
>
> Will sort low half of 2-3 Entering 2-2
>
> Base-Case Return 2-2 Will sort high half of 2-3
>
> Entering 3-3
>
> Base-Case Return 3-3 Will merge halves into 2-3
>
> Return 2-3 theArray=21 64 33 70 Will merge halves into 0-3
>
> Return 0-3 theArray=21 33 64 70
>
> This is roughly the same content as would be generated by the
> MergeSort Workshop applet if it could sort four items. Study of this
> output, and comparison with the code for recMergeSort() and Figure
> 6.15, will reveal the details of the sorting process.

##### Efficiency of the mergesort

> As we noted, the mergesort runs in O(N\*logN) time. How do we know
> this? Let's see how we can figure out the number of times a data item
> must be copied and the number times it must be compared with another
> data item during the course of the algorithm. We assume that copying
> and comparing are the most time-consuming operations; that the
> recursive calls and returns don't add much overhead.

####### Number of Copies

> Consider Figure 6.15. Each cell below the top line represents an
> element copied from the array into the workspace.
>
> Adding up all the cells in Figure 6.15 (the seven numbered steps)
> shows there are 24 copies necessary to sort 8 items. Log28 is 3, so
> 8\*log28 equals 24. This shows that, for the case of 8 items, the
> number of copies is proportional to N\*log2N.
>
> Another way to look at this calculation is that, to sort 8 items
> requires 3 *levels*, each of which involves 8 copies. A level means
> all copies into the same size subarray. In the first level, there are
> four 2-element subarrays; in the second level, there are two 4-element
> subarrays; and in the third level, there is one 8-element subarray.
> Each level has 8 elements, so again there are 3\*8 or 24 copies.
>
> 292 **CHAPTER 6** Recursion
>
> In Figure 6.15, by considering only half the graph, you can see that 8
> copies are necessary for an array of 4 items (steps 1, 2, and 3), and
> 2 copies are necessary for 2 items. Similar calculations provide the
> number of copies necessary for larger arrays. Table 6.4 summarizes
> this information.
>
> ***TABLE 6.4*** Number of Operations When N Is a Power of 2

+-------------+-------------+-------------+-------------+-------------+
|             | > **Number  |             | > **Compari |
|             | > of Copies |             | sons**      |
|             | > into**    |             |             |
|             | >           |             |             |
|             | > **Workspa |             |             |
|             | ce**        |             |             |
+=============+=============+=============+=============+=============+
| **N**       | > **log2N** | > **(N\*log | > **Total   | > **Max     |
|             |             | 2N)**       | > Copies**  | > (Min)**   |
+-------------+-------------+-------------+-------------+-------------+
| 2           | > 1         | > 2         | > 4         | > 1 (1)     |
+-------------+-------------+-------------+-------------+-------------+
| 4           | > 2         | > 8         | > 16        | > 5 (4)     |
+-------------+-------------+-------------+-------------+-------------+
| 8           | > 3         | > 24        | > 48        | > 17 (12)   |
+-------------+-------------+-------------+-------------+-------------+
| 16          | > 4         | > 64        | > 128       | > 49 (32)   |
+-------------+-------------+-------------+-------------+-------------+
| 32          | > 5         | > 160       | > 320       | > 129 (80)  |
+-------------+-------------+-------------+-------------+-------------+
| 64          | > 6         | > 384       | > 768       | > 321 (192) |
+-------------+-------------+-------------+-------------+-------------+
| 128         | > 7         | > 896       | > 1792      | > 769 (448) |
+-------------+-------------+-------------+-------------+-------------+

> Actually, the items are not only copied into the workspace, they're
> also copied back into the original array. This doubles the number of
> copies, as shown in the Total Copies column. The final column of Table
> 6.4 shows comparisons, which we'll return to in a moment.
>
> It's harder to calculate the number of copies and comparisons when N
> is not a multi- ple of 2, but these numbers fall between those that
> are a power of 2. For 12 items, there are 88 total copies, and for 100
> items, 1,344 total copies.

####### Number of Comparisons

> In the mergesort algorithm, the number of comparisons is always
> somewhat less than the number of copies. How much less? Assuming the
> number of items is a power of 2, for each individual merging
> operation, the maximum number of comparisons is always one less than
> the number of items being merged, and the minimum is half the number
> of items being merged. You can see why this is true in Figure 6.18,
> which shows two possibilities when trying to merge two arrays of four
> items each.
>
> In the first case, the items interleave, and seven comparisons must be
> made to merge them. In the second case, all the items in one array are
> smaller than all the items in the other, so only four comparisons need
> be made.
>
> There are many merges for each sort, so we must add the comparisons
> for each one. Referring back to Figure 6.15, you can see that seven
> merge operations are required to sort eight items. The number of items
> being merged and the resulting number of comparisons are shown in
> Table 6.5.

mergesort 293

> ![](media/image233.png)![](media/image235.png){width="0.7664435695538058in"
> height="0.23061351706036745in"}Comparisons 1. 12-24
>
> 2\. 24-34
>
> 3\. 34-47
>
> C 4. 47-55
>
> 5\. 55-63
>
> 6\. 63-79
>
> 7\. 79-85

+------+------+------+------+
| > 12 | > 34 | > 55 | > 79 |
+------+------+------+------+

a)  ![](media/image233.png)Worst-case Scenario

+------+------+------+------+
| > 12 | > 24 | > 34 | > 47 |
+------+------+------+------+

  -- -- -- -- -- -- -- --
                       
  -- -- -- -- -- -- -- --

+------+------+------+------+
| > 55 | > 63 | > 79 | > 85 |
+------+------+------+------+

b)  Best-case Scenario

> ***FIGURE 6.18*** Maximum and minimum comparisons.
>
> Comparisons 1. 12-55
>
> 2\. 24-55
>
> 3\. 34-55
>
> 4\. 47-55
>
> ***TABLE 6.5*** Comparisons Involved in Sorting 8 Items

+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| **Ste | > **1 | > **2 | **3** | > **4 | > **5 | > **6 | > **7 | > **T |
| p     | **    | **    |       | **    | **    | **    | **    | otals |
| Numbe |       |       |       |       |       |       |       | **    |
| r**   |       |       |       |       |       |       |       |       |
+=======+=======+=======+=======+=======+=======+=======+=======+=======+
| Numbe | > 2   | > 2   | 4     | > 2   | > 2   | > 4   | > 8   | > 24  |
| r     |       |       |       |       |       |       |       |       |
| of    |       |       |       |       |       |       |       |       |
| items |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| being |       |       |       |       |       |       |       |       |
| merge |       |       |       |       |       |       |       |       |
| d     |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| (N)   |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| Maxim | > 1   | > 1   | 3     | > 1   | > 1   | > 3   | > 7   | > 17  |
| um    |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| compa |       |       |       |       |       |       |       |       |
| rison |       |       |       |       |       |       |       |       |
| s     |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| (N-1) |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| Minim | > 1   | > 1   | 2     | > 1   | > 1   | > 2   | > 4   | > 12  |
| um    |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| compa |       |       |       |       |       |       |       |       |
| rison |       |       |       |       |       |       |       |       |
| s     |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
| (N/2) |       |       |       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+

> For each merge, the maximum number of comparisons is one less than the
> number of items. Adding these figures for all the merges gives us a
> total of 17.
>
> The minimum number of comparisons is always half the number of items
> being merged, and adding these figures for all the merges results in
> 12 comparisons. Similar arithmetic results in the Comparisons columns
> for Table 6.4. The actual
>
> 294 **CHAPTER 6** Recursion
>
> number of comparisons to sort a specific array depends on how the data
> is arranged, but it will be somewhere between the maximum and minimum
> values.

#### Eliminating Recursion

> Some algorithms lend themselves to a recursive approach, some don't.
> As we've seen, the recursive triangle() and factorial() methods can be
> implemented more effi- ciently using a simple loop. However, various
> divide-and-conquer algorithms, such as mergesort, work very well as
> recursive routines.
>
> Often an algorithm is easy to conceptualize as a recursive method, but
> in practice the recursive approach proves to be inefficient. In such
> cases, it's useful to transform the recursive approach into a
> non-recursive approach. Such a transformation can often make use of a
> stack.

##### Recursion and Stacks

> There is a close relationship between recursion and stacks. In fact,
> most compilers implement recursion by using stacks. As we noted, when
> a method is called, the compiler pushes the arguments to the method
> and the return address (where control will go when the method returns)
> on the stack, and then transfers control to the method. When the
> method returns, it pops these values off the stack. The arguments
> disappear, and control returns to the return address.

##### Simulating a Recursive Method

> In this section we'll demonstrate how any recursive solution can be
> transformed into a stack-based solution. Remember the recursive
> triangle() method from the first section in this chapter? Here it is
> again:
>
> int triangle(int n)
>
> {
>
> if(n==1)
>
> return 1; else
>
> return( n + triangle(n-1) );
>
> }
>
> We're going to break this algorithm down into its individual
> operations, making each operation one case in a switch statement. (You
> can perform a similar decompo- sition using goto statements in C++ and
> some other languages, but Java doesn't support goto.)
>
> The switch statement is enclosed in a method called step(). Each call
> to step() causes one case section within the switch to be executed.
> Calling step() repeatedly will eventually execute all the code in the
> algorithm.

Eliminating Recursion 295

> The triangle() method we just saw performs two kinds of operations.
> First, it carries out the arithmetic necessary to compute triangular
> numbers. This involves checking if n is 1, and adding n to the results
> of previous recursive calls. However, triangle() also performs the
> operations necessary to manage the method itself, including trans- fer
> of control, argument access, and the return address. These operations
> are not visible by looking at the code; they're built into all
> methods. Here, roughly speaking, is what happens during a call to a
> method:

-   When a method is called, its arguments and the return address are
    pushed onto a stack.

-   A method can access its arguments by peeking at the top of the
    stack.

-   When a method is about to return, it peeks at the stack to obtain
    the return address, and then pops both this address and its
    arguments off the stack and discards them.

> The stackTriangle.java program contains three classes: Params, StackX,
> and StackTriangleApp. The Params class encapsulates the return address
> and the method's argument, n; objects of this class are pushed onto
> the stack. The StackX class is similar to those in other chapters,
> except that it holds objects of class Params. The StackTriangleApp
> class contains four methods: main(), recTriangle(), step(), and the
> usual getInt() method for numerical input.
>
> The main() routine asks the user for a number, calls the recTriangle()
> method to calculate the triangular number corresponding to n, and
> displays the result.
>
> The recTriangle() method creates a StackX object and initializes
> codePart to 1. It then settles into a while loop, where it repeatedly
> calls step(). It won't exit from the loop until step() returns true by
> reaching case 6, its exit point. The step() method is basi- cally a
> large switch statement in which each case corresponds to a section of
> code in the original triangle() method. Listing 6.7 shows the
> stackTriangle.java program.
>
> ***LISTING 6.7*** The stackTriangle.java Program
>
> // stackTriangle.java
>
> // evaluates triangular numbers, stack replaces recursion
>
> // to run this program: C\>java StackTriangleApp import java.io.\*; //
> for I/O
>
> //////////////////////////////////////////////////////////////// class
> Params // parameters to save on stack
>
> {
>
> public int n;
>
> public int returnAddress;
>
> 296 **CHAPTER 6** Recursion
>
> ***LISTING 6.7*** Continued
>
> public Params(int nn, int ra)
>
> {
>
> n=nn; returnAddress=ra;
>
> }
>
> } // end class Params
>
> //////////////////////////////////////////////////////////////// class
> StackX
>
> {
>
> private int maxSize; // size of StackX array private Params\[\]
> stackArray;
>
> private int top; // top of stack
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public StackX(int s) // constructor
>
> {
>
> maxSize = s; // set array size stackArray = new Params\[maxSize\]; //
> create array top = -1; // no items yet
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void push(Params p) // put item on top of stack
>
> {
>
> stackArray\[++top\] = p; // increment top, insert item
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Params pop() // take item from top of stack
>
> {
>
> return stackArray\[top\--\]; // access item, decrement top
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Params peek() // peek at top of stack
>
> {
>
> return stackArray\[top\];
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class StackX
>
> //////////////////////////////////////////////////////////////// class
> StackTriangleApp
>
> {
>
> static int theNumber; static int theAnswer;

Eliminating Recursion 297

> ***LISTING 6.7*** Continued static StackX theStack; static int
> codePart; static Params theseParams;
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static void main(String\[\] args) throws IOException
>
> {
>
> System.out.print("Enter a number: "); theNumber = getInt();
>
> recTriangle(); System.out.println("Triangle="+theAnswer);
>
> } // end main()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static void recTriangle()
>
> {
>
> theStack = new StackX(10000); codePart = 1;
>
> while( step() == false) // call step() until it's true
>
> ; // null statement
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static boolean step()
>
> {
>
> switch(codePart)
>
> {
>
> case 1: // initial call
>
> theseParams = new Params(theNumber, 6); theStack.push(theseParams);
>
> codePart = 2; break;
>
> case 2: // method entry
>
> theseParams = theStack.peek(); if(theseParams.n == 1) // test
>
> {
>
> theAnswer = 1;
>
> codePart = 5; // exit
>
> }
>
> else
>
> codePart = 3; // recursive call break;
>
> case 3: // method call
>
> Params newParams = new Params(theseParams.n - 1, 4);
>
> 298 **CHAPTER 6** Recursion
>
> ***LISTING 6.7*** Continued
>
> theStack.push(newParams); codePart = 2; // go enter method break;
>
> case 4: // calculation
>
> theseParams = theStack.peek(); theAnswer = theAnswer + theseParams.n;
> codePart = 5;
>
> break;
>
> case 5: // method exit
>
> theseParams = theStack.peek();
>
> codePart = theseParams.returnAddress; // (4 or 6) theStack.pop();
>
> break;
>
> case 6: // return point
>
> return true;
>
> } // end switch return false;
>
> } // end triangle
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static String getString() throws IOException
>
> {
>
> InputStreamReader isr = new InputStreamReader(System.in);
> BufferedReader br = new BufferedReader(isr);
>
> String s = br.readLine(); return s;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static int getInt() throws IOException
>
> {
>
> String s = getString(); return Integer.parseInt(s);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class StackTriangleApp
>
> ////////////////////////////////////////////////////////////////
>
> This program calculates triangular numbers, just as the triangle.java
> program (Listing 6.1) at the beginning of the chapter did. Here's some
> sample output:
>
> Enter a number: 100 Triangle=5050

Eliminating Recursion 299

> Figure 6.19 shows how the sections of code in each case relate to the
> various parts of the algorithm.
>
> ![](media/image237.png)Case 1:
>
> ***FIGURE 6.19*** The cases and the step() method.
>
> The program simulates a method, but it has no name in the listing
> because it isn't a real Java method. Let's call this simulated method
> simMeth(). The initial call to simMeth() (at case 1) pushes the value
> entered by the user and a return value of 6 onto the stack and moves
> to the entry point of simMeth() (case 2).
>
> At its entry (case 2), simMeth() tests whether its argument is 1. It
> accesses the argu- ment by peeking at the top of the stack. If the
> argument is 1, this is the base case
>
> 300 **CHAPTER 6** Recursion
>
> and control goes to simMeth()'s exit (case 5). If not, it calls itself
> recursively (case 3). This recursive call consists of pushing n-1 and
> a return address of 4 onto the stack, and going to the method entry at
> case 2.
>
> On the return from the recursive call, simMeth() adds its argument n
> to the value returned from the call. Finally, it exits (case 5). When
> it exits, it pops the last Params object off the stack; this
> information is no longer needed.
>
> The return address given in the initial call was 6, so case 6 is the
> place where control goes when the method returns. This code returns
> true to let the while loop in recTriangle() know that the loop is
> over.
>
> Note that in this description of simMeth()'s operation we use terms
> like *argument*, *recursive call*, and *return address* to mean
> simulations of these features, not the normal Java versions.
>
> If you inserted some output statements in each case to see what
> simMeth() was doing, you could arrange for output like this:

+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > Enter a | > number: 4    | > Stack: |       |    |       |
| >         | >              |          |       |    |       |
| > case 1. | > theAnswer=0  |          |       |    |       |
+===========+================+==========+=======+====+=======+======+=================+
| > case 2. | > theAnswer=0  | > Stack: | > (4, | 6) |       |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 3. | > theAnswer=0  | > Stack: | > (4, | 6) |       |      |                 |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 2. | > theAnswer=0  | > Stack: | > (4, | 6) | > (3, | > 4) |                 |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 3. | > theAnswer=0  | > Stack: | > (4, | 6) | > (3, | > 4) |                 |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 2. | > theAnswer=0  | > Stack: | > (4, | 6) | > (3, | > 4) | > (2, 4)        |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 3. | > theAnswer=0  | > Stack: | > (4, | 6) | > (3, | > 4) | > (2, 4)        |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 2. | > theAnswer=0  | > Stack: | > (4, | 6) | > (3, | > 4) | > (2, 4) (1, 4) |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 5. | > theAnswer=1  | > Stack: | > (4, | 6) | > (3, | > 4) | > (2, 4) (1, 4) |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 4. | > theAnswer=1  | > Stack: | > (4, | 6) | > (3, | > 4) | > (2, 4)        |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 5. | > theAnswer=3  | > Stack: | > (4, | 6) | > (3, | > 4) | > (2, 4)        |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 4. | > theAnswer=3  | > Stack: | > (4, | 6) | > (3, | > 4) |                 |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 5. | > theAnswer=6  | > Stack: | > (4, | 6) | > (3, | > 4) |                 |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 4. | > theAnswer=6  | > Stack: | > (4, | 6) |       |      |                 |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 5. | > theAnswer=10 | > Stack: | > (4, | 6) |       |      |                 |
+-----------+----------------+----------+-------+----+-------+------+-----------------+
| > case 6. | > theAnswer=10 | > Stack: |       |    |       |      |                 |
+-----------+----------------+----------+-------+----+-------+------+-----------------+

> Triangle=10
>
> The case number shows what section of code is being executed. The
> contents of the stack (consisting of Params objects containing n
> followed by a return address) are also shown. The simMeth() method is
> entered four times (case 2) and returns four times (case 5). Only when
> it starts returning does theAnswer begin to accumulate the results of
> the calculations.

Eliminating Recursion 301

##### What Does This Prove?

> In stackTriangle.java (Listing 6.7) we have a program that more or
> less systemati- cally transforms a program that uses recursion into a
> program that uses a stack. This suggests that such a transformation is
> possible for any program that uses recursion, and in fact this is the
> case.
>
> With some additional work, you can systematically refine the code we
> show here, simplifying it and even eliminating the switch statement
> entirely to make the code more efficient.
>
> In practice, however, it's usually more practical to rethink the
> algorithm from the beginning, using a stack-based approach instead of
> a recursive approach. Listing 6.8 shows what happens when we do that
> with the triangle() method.
>
> ***LISTING 6.8*** The stackTriangle2.java Program
>
> // stackTriangle2.java
>
> // evaluates triangular numbers, stack replaces recursion
>
> // to run this program: C\>java StackTriangle2App import java.io.\*;
> // for I/O
>
> //////////////////////////////////////////////////////////////// class
> StackX
>
> {
>
> private int maxSize; // size of stack array private int\[\]
> stackArray;
>
> private int top; // top of stack
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public StackX(int s) // constructor
>
> {
>
> maxSize = s;
>
> stackArray = new int\[maxSize\]; top = -1;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void push(int p) // put item on top of stack
>
> { stackArray\[++top\] = p; }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int pop() // take item from top of stack
>
> { return stackArray\[top\--\]; }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int peek() // peek at top of stack
>
> { return stackArray\[top\]; }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> 302 **CHAPTER 6** Recursion
>
> ***LISTING 6.8*** Continued
>
> public boolean isEmpty() // true if stack is empty
>
> { return (top == -1); }

//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> } // end class StackX
>
> //////////////////////////////////////////////////////////////// class
> StackTriangle2App
>
> {
>
> static int theNumber; static int theAnswer; static StackX theStack;
>
> public static void main(String\[\] args) throws IOException
>
> {
>
> System.out.print("Enter a number: "); theNumber = getInt();
> stackTriangle();
>
> System.out.println("Triangle="+theAnswer);
>
> } // end main()

//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public static void stackTriangle()
>
> {
>
> theStack = new StackX(10000); // make a stack theAnswer = 0; //
> initialize answer
>
> while(theNumber \> 0) // until n is 1,
>
> {
>
> theStack.push(theNumber); // push value
>
> \--theNumber; // decrement value
>
> }
>
> while( !theStack.isEmpty() ) // until stack empty,
>
> {
>
> int newN = theStack.pop(); // pop value, theAnswer += newN; // add to
> answer
>
> }
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static String getString() throws IOException
>
> {
>
> InputStreamReader isr = new InputStreamReader(System.in);
> BufferedReader br = new BufferedReader(isr);
>
> Some Interesting Recursive Applications 303
>
> ***LISTING 6.8*** Continued
>
> String s = br.readLine(); return s;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static int getInt() throws IOException
>
> {
>
> String s = getString(); return Integer.parseInt(s);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class StackTriangle2App
>
> Here two short while loops in the stackTriangle() method substitute
> for the entire step() method of the stackTriangle.java program. Of
> course, in this program you can see by inspection that you can
> eliminate the stack entirely and use a simple loop. However, in more
> complicated algorithms the stack must remain.
>
> Often you'll need to experiment to see whether a recursive method, a
> stack-based approach, or a simple loop is the most efficient (or
> practical) way to handle a particular situation.

#### Some Interesting Recursive Applications

> Let's look briefly at some other situations in which recursion is
> useful. You will see from the diversity of these examples that
> recursion can pop up in unexpected places. We'll examine three
> problems: raising a number to a power, fitting items into a knapsack,
> and choosing members of a mountain-climbing team. We'll explain the
> concepts and leave the implementations as exercises.

##### Raising a Number to a Power

> The more sophisticated pocket calculators allow you to raise a number
> to an arbi- trary power. They usually have a key labeled something
> like x\^y, where the circum- flex indicates that x is raised to the y
> power. How would you do this calculation if your calculator lacked
> this key? You might assume you would need to multiply x by itself y
> times. That is, if x was 2 and y was 8 (28), you would carry out the
> arithmetic for 2\*2\*2\*2\*2\*2\*2\*2. However, for large values of y,
> this approach might prove tedious. Is there a quicker way?
>
> One solution is to rearrange the problem so you multiply by multiples
> of 2 whenever possible, instead of by 2. Take 28 as an example.
> Eventually, we must involve eight 2s in the multiplication process.
> Let's say we start with 2\*2=4. We've used up two of the
>
> 304 **CHAPTER 6** Recursion
>
> 2s, but there are still six to go. However, we now have a new number
> to work with:

4.  So we try 4\*4=16. This uses four 2s (because each 4 is two 2s
    multiplied together). We need to use up four more 2s, but now we
    have 16 to work with, and 16\*16=256 uses exactly eight 2s (because
    each 16 has four 2s).

> So we've found the answer to 28 with only three multiplications
> instead of seven. That's O(log N) time instead O(N).
>
> Can we make this process into an algorithm that a computer can
> execute? The scheme is based on the mathematical equality xy =
> (x2)y/2. In our example, 28 = (22)8/2, or 28 = (22)4. This is true
> because raising a power to another power is the same as multiplying
> the powers.
>
> However, we're assuming our computer can't raise a number to a power,
> so we can't handle (22)4. Let's see if we can transform this into an
> expression that involves only multiplication. The trick is to start by
> substituting a new variable for 22.
>
> Let's say that 22=a. Then 28 equals (22)4, which is a4. However,
> according to the origi- nal equality, a4 can be written (a2)2, so 28 =
> (a2)2.
>
> Again we substitute a new variable for a2, say a2=c, then (c)2 can be
> written (c2)1, which also equals 28.
>
> Now we have a problem we can handle with simple multiplication: c
> times c.
>
> You can imbed this scheme in a recursive method---let's call it
> power()---for calculat- ing powers. The arguments are x and y, and the
> method returns xy. We don't need to worry about variables like a and c
> anymore because x and y get new values each time the method calls
> itself. Its arguments are x\*x and y/2. For the x=2 and y=8, the
> sequence of arguments and return values would be
>
> x=2, y=8 x=4, y=4 x=16, y=2 x=256, y=1
>
> Returning 256, x=256, y=1 Returning 256, x=16, y=2 Returning 256, x=4,
> y=4 Returning 256, x=2, y=8
>
> When y is 1, we return. The answer, 256, is passed unchanged back up
> the sequence of methods.
>
> We've shown an example in which y is an even number throughout the
> entire sequence of divisions. This will not usually be the case.
> Here's how to revise the algo- rithm to deal with the situation where
> y is odd. Use integer division on the way down and don't worry about a
> remainder when dividing y by 2. However, during the
>
> Some Interesting Recursive Applications 305
>
> return process, whenever y is an odd number, do an additional
> multiplication by x. Here's the sequence for 318:
>
> x=3, y=18 x=9, y=9 x=81, y=4 x=6561, y=2
>
> x=43046721, y=1
>
> Returning 43046721, x=43046721, y=1 Returning 43046721, x=6561, y=2
> Returning 43046721, x=81, y=4
>
> Returning 387420489, x=9, y=9 // y is odd; so multiply by x Returning
> 387420489, x=3, y=18

##### The Knapsack Problem

> The Knapsack Problem is a classic in computer science. In its simplest
> form it involves trying to fit items of different weights into a
> knapsack so that the knapsack ends up with a specified total weight.
> You don't need to fit in all the items.
>
> For example, suppose you want your knapsack to weigh exactly 20
> pounds, and you have five items, with weights of 11, 8, 7, 6, and 5
> pounds. For small numbers of items, humans are pretty good at solving
> this problem by inspection. So you can probably figure out that only
> the 8, 7, and 5 combination of items adds up to 20.
>
> If we want a computer to solve this problem, we'll need to give it
> more detailed instructions. Here's the algorithm:

1.  If at any point in this process the sum of the items you selected
    adds up to the target, you're done.

2.  Start by selecting the first item. The remaining items must add up
    to the knapsack's target weight minus the first item; this is a new
    target weight.

3.  Try, one by one, each of the possible combinations of the remaining
    items. Notice, however, that you don't really need to try all the
    combinations, because whenever the sum of the items is more than the
    target weight, you can stop adding items.

4.  If none of the combinations work, discard the first item, and start
    the whole process again with the second item.

5.  Continue this with the third item and so on until you've tried all
    the combinations, at which point you know there is no solution.

> 306 **CHAPTER 6** Recursion
>
> In the example just described, start with 11. Now we want the
> remaining items to add up to 9 (20 minus 11). Of these, we start with
> 8, which is too small. Now we want the remaining items to add up to 1
> (9 minus 8). We start with 7, but that's bigger than 1, so we try 6
> and then 5, which are also too big. We've run out of items, so we know
> that any combination that includes 8 won't add up to 9. Next we try 7,
> so now we're looking for a target of 2 (9 minus 7). We continue in the
> same way, as summarized here:
>
> Items: 11, 8, 7, 6, 5
>
> ==========================================
>
> 11 // Target = 20, 11 is too small

<table>
<thead>
<tr class="header">
<th><blockquote>
<p>11,</p>
</blockquote></th>
<th><blockquote>
<p>8</p>
</blockquote></th>
<th>//</th>
<th><blockquote>
<p>Target</p>
</blockquote></th>
<th>=</th>
<th><blockquote>
<p>9,</p>
</blockquote></th>
<th><blockquote>
<p>8</p>
</blockquote></th>
<th><blockquote>
<p>is</p>
</blockquote></th>
<th><blockquote>
<p>too</p>
</blockquote></th>
<th><blockquote>
<p>small</p>
</blockquote></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>8, 7</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>1,</p>
</blockquote></td>
<td><blockquote>
<p>7</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>big</p>
</blockquote></td>
</tr>
<tr class="even">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>8, 6</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>1,</p>
</blockquote></td>
<td><blockquote>
<p>6</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>big</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>8, 5</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>1,</p>
</blockquote></td>
<td><blockquote>
<p>5</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>big. No more items</p>
</blockquote></td>
</tr>
<tr class="even">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>7</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>9,</p>
</blockquote></td>
<td><blockquote>
<p>7</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>small</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>7, 6</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>2,</p>
</blockquote></td>
<td><blockquote>
<p>6</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>big</p>
</blockquote></td>
</tr>
<tr class="even">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>7, 5</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>2,</p>
</blockquote></td>
<td><blockquote>
<p>5</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>big. No more items</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>6</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>9,</p>
</blockquote></td>
<td><blockquote>
<p>6</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>small</p>
</blockquote></td>
</tr>
<tr class="even">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>6, 5</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>3,</p>
</blockquote></td>
<td><blockquote>
<p>5</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>big. No more items</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><blockquote>
<p>11,</p>
</blockquote></td>
<td><blockquote>
<p>5</p>
</blockquote></td>
<td>//</td>
<td><blockquote>
<p>Target</p>
</blockquote></td>
<td>=</td>
<td><blockquote>
<p>9,</p>
</blockquote></td>
<td><blockquote>
<p>5</p>
</blockquote></td>
<td><blockquote>
<p>is</p>
</blockquote></td>
<td><blockquote>
<p>too</p>
</blockquote></td>
<td><blockquote>
<p>small. No more items</p>
</blockquote></td>
</tr>
</tbody>
</table>

> 8, // Target = 20, 8 is too small
>
> 8, 7 // Target = 12, 7 is too small
>
> 8, 7, 6 // Target = 5, 6 is too big
>
> 8, 7, 5 // Target = 5, 5 is just right. Success!
>
> As you may recognize, a recursive routine can pick the first item,
> and, if the item is smaller than the target, the routine can call
> itself with a new target to investigate the sums of all the remaining
> items.

##### Combinations: Picking a Team

> In mathematics, a *combination* is a selection of things in which
> their order doesn't matter. For example, suppose there is a group of
> five mountain climbers named A, B, C, D, and E. From this group you
> want to select a team of three to scale steep and icy Mount Anaconda.
> However, you're worried about how the team members will get along, so
> you decide to list all the possible teams; that is, all the possible
> combina- tions of three climbers. But then you think it would be nice
> to have a computer program print out all the combinations for you.
> Such a program would show you the 10 possible combinations:
>
> ABC, ABD, ABE, ACD, ACE, ADE, BCD, BCE, BDE, CDE
>
> Some Interesting Recursive Applications 307
>
> How would you write such a program? It turns out there's an elegant
> recursive solu- tion. It involves dividing these combinations into two
> groups: those that begin with A and those that don't. Suppose we
> abbreviate the idea of 3 people selected from a group of 5 as (5,3).
> Let's say n is the size of the group and k is the size of a team. A
> theorem says that
>
> (n, k) = (n -- 1, k -- 1) + (n -- 1, k)
>
> For our example of 3 people selected from a group of 5, we have (5, 3)
> = (4, 2) + (4, 3)
>
> We've broken a large problem into two smaller ones. Instead of
> selecting from a group of 5, we're selecting twice from a group of 4:
> First, all the ways to select 2 people from a group of 4, then all the
> ways to select 3 people from a group of 4.
>
> There are 6 ways to select 2 people from a group of 4. In the (4, 2)
> term---which we'll call the left term---these 6 combinations are
>
> BC, BD, BE, CD, CE, DE
>
> A is the missing group member, so to make three-person teams we
> precede these combinations with A:
>
> ABC, ABD, ABE, ACD, ACE, ADE
>
> There are four ways to select 3 people from a group of 4. In the (4,
> 3) term---the right term---we have
>
> BCD, BCE, BDE, CDE
>
> When these 4 combinations from the right term are added to the 6 from
> the left term, we get the 10 combinations for (5, 3).
>
> You can apply the same decomposition process to each of the groups of
> 4. For example, (4, 2) is (3, 1) added to (3, 2). As you can see, this
> is a natural place to apply recursion.
>
> You can think of this problem as a tree with (5,3) on the top row,
> (4,3) and (4,2) on the next row, and so on, where the nodes in the
> tree correspond to recursive func- tion calls. Figure 6.20 shows what
> this looks like for the (5,3) example.
>
> The base cases are combinations that make no sense: those with a 0 for
> either number and those where the team size is greater than the group
> size. The combina- tion (1,1) is valid but there's no point trying to
> break it down further. In the figure, dotted lines show the base
> cases; you return rather than following them.
>
> 308 **CHAPTER 6** Recursion
>
> ***FIGURE 6.20*** Picking a team of 3 from a group of 5.
>
> The recursion depth corresponds to the group members: The node on the
> top row represents group member A, the two nodes on the next row
> represent group member B, and so on. If there are 5 group members,
> you'll have 5 levels.
>
> As you descend the tree you need to remember the sequence of members
> you visit. Here's how to do that: Whenever you make a call to a left
> term, you record the node you're leaving by adding its letter to a
> sequence. These left calls and the letters to add to the sequence are
> shown by the darker lines in the figure. You'll need to role the
> sequence back up as you return.
>
> To record all the combinations, you can display them as you go along.
> You don't display anything when making left calls. However, when you
> make calls to the right, you check the sequence; if you're at a valid
> node, and adding one member will complete the team, then add the node
> to the sequence and display the complete team.

#### Summary

-   A recursive method calls itself repeatedly, with different argument
    values each time.

-   Some value of its arguments causes a recursive method to return
    without calling itself. This is called the base case.

-   When the innermost instance of a recursive method returns, the
    process "unwinds" by completing pending instances of the method,
    going from the latest back to the original call.

Summary 309

-   A triangular number is the sum of itself and all numbers smaller
    than itself. (*Number* means *integer* in this context.) For
    example, the triangular number of 4 is 10, because 4+3+2+1 = 10.

-   The factorial of a number is the product of itself and all numbers
    smaller than itself. For example, the factorial of 4 is 4\*3\*2\*1
    = 24.

-   Both triangular numbers and factorials can be calculated using
    either a recursive method or a simple loop.

-   The anagram of a word (all possible combinations of its n letters)
    can be found recursively by repeatedly rotating all its letters and
    anagramming the rightmost n-1 of them.

-   A binary search can be carried out recursively by checking which
    half of a sorted range the search key is in, and then doing the same
    thing with that half.

-   The Towers of Hanoi puzzle consists of three towers and an arbitrary
    number of rings.

-   The Towers of Hanoi puzzle can be solved recursively by moving all
    but the bottom disk of a subtree to an intermediate tower, moving
    the bottom disk to the destination tower, and finally moving the
    subtree to the destination.

-   Merging two sorted arrays means to create a third array that
    contains all the elements from both arrays in sorted order.

-   In mergesort, 1-element subarrays of a larger array are merged into
    2-element subarrays, 2-element subarrays are merged into 4-element
    subarrays, and so on until the entire array is sorted.

-   mergesort requires O(N\*logN) time.

-   mergesort requires a workspace equal in size to the original array.

-   For triangular numbers, factorials, anagrams, and the binary search,
    the recur- sive method contains only one call to itself. (There are
    two shown in the code for the binary search, but only one is used on
    any given pass through the method's code.)

-   For the Towers of Hanoi and mergesort, the recursive method contains
    two calls to itself.

-   Any operation that can be carried out with recursion can be carried
    out with a stack.

-   A recursive approach may be inefficient. If so, it can sometimes be
    replaced with a simple loop or a stack-based approach.

> 310 **CHAPTER 6** Recursion

#### Questions

> These questions are intended as a self-test for readers. Answers may
> be found in Appendix C.

1.  If the user enters 10 in the triangle.java program (Listing 6.1),
    what is the maximum number of "copies" of the triangle() method
    (actually just copies of its argument) that exist at any one time?

2.  Where are the copies of the argument, mentioned in question 1,
    stored?

    a.  in a variable in the triangle() method

    b.  in a field of the TriangleApp class

    c.  in a variable of the getString() method

    d.  on a stack

3.  Assume the user enters 10 as in question 1. What is the value of n
    when the

> triangle() method first returns a value other than 1?

4.  Assume the same situation as in question 1. What is the value of n
    when the

> triangle() method is about to return to main()?

5.  True or false: In the triangle() method, the return values are
    stored on the stack.

6.  In the anagram.java program (Listing 6.2), at a certain depth of
    recursion, a version of the doAnagram() method is working with the
    string "led". When this method calls a new version of itself, what
    letters will the new version be working with?

7.  We've seen that recursion can take the place of a loop, as in the
    loop-oriented orderedArray.java program (Listing 2.4) and the
    recursive binarySearch.java program (Listing 6.3). Which of the
    following is *not* true?

    e.  Both programs divide the range repeatedly in half.

    f.  If the key is not found, the loop version returns because the
        range bounds cross, but the recursive version occurs because it
        reaches the bottom recursion level.

    g.  If the key is found, the loop version returns from the entire
        method, whereas the recursive version returns from only one
        level of recursion.

    h.  In the recursive version the range to be searched must be
        specified in the arguments, while in the loop version it need
        not be.

Questions 311

8.  In the recFind() method in the binarySearch.java program (Listing
    6.3), what takes the place of the loop in the non-recursive version?

    i.  the recFind() method

    j.  arguments to recFind()

    k.  recursive calls to recFind()

    l.  the call from main() to recFind()

9.  The binarySearch.java program is an example of the [ ]{.underline}
    approach to solving a problem.

10. What gets smaller as you make repeated recursive calls in the
    redFind()

> method?

11. What becomes smaller with repeated recursive calls in the
    towers.java program (Listing 6.4)?

12. The algorithm in the towers.java program involves

    m.  "trees" that are data storage devices.

    n.  secretly putting small disks under large disks.

    o.  changing which columns are the source and destination.

    p.  moving one small disk and then a stack of larger disks.

13. Which is *not* true about the merge() method in the merge.java
    program (Listing 6.5)?

    q.  Its algorithm can handle arrays of different sizes.

    r.  It must search the target array to find where to put the next
        item.

    s.  It is not recursive.

    t.  It continuously takes the smallest item irrespective of what
        array it's in.

14. The disadvantage of mergesort is that

    u.  it is not recursive.

    v.  it uses more memory.

    w.  although faster than the insertion sort, it is much slower than
        quicksort.

    x.  it is complicated to implement.

15. Besides a loop, a [ ]{.underline} can often be used instead of
    recursion.

> 312 **CHAPTER 6** Recursion

#### Experiments

> Carrying out these experiments will help to provide insights into the
> topics covered in the chapter. No programming is involved.

1.  In the triangle.java program (Listing 6.1), remove the code for the
    base case (the if(n==1), the return 1;, and the else). Then run the
    program and see what happens.

2.  Use the Towers Workshop applet in manual mode to solve the puzzle
    with seven or more disks.

3.  Rewrite the main() part of mergeSort.java (Listing 6.6) so you can
    fill the array with hundreds of thousands of random numbers. Run the
    program to sort these numbers and compare its speed with the sorts
    in Chapter 3, "Simple Sorting."

#### Programming Projects

> Writing programs that solve the Programming Projects helps to solidify
> your under- standing of the material and demonstrates how the
> chapter's concepts are applied. (As noted in the Introduction,
> qualified instructors may obtain completed solutions to the
> Programming Projects on the publisher's Web site.)

1.  Suppose you buy a budget-priced pocket PC and discover that the chip
    inside can't do multiplication, only addition. You program your way
    out of this quandary by writing a recursive method, mult(), that
    performs multiplication of x and y by adding x to itself y times.
    Its arguments are x and y and its return value is the product of x
    and y. Write such a method and a main() program to call it. Does the
    addition take place when the method calls itself or when it returns?

    In Chapter 8, "Binary Trees," we'll look at binary trees, where
    every branch has (potentially) exactly two sub-branches. If we draw
    a binary tree on the screen using characters, we might have 1 branch
    on the top row, 2 on the next row, then 4, 8, 16, and so on. Here's
    what that looks like for a tree 16 characters wide:

> \-\-\-\-\-\-\--X\-\-\-\-\-\--
>
> \-\-\--X X\-\--
>
> \--X\-\--X\-\--X\-\--X-
>
> -X-X-X-X-X-X-X-X XXXXXXXXXXXXXXXX

Programming Projects 313

> (Note that the bottom line should be shifted a half character-width
> right, but there's nothing we can do about that with character-mode
> graphics.) You can draw this tree using a recursive makeBranches()
> method with arguments left and right, which are the endpoints of a
> horizontal range. When you first enter the routine, left is 0 and
> right is the number of characters (including dashes) in all the lines,
> minus 1. You draw an X in the center of this range. Then the method
> calls itself twice: once for the left half of the range and once for
> the right half. Return when the range gets too small. You will
> probably want to put all the dashes and Xs into an array and display
> the array all at once, perhaps with a display() method. Write a main()
> program to draw the tree by calling makeBranches() and display().
> Allow main() to determine the line length of the display (32, 64, or
> whatever). Ensure that the array that holds the characters for display
> is no larger than it needs to be. What is the relationship of the
> number of lines (five in the picture here) to the line width?

3.  Implement the recursive approach to raising a number to a power, as
    described in the "Raising a Number to a Power" section near the end
    of this chapter. Write the recursive power() function and a main()
    routine to test it.

    Write a program that solves the knapsack problem for an arbitrary
    knapsack capacity and series of weights. Assume the weights are
    stored in an array. Hint: The arguments to the recursive knapsack()
    function are the target weight and the array index where the
    remaining items start.

    Implement a recursive approach to showing all the teams that can be
    created from a group (n things taken k at a time). Write the
    recursive showTeams() method and a main() method to prompt the user
    for the group size and the team size to provide arguments for
    showTeam(), which then displays all the possible combinations.
