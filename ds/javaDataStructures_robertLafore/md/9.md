9
=

Red-Black Trees
---------------

> As you learned in Chapter 8, "Binary Trees," ordinary binary search
> trees offer important advantages as data storage devices: You can
> quickly search for an item with a
>
> given key, and you can also quickly insert or delete an item. Other
> data storage structures, such as arrays, sorted arrays, and linked
> lists, perform one or the other of these activities slowly. Thus,
> binary search trees might appear to be the ideal data storage
> structure.
>
> Unfortunately, ordinary binary search trees suffer from a troublesome
> problem. They work well if the data is inserted into the tree in
> random order. However, they become much slower if data is inserted in
> already-sorted order (17, 21, 28, 36,...) or inversely sorted order
> (36, 28, 21, 17,...). When the values to be inserted are already
> ordered, a binary tree becomes unbalanced. With an unbalanced tree,
> the ability to quickly find (or insert or delete) a given element is
> lost.
>
> This chapter explores one way to solve the problem of unbalanced
> trees: the red-black tree, which is a binary search tree with some
> added features.
>
> There are other ways to ensure that trees are balanced. We'll mention
> some at the end of this chapter, and examine several, 2-3-4 trees and
> 2-3 trees, in Chapter 10, "2-3-4 Trees and External Storage." In fact,
> as we'll see in that chapter, operations on a 2-3-4 tree correspond in
> a surprising way to operations on a red-black tree.

#### Our Approach to the Discussion

> We'll explain insertion into red-black trees a little differ- ently
> than we have explained insertion into other data structures. Red-black
> trees are not trivial to understand. Because of this and also because
> of a multiplicity of

##### IN THIS CHAPTER

-   Our Approach to the Discussion

-   Balanced and Unbalanced Trees

-   Experimenting with the Workshop Applet

-   Rotations

-   Inserting a New Node

-   Deletion

-   The Efficiency of Red-Black Trees

-   Red-Black Tree Implementation

-   Other Balanced Trees

> 430 **CHAPTER 9** Red-Black Trees
>
> symmetrical cases (for left or right children, inside or outside
> grandchildren, and so on), the actual code is more lengthy and complex
> than one might expect. It's there- fore hard to learn about the
> algorithm by examining code. Accordingly, there are no listings in
> this chapter. You can create similar functionality using a 2-3-4 tree
> with the code shown in Chapter 10. However, the concepts you learn
> about here will aid your understanding of 2-3-4 trees and are
> themselves quite interesting.

##### Conceptual

> For our conceptual understanding of red-black trees, we will be aided
> by the RBTree Workshop applet. We'll describe how you can work in
> partnership with the applet to insert new nodes into a tree. Including
> a human into the insertion routine certainly slows it down but also
> makes it easier for the human to understand how the process works.
>
> Searching works the same way in a red-black tree as it does in an
> ordinary binary tree. On the other hand, insertion and deletion, while
> based on the algorithms in an ordinary tree, are extensively modified.
> Accordingly, in this chapter we'll be concen- trating on the insertion
> process.

##### Top-Down Insertion

> The approach to insertion that we'll discuss is called *top-down*
> insertion. This means that some structural changes may be made to the
> tree as the search routine descends the tree looking for the place to
> insert the node.
>
> Another approach is *bottom-up* insertion. This involves finding the
> place to insert the node and then working back up through the tree
> making structural changes.
>
> Bottom-up insertion is less efficient because two passes must be made
> through the tree.

#### Balanced and Unbalanced Trees

> Before we begin our investigation of red-black trees, let's review how
> trees become unbalanced. Fire up the Binary Tree Workshop applet from
> Chapter 8 (not this chapter's RBTree applet). Use the Fill button to
> create a tree with only one node. Then insert a series of nodes whose
> keys are in either ascending or descending order. The result will be
> something like that in Figure 9.1.
>
> The nodes arrange themselves in a line with no branches. Because each
> node is larger than the previously inserted one, every node is a right
> child, so all the nodes are on one side of the root. The tree is
> maximally unbalanced. If you inserted items in descending order, every
> node would be the left child of its parent, and the tree would be
> unbalanced on the other side.
>
> Balanced and Unbalanced Trees 431

![](media/image1.png)

> ***FIGURE 9.1*** Items inserted in ascending order.

##### Degenerates to O(N)

> When there are no branches, the tree becomes, in effect, a linked
> list. The arrange- ment of data is one-dimensional instead of
> two-dimensional. Unfortunately, as with a linked list, you must now
> search through (on the average) half the items to find the one you're
> looking for. In this situation the speed of searching is reduced to
> O(N), instead of O(logN) as it is for a balanced tree. Searching
> through 10,000 items in such an unbalanced tree would require an
> average of 5,000 comparisons, whereas for a balanced tree with random
> insertions it requires only 14. For presorted data you might just as
> well use a linked list in the first place.
>
> Data that's only partly sorted will generate trees that are only
> partly unbalanced. If you use the Binary Tree Workshop applet from
> Chapter 8 to attempt to generate trees with 31 nodes, you'll see that
> some of them are more unbalanced than others, as shown in Figure 9.2.
>
> Although not as bad as a maximally unbalanced tree, this situation is
> not optimal for searching times.
>
> In the Binary Tree Workshop applet, trees can become partially
> unbalanced, even with randomly generated data, because the amount of
> data is so small that even a short run of ordered numbers will have a
> big effect on the tree. Also, a very small or very large key value can
> cause an unbalanced tree by not allowing the insertion of many nodes
> on one side or the other of its node. A root of 3, for example, allows
> only two more nodes to be inserted to its left.
>
> 432 **CHAPTER 9** Red-Black Trees

![](media/image9.png){width="2.799815179352581in"
height="2.2799989063867017in"}

> ***FIGURE 9.2*** A partially unbalanced tree.
>
> With a realistic amount of random data, it's not likely a tree would
> become seriously unbalanced. However, there may be runs of sorted data
> that will partially unbalance a tree. Searching partially unbalanced
> trees will take time somewhere between O(N) and O(logN), depending on
> how badly the tree is unbalanced.

##### Balance to the Rescue

> To guarantee the quick O(log N) search times a tree is capable of, we
> need to ensure that our tree is always balanced (or at least almost
> balanced). This means that each node in a tree needs to have roughly
> the same number of descendents on its left side as it has on its
> right.
>
> In a red-black tree, balance is achieved during insertion (and also
> deletion, but we'll ignore that for the moment). As an item is being
> inserted, the insertion routine checks that certain characteristics of
> the tree are not violated. If they are, it takes corrective action,
> restructuring the tree as necessary. By maintaining these character-
> istics, the tree is kept balanced.

##### Red-Black Tree Characteristics

> What are these mysterious tree characteristics? There are two, one
> simple and one more complicated:

-   The nodes are colored.

-   During insertion and deletion, rules are followed that preserve
    various arrangements of these colors.

> Balanced and Unbalanced Trees 433

####### Colored Nodes

> In a red-black tree, every node is either black or red. These are
> arbitrary colors; blue and yellow would do just as well. In fact, the
> whole concept of saying that nodes have "colors" is somewhat
> arbitrary. Some other analogy could have been used instead: We could
> say that every node is either heavy or light, or yin or yang.
>
> However, colors are convenient labels. A data field, which can be
> boolean (isRed, for example), is added to the node class to embody
> this color information.
>
> In the RBTree Workshop applet, the red-black characteristic of a node
> is shown by its border color. The center color, as it was in the
> Binary Tree Workshop applet in the preceding chapter, is simply a
> randomly generated data field of the node.
>
> When we speak of a node's color in this chapter, we'll almost always
> be referring to its red-black border color. In the figures (except the
> screenshot of Figure 9.3) we'll show black nodes with a solid black
> border and red nodes with a white border. (Nodes are sometimes shown
> with no border to indicate that it doesn't matter whether they're
> black or red.)

####### Red-Black Rules

> When inserting (or deleting) a new node, certain rules, which we call
> the *red-black rules*, must be followed. If they're followed, the tree
> will be balanced. Let's look briefly at these rules:

1.  Every node is either red or black.

2.  The root is always black.

3.  If a node is red, its children must be black (although the converse
    isn't necessarily true).

4.  Every path from the root to a leaf, or to a null child, must contain
    the same number of black nodes.

> The "null child" referred to in Rule 4 is a place where a child could
> be attached to a non-leaf node. In other words, it's the potential
> left child of a node with a right child, or the potential right child
> of a node with a left child. This will make more sense as we go along.
>
> The number of black nodes on a path from root to leaf is called the
> *black height*. Another way to state Rule 4 is that the black height
> must be the same for all paths from the root to a leaf.
>
> These rules probably seem completely mysterious. It's not obvious how
> they will lead to a balanced tree, but they do; some very clever
> people invented them. Copy them onto a sticky note, and keep it on
> your computer. You'll need to refer to them often in the course of
> this chapter.
>
> 434 **CHAPTER 9** Red-Black Trees
>
> You can see how the rules work by using the RBTree Workshop applet.
> We'll do some experiments with the applet in a moment, but first you
> should understand what actions you can take to fix things if one of
> the red-black rules is broken.

####### Duplicate Keys

> What happens if there's more than one data item with the same key?
> This presents a slight problem in red-black trees. It's important that
> nodes with the same key are distributed on both sides of other nodes
> with the same key. That is, if keys arrive in the order 50, 50, 50,
> you want the second 50 to go to the right of the first one, and the
> third 50 to go to the left of the first one. Otherwise, the tree
> becomes unbal- anced.
>
> Distributing nodes with equal keys could be handled by some kind of
> randomizing process in the insertion algorithm. However, the search
> process then becomes more complicated if all items with the same key
> must be found.
>
> It's simpler to outlaw items with the same key. In this discussion
> we'll assume duplicates aren't allowed.

##### Fixing Rule Violations

> Suppose you see (or are told by the applet) that the color rules are
> violated. How can you fix things so your tree is in compliance? There
> are two, and only two, possible actions you can take:

-   You can change the colors of nodes.

-   You can perform rotations.

> In the applet, changing the color of a node means changing its
> red-black border color (not the center color). A rotation is a
> rearrangement of the nodes that, one hopes, leaves the tree more
> balanced.
>
> At this point such concepts probably seem very abstract, so let's
> become familiar with the RBTree Workshop applet, which can help to
> clarify things.

#### Using the RBTree Workshop Applet

> Figure 9.3 shows what the RBTree Workshop applet looks like after some
> nodes have been inserted. (It may be hard to tell the difference
> between red and black node borders in the figure, but they should be
> clear on a color monitor.)
>
> There are quite a few buttons in the RBTree applet. We'll briefly
> review what they do, although at this point some of the descriptions
> may be a bit puzzling.
>
> Using the RBTree Workshop Applet 435

![](media/image10.png){width="2.792222222222222in"
height="2.2799989063867017in"}

> ***FIGURE 9.3*** The RBTree Workshop applet.

##### Clicking on a Node

> The red arrow points to the currently selected node. It's this node
> whose color is changed or which is the top node in a rotation. You
> select a node by single-clicking it with the mouse, which moves the
> red arrow to the node.

##### The Start Button

> When you first start the RBTree Workshop applet, and also when you
> press the Start button, you'll see that a tree with only one node is
> created. Because an understand- ing of red-black trees focuses on
> using the red-black rules during the insertion process, it's more
> convenient to begin with the root and build up the tree by insert- ing
> additional nodes. To simplify future operations, the initial root node
> is always given a value of 50. You select your own numbers for
> subsequent insertions.

##### The Ins Button

> The Ins button causes a new node to be created, with the value that
> was typed into the Number box, and then inserted into the tree. (At
> least this is what happens if no color flips are necessary. See the
> section on the Flip button for more on this possibility.)
>
> Notice that the Ins button does a complete insertion operation with
> one push; multi- ple pushes are not required as they were with the
> Binary Tree Workshop applet in the preceding chapter. It's therefore
> important to type the key value before pushing the button. The focus
> in the RBTree applet is not on the process of finding the place
>
> 436 **CHAPTER 9** Red-Black Trees
>
> to insert the node, which is similar to that in ordinary binary search
> trees, but on keeping the tree balanced; so the applet doesn't show
> the individual steps in the insertion.

##### The Del Button

> Pushing the Del button causes the node with the key value typed into
> the Number box to be deleted. As with the Ins button, this deletion
> takes place immediately after the first push; multiple pushes are not
> required.
>
> The Del button and the Ins button use the basic insertion
> algorithms---the same as those in the Tree Workshop applet. This is
> how the work is divided between the applet and the user: The applet
> does the insertion, but it's (mostly) up to the user to make the
> appropriate changes to the tree to ensure the red-black rules are
> followed and the tree thereby becomes balanced.

##### The Flip Button

> If there is a black parent with two red children, and you place the
> red arrow on the parent by clicking on the node with the mouse, then
> when you press the Flip button, the parent will become red and the
> children will become black. That is, the colors are flipped between
> the parent and children. You'll learn later why such a color exchange
> is desirable.
>
> If you try to flip the root, it will remain black, so as not to
> violate Rule 2, but its children will change from red to black.

##### The RoL Button

> The RoL button carries out a left rotation. To rotate a group of
> nodes, first single- click the mouse to position the arrow at the
> topmost node of the group to be rotated. For a left rotation, the top
> node must have a right child. Then click the button. We'll examine
> rotations in detail later.

##### The RoR Button

> The RoR button performs a right rotation. Position the arrow on the
> top node to be rotated, making sure it has a left child; then click
> the button.

##### The R/B Button

> The R/B button changes a red node to black, or a black node to red.
> Single-click the mouse to position the red arrow on the node, and then
> push the button. (This button changes the color of a single node;
> don't confuse it with the Flip button, which changes three nodes at
> once.)
>
> Experimenting with the Workshop Applet 437

##### Text Messages

> Messages in the text box below the buttons tell you whether the tree
> is *red-black correct*. The tree is red-black correct if it adheres to
> rules 1 through 4 listed previously. If it's not correct, you'll see
> messages advising which rule is being violated. In some cases the red
> arrow will point to the place where the violation occurred.

##### Where's the Find Button?

> In red-black trees, a search routine operates exactly as it did in the
> ordinary binary search trees described in the preceding chapter. It
> starts at the root, and, at each node it encounters (the current
> node), it decides whether to go to the left or right child by
> comparing the key of the current node with the search key.
>
> We don't include a Find button in the RBTree applet because you
> already understand this process and our attention will be on
> manipulating the red-black aspects of the tree.

#### Experimenting with the Workshop Applet

> Now that you're familiar with the RBTree buttons, let's do some simple
> experiments to get a feel for what the applet does. The idea here is
> to learn to manipulate the applet's controls. Later you'll use these
> skills to balance the tree.

##### Experiment 1: Inserting Two Red Nodes

> Press Start to clear any extra nodes. You'll be left with the root
> node, which always has the value 50.
>
> Insert a new node with a value smaller than the root, say 25, by
> typing the number into the Number box and pressing the Ins button.
> Adding this node doesn't cause any rule violations, so the message
> continues to say Tree is red-black correct.
>
> Insert a second node that's larger than the root, say 75. The tree is
> still red-black correct. It's also balanced; there are the same number
> of nodes on the right of the only non-leaf node (the root) as there
> are on its left. The result is shown in Figure 9.4.
>
> Notice that newly inserted nodes are always colored red (except for
> the root). This is not an accident. Inserting a red node is less
> likely to violate the red-black rules than inserting a black one. This
> is because, if the new red node is attached to a black one, no rule is
> broken. It doesn't create a situation in which there are two red nodes
> together (Rule 3), and it doesn't change the black height in any of
> the paths (Rule 4). Of course, if you attach a new red node to a red
> node, Rule 3 will be violated.
>
> However, with any luck this will happen only half the time. Whereas,
> if it were possible to add a new black node, it would always change
> the black height for its path, violating Rule 4.
>
> 438 **CHAPTER 9** Red-Black Trees
>
> Black node
>
> ![](media/image11.png)
>
> ***FIGURE 9.4*** A balanced tree.
>
> Also, it's easier to fix violations of Rule 3 (parent and child are
> both red) than Rule 4 (black heights differ), as we'll see later.

##### Experiment 2: Rotations

> Let's try some rotations. Start with the three nodes as shown in
> Figure 9.4. Position the red arrow on the root (50) by clicking it
> with the mouse. This node will be the *top node* in the rotation. Now
> perform a right rotation by pressing the RoR button. The nodes all
> shift to new positions, as shown in Figure 9.5.
>
> Arrow
>
> ![](media/image14.png)
>
> ***FIGURE 9.5*** Following a right rotation.
>
> In this right rotation, the parent or top node moves into the place of
> its right child, the left child moves up and takes the place of the
> parent, and the right child moves down to become the grandchild of the
> new top node.
>
> Notice that the tree is now unbalanced; more nodes appear to the right
> of the root than to the left. Also, the message indicates that the
> red-black rules are violated, specifically Rule 2 (the root is always
> black). Don't worry about this problem yet.
>
> Instead, rotate the other way. Position the red arrow on 25, which is
> now the root (the arrow should already point to 25 after the previous
> rotation). Click the RoL button to rotate left. The nodes will return
> to the position of Figure 9.4.
>
> Experimenting with the Workshop Applet 439

##### Experiment 3: Color Flips

> Start with the position of Figure 9.4, with nodes 25 and 75 inserted
> in addition to 50 in the root position. Note that the parent (the
> root) is black and both its children are red. Now try to insert
> another node. No matter what value you use, you'll see the message
> Can't Insert: Needs color flip.
>
> As we mentioned, a color flip is necessary whenever, during the
> insertion process, a black node with two red children is encountered.
>
> The red arrow should already be positioned on the black parent (the
> root node), so click the Flip button. The root's two children change
> from red to black. Ordinarily, the parent would change from black to
> red, but this is a special case because it's the root: It remains
> black to avoid violating Rule 2. Now all three nodes are black. The
> tree is still red-black correct.
>
> Now click the Ins button again to insert the new node. Figure 9.6
> shows the result if the newly inserted node has the key value 12.

![](media/image17.png)

> ***FIGURE 9.6*** Colors flipped, new node inserted.
>
> The tree is still red-black correct. The root is black, there's no
> situation in which a parent and child are both red, and all the paths
> have the same number of black nodes (two). Adding the new red node
> didn't change the red-black correctness.

##### Experiment 4: An Unbalanced Tree

> Now let's see what happens when you try to do something that leads to
> an unbal- anced tree. In Figure 9.6 one path has one more node than
> the other. This isn't very unbalanced, and no red-black rules are
> violated, so neither we nor the red-black algo- rithms need to worry
> about it. However, suppose that one path differs from another by two
> or more levels (where level is the same as the number of nodes along
> the path). In this case the red-black rules will always be violated,
> and we'll need to rebal- ance the tree.
>
> Insert a 6 into the tree of Figure 9.6. You'll see the message Error:
> parent and child are both red. Rule 3 has been violated, as shown in
> Figure 9.7.
>
> 440 **CHAPTER 9** Red-Black Trees
>
> ![](media/image22.png)50
>
> 25
>
> 75
>
> Red parent and
>
> 12 [ ]{.underline} child violates
>
> Rule 3
>
> Changing this to
>
> 6 black violates Rule 4
>
> ***FIGURE 9.7*** Parent and child are both red.
>
> How can we fix the tree so Rule 3 isn't violated? An obvious approach
> is to change one of the offending nodes to black. Let's try changing
> the child node, 6. Position the red arrow on it and press the R/B
> button. The node becomes black.
>
> The good news is we fixed the problem of both parent and child being
> red. The bad news is that now the message says Error: Black heights
> differ. The path from the root to node 6 has three black nodes in it,
> while the path from the root to node 75 has only two. Thus, Rule 4 is
> violated. It seems we can't win.
>
> This problem can be fixed with a rotation and some color changes. How
> to do this will be the topic of later sections.

##### More Experiments

> Experiment with the RBTree Workshop applet on your own. Insert more
> nodes and see what happens. See if you can use rotations and color
> changes to achieve a balanced tree. Does keeping the tree red-black
> correct seem to guarantee an (almost) balanced tree?
>
> Try inserting ascending keys (50, 60, 70, 80, 90) and then restart
> with the Start
>
> button and try descending keys (50, 40, 30, 20, 10). Ignore the
> messages; we'll see what they mean later. These are the situations
> that get the ordinary binary search tree into trouble. Can you still
> balance the tree?

##### The Red-Black Rules and Balanced Trees

> Try to create a tree that is unbalanced by two or more levels but is
> red-black correct. As it turns out, this is impossible. That's why the
> red-black rules keep the tree balanced. If one path is more than one
> node longer than another, it must either

Rotations 441

> have more black nodes, violating Rule 4, or it must have two adjacent
> red nodes, violating Rule 3. Convince yourself that this is true by
> experimenting with the applet.

##### Null Children

> Remember that Rule 4 specifies all paths that go from the root to any
> leaf or to *any null children* must have the same number of black
> nodes. A null child is a child that a non-leaf node might have, but
> doesn't. (That is, a missing left child if the node has a right child,
> or vice versa.) Thus, in Figure 9.8 the path from 50 to 25 to the
> right child of 25 (its null child) has only one black node, which is
> not the same as the paths to 6 and 75, which have two. This
> arrangement violates Rule 4, although both paths to leaf nodes have
> the same number of black nodes.
>
> ![](media/image27.png)50
>
> 25

75

> Black height is 2
>
> 12 [ ]{.underline} Null child of 25
>
> Black height is 1
>
> 6 [ ]{.underline} Null child of 12
>
> Black height is 2
>
> Black height is 2
>
> ***FIGURE 9.8*** Path to a null child.
>
> The term *black height* is used to describe the number of black nodes
> from the root to a given node. In Figure 9.8 the black height of 50 is
> 1, of 25 is still 1, of 12 is 2, and so on.

#### Rotations

> To balance a tree, you need to physically rearrange the nodes. If all
> the nodes are on the left of the root, for example, you need to move
> some of them over to the right side. This is done using *rotations*.
> In this section we'll learn what rotations are and how to execute
> them. Rotations must do two things at once:
>
> 442 **CHAPTER 9** Red-Black Trees

-   Raise some nodes and lower others to help balance the tree.

-   Ensure that the characteristics of a binary search tree are not
    violated.

> Recall that in a binary search tree the left children of any node have
> key values less than the node, while its right children have key
> values greater than or equal to the node. If the rotation didn't
> maintain a valid binary search tree, it wouldn't be of much use,
> because the search algorithm, as we saw in the preceding chapter,
> relies on the search-tree arrangement.
>
> Note that color rules and node color changes are used only to help
> decide when to perform a rotation. Fiddling with the colors doesn't
> accomplish anything by itself; it's the rotation that's the heavy
> hitter. Color rules are like rules of thumb for build- ing a house
> (such as "exterior doors open inward"), while rotations are like the
> hammering and sawing needed to actually build it.

##### Simple Rotations

> In Experiment 2 we tried rotations to the left and right. Those
> rotations were easy to visualize because they involved only three
> nodes. Let's clarify some aspects of this process.

####### What's Rotating?

> The term *rotation* can be a little misleading. The nodes themselves
> aren't rotated; it's the relationship between them that changes. One
> node is chosen as the "top" of the rotation. If we're doing a right
> rotation, this "top" node will move down and to the right, into the
> position of its right child. Its left child will move up to take its
> place.
>
> Remember that the top node isn't the "center" of the rotation. If we
> talk about a car tire, the top node doesn't correspond to the axle or
> the hubcap; it's more like the topmost part of the tire tread.
>
> The rotation we described in Experiment 2 was performed with the root
> as the top node, but of course any node can be the top node in a
> rotation, provided it has the appropriate child.

####### Mind the Children

> You must be sure that, if you're doing a right rotation, the top node
> has a left child. Otherwise, there's nothing to rotate into the top
> spot. Similarly, if you're doing a left rotation, the top node must
> have a right child.

##### The Weird Crossover Node

> Rotations can be more complicated than the three-node example we've
> discussed so far. Click Start, and then, with 50 already at the root,
> insert nodes with the following values, in this order: 25, 75, 12, 37.

Rotations 443

> When you try to insert the 12, you'll see the Can't insert: needs
> color flip message. Just click the Flip button. The parent and
> children change color. Then press Ins again to complete the insertion
> of the 12. Finally, insert the 37. The resulting arrangement is shown
> in Figure 9.9a.
>
> ![](media/image33.png)a)
>
> ![](media/image22.png)b)
>
> ***FIGURE 9.9*** Rotation with crossover node.
>
> Now we'll try a rotation. Place the arrow on the root (don't forget
> this!) and press the RoR button. All the nodes move. The 12 follows
> the 25 up, and the 50 follows the 75 down.
>
> But what's this? The 37 has detached itself from the 25, whose right
> child it was, and become instead the left child of 50. Some nodes go
> up, some nodes go down, but the 37 moves *across*. The result is shown
> in Figure 9.9b. The rotation has caused a viola- tion of Rule 4; we'll
> see how to fix this problem later.
>
> In the original position of Figure 9.9a, the 37 is called an *inside
> grandchild* of the top node, 50. (The 12 is an *outside grandchild*.)
> The inside grandchild, if it's the child of the node that's going up
> (which is the left child of the top node in a right rotation) is
> always disconnected from its parent and reconnected to its former
> grandparent. It's like becoming your own uncle (although it's best not
> to dwell too long on this analogy).
>
> 444 **CHAPTER 9** Red-Black Trees

##### Subtrees on the Move

> We've shown individual nodes changing position during a rotation, but
> entire subtrees can move as well. To see this, click Start to put 50
> at the root, and then insert the following sequence of nodes in order:
> 25, 75, 12, 37, 62, 87, 6, 18, 31, 43. Click Flip whenever you can't
> complete an insertion because of the Can't insert: needs color flip
> message. The resulting arrangement is shown in Figure 9.10a.

![](media/image40.png)![](media/image14.png)

> ***FIGURE 9.10*** Subtree motion during rotation.

Inserting a New Node 445

> Position the arrow on the root, 50. Now press RoR. Wow! (Or is it
> WoW?) A lot of nodes have changed position. The result is shown in
> Figure 9.10b. Here's what happens:

-   The top node (50) goes to its right child.

-   The top node's left child (25) goes to the top.

-   The entire subtree of which 12 is the root moves up.

-   The entire subtree of which 37 is the root moves across to become
    the left child of 50.

-   The entire subtree of which 75 is the root moves down.

> You'll see the Error: root must be black message, but you can ignore
> it for the moment. You can flip back and forth by alternately pressing
> RoR and RoL with the arrow on the top node. Do this and watch what
> happens to the subtrees, especially the one with 37 as its root.
>
> In Figure 9.10, the subtrees are encircled by dotted triangles. Note
> that the relations of the nodes within each subtree are unaffected by
> the rotation. The entire subtree moves as a unit. The subtrees can be
> larger (have more descendants) than the three nodes we show in this
> example. No matter how many nodes there are in a subtree, they will
> all move together during a rotation.

##### Human Beings Versus Computers

> At this point, you've learned pretty much all you need to know about
> what a rota- tion does. To cause a rotation, you position the arrow on
> the top node and then press RoR or RoL. Of course, in a real red-black
> tree insertion algorithm, rotations happen under program control,
> without human intervention.
>
> Notice however that, in your capacity as a human being, you could
> probably balance any tree just by looking at it and performing
> appropriate rotations. Whenever a node has a lot of left descendants
> and not too many right ones, you rotate it right, and vice versa.
>
> Unfortunately, computers aren't very good at "just looking" at a
> pattern. They work better if they can follow a few simple rules.
> That's what the red-black scheme provides, in the form of color coding
> and the four color rules.

#### Inserting a New Node

> Now you have enough background to see how a red-black tree's insertion
> routine uses rotations and the color rules to maintain the tree's
> balance.
>
> 446 **CHAPTER 9** Red-Black Trees

##### Preview of the Insertion Process

> We're going to briefly preview our approach to describing the
> insertion process. Don't worry if things aren't completely clear in
> the preview; we'll discuss this process in more detail in a moment.
>
> In the discussion that follows, we'll use X, P, and G to designate a
> pattern of related nodes. X is a node that has caused a rule
> violation. (Sometimes X refers to a newly inserted node, and sometimes
> to the child node when a parent and child have a red- red conflict.)

-   X is a particular node.

-   P is the parent of X.

-   G is the grandparent of X (the parent of P).

> On the way down the tree to find the insertion point, you perform a
> color flip whenever you find a black node with two red children (a
> violation of Rule 2). Sometimes the flip causes a red-red conflict (a
> violation of Rule 3). Call the red child X and the red parent P. The
> conflict can be fixed with a single rotation or a double rotation,
> depending on whether X is an outside or inside grandchild of G.
> Following color flips and rotations, you continue down to the
> insertion point and insert the new node.
>
> After you've inserted the new node X, if P is black, you simply attach
> the new red node. If P is red, there are two possibilities: X can be
> an outside or inside grandchild of G. You perform two color changes
> (we'll see what they are in a moment). If X is an outside grandchild,
> you perform one rotation, and if it's an inside grandchild, you
> perform two. This restores the tree to a balanced state.
>
> Now we'll recapitulate this preview in more detail. We'll divide the
> discussion into three parts, arranged in order of complexity:

1.  Color flips on the way down

2.  Rotations after the node is inserted

3.  Rotations on the way down

> If we were discussing these three parts in strict chronological order,
> we would examine part 3 before part 2. However, it's easier to talk
> about rotations at the bottom of the tree than in the middle, and
> operations 1 and 2 are encountered more frequently than operation 3,
> so we'll discuss 2 before 3.

##### Color Flips on the Way Down

> The insertion routine in a red-black tree starts off doing essentially
> the same thing it does in an ordinary binary search tree: It follows a
> path from the root to the place

Inserting a New Node 447

> where the node should be inserted, going left or right at each node
> depending on the relative size of the node's key and the search key.
>
> However, in a red-black tree, getting to the insertion point is
> complicated by color flips and rotations. We introduced color flips in
> Experiment 3; now we'll look at them in more detail.
>
> Imagine the insertion routine proceeding down the tree, going left or
> right at each node, searching for the place to insert a new node. To
> make sure the color rules aren't broken, it needs to perform color
> flips when necessary. Here's the rule: Every time the insertion
> routine encounters a black node that has two red children, it must
> change the children to black and the parent to red (unless the parent
> is the root, which always remains black).
>
> How does a color flip affect the red-black rules? For convenience,
> let's call the node at the top of the triangle, the one that's red
> before the flip, P for parent. We'll call P's left and right children
> X1 and X2. This arrangement is shown in Figure 9.11a.

![](media/image14.png)![](media/image17.png)

> ***FIGURE 9.11*** Color flip.

####### Black Heights Unchanged

> Figure 9.11b shows the nodes after the color flip. The flip leaves
> unchanged the number of black nodes on the path from the root on down
> through P to the leaf or null nodes. All such paths go through P, and
> then through either X1 or X2. Before the flip, only P is black, so the
> triangle (consisting of P, X1, and X2) adds one black node to each of
> these paths.
>
> After the flip, P is no longer black, but both X1 and X2 are, so again
> the triangle contributes one black node to every path that passes
> through it. So a color flip can't cause Rule 4 to be violated.
>
> Color flips are helpful because they make red leaf nodes into black
> leaf nodes. This makes it easier to attach new red nodes without
> violating Rule 3.
>
> 448 **CHAPTER 9** Red-Black Trees

####### Violation of Rule 3

> Although Rule 4 is not violated by a color flip, Rule 3 (a node and
> its parent can't both be red) may be. If the parent of P is black,
> there's no problem when P is changed from black to red. However, if
> the parent of P is red, then, after the color change, we'll have two
> reds in a row.
>
> This problem needs to be fixed before we continue down the path to
> insert the new node. We can correct the situation with a rotation, as
> we'll soon see.

####### The Root Situation

> What about the root? Remember that a color flip of the root and its
> two children leaves the root, as well as its children, black. This
> color flip avoids violating Rule 2. Does this affect the other
> red-black rules? Clearly, there are no red-to-red conflicts because
> we've made more nodes black and none red. Thus, Rule 3 isn't violated.
>
> Also, because the root and one or the other of its two children are in
> every path, the black height of every path is increased the same
> amount---that is, by 1. Thus, Rule 4 isn't violated either.

####### Finally, Just Insert It

> After you've worked your way down to the appropriate place in the
> tree, performing color flips (and rotations) if necessary on the way
> down, you can then insert the new node as described in the preceding
> chapter for an ordinary binary search tree.
>
> However, that's not the end of the story.

##### Rotations After the Node Is Inserted

> The insertion of the new node may cause the red-black rules to be
> violated. Therefore, following the insertion, we must check for rule
> violations and take appropriate steps.
>
> Remember that, as described earlier, the newly inserted node, which
> we'll call X, is always red. X may be located in various positions
> relative to P and G, as shown in Figure 9.12.
>
> Remember that a node X is an outside grandchild if it's on the same
> side of its parent P that P is of its parent G. That is, X is an
> outside grandchild if either it's a left child of P and P is a left
> child of G (Figure 9.12a), or it's a right child of P and P is a right
> child of G (Figure 9.12d). Conversely, X is an inside grandchild if
> it's on the opposite side of its parent P that P is of its parent G
> (Figures 9.12b and 9.12c).
>
> The multiplicity of what we might call "handed" (left or right)
> variations shown in Figure 9.12 is one reason the red-black insertion
> routine is so complex to program.

Inserting a New Node 449

> ![](media/image48.png)Outside grandchild (Left child)

![](media/image54.png)

> Inside grandchild (Right child)

a)  ![](media/image48.png)![](media/image54.png)d)

> Inside grandchild (Left child)
>
> Outside grandchild (Right child)
>
> ***FIGURE 9.12*** Handed variations of node being inserted.
>
> The action we take to restore the red-black rules is determined by the
> colors and configuration of X and its relatives. Perhaps surprisingly,
> nodes can be arranged in only three major ways (not counting the
> handed variations already mentioned). Each possibility must be dealt
> with in a different way to preserve red-black correct- ness and
> thereby lead to a balanced tree. We'll list the three possibilities
> briefly and then discuss each one in detail in its own section. Figure
> 9.13 shows what they look like. Remember that X is always red.

1.  P is black.

2.  P is red and X is an outside grandchild of G.

3.  P is red and X is an inside grandchild of G.

> You might think that this list doesn't cover all the possibilities.
> We'll return to this question after we've explored these three.
>
> 450 **CHAPTER 9** Red-Black Trees
>
> ![](media/image48.png)![](media/image70.png)X

a)  Possibility 1: P is black

b)  Possibility 2: P is red, and X is outside

![](media/image73.png)G

P Red

X Inside grandchild

c)  Possibility 3: P is red, and X is inside

> ***FIGURE 9.13*** Three post-insertion possibilities.

####### Possibility 1: P Is Black

> If P is black, we get a free ride. The node we've just inserted is
> always red. If its parent is black, there's no red-to-red conflict
> (Rule 3) and no addition to the number of black nodes (Rule 4). Thus,
> no color rules are violated. We don't need to do anything else. The
> insertion is complete.

####### Possibility 2: P Is Red and X Is Outside

> If P is red and X is an outside grandchild, we need a single rotation
> and some color changes. Let's set this up with the RBTree Workshop
> applet so we can see what we're talking about. Start with the usual 50
> at the root, and insert 25, 75, and 12. You'll need to do a color flip
> before you insert the 12.
>
> Now insert 6, which is X, the new node. Figure 9.14a shows the
> resulting tree. The message on the Workshop applet says Error: parent
> and child both red, so we know we need to take some action.

Inserting a New Node 451

![](media/image76.png)P

X

> ![](media/image84.png)b)
>
> ***FIGURE 9.14*** P is red and X is an outside grandchild.
>
> In this situation, we can take three steps to restore red-black
> correctness and thereby balance the tree. Here are the steps:

1.  Switch the color of X's grandparent G (25 in this example).

2.  Switch the color of X's parent P (12).

3.  Rotate with X's grandparent G (25) at the top, in the direction that
    raises X (6). This is a right rotation in the example.

> As you've learned, to switch colors, put the arrow on the node and
> press the R/B button. To rotate right, put the arrow on the top node
> and press RoR. When you've completed the three steps, the Workshop
> applet will inform you that the Tree is red/black correct. It's also
> more balanced than it was, as shown in Figure 9.14b.
>
> In this example, X was an outside grandchild and a left child. There's
> a symmetrical situation when the X is an outside grandchild but a
> right child. Try this by creating the tree 50, 25, 75, 87, 93 (with
> color flips when necessary). Fix it by changing the colors of 75 and
> 87, and rotating left with 75 at the top. Again, the tree is balanced.

####### Possibility 3: P Is Red and X Is Inside

> If P is red and X is an inside grandchild, we need two rotations and
> some color changes. To see this one in action, use the RBTree Workshop
> applet to create the tree
>
> 452 **CHAPTER 9** Red-Black Trees
>
> 50, 25, 75, 12, 18. (Again, you'll need a color flip before you insert
> the 12.) The result is shown in Figure 9.15a.
>
> Note that the 18 node is an inside grandchild. It and its parent are
> both red, so again you see the error message Error: parent and child
> both red.
>
> Fixing this arrangement is slightly more complicated. If we try to
> rotate right with the grandparent node G (25) at the top, as we did in
> Possibility 2, the inside grand- child X (18) moves across rather than
> up, so the tree is no more balanced than before. (Try this, then
> rotate back, with 12 at the top, to restore it.) A different solution
> is needed.
>
> The trick when X is an inside grandchild is to perform *two* rotations
> rather than one. The first changes X from an inside grandchild to an
> outside grandchild, as shown in Figures 9.15a and 9.15b. Now the
> situation is similar to Possibility 1, and we can apply the same
> rotation, with the grandparent at the top, as we did before. The
> result is shown in Figure 9.15c.
>
> ![](media/image93.png)G 50

a\) 25 [ ]{.underline}

> Color change

P

> 12

Rotation 1

> X
>
> 18 Color change
>
> ![](media/image91.png)
>
> ![](media/image73.png)c)
>
> ***FIGURE 9.15*** P is red and X is an inside grandchild.

Inserting a New Node 453

> We must also recolor the nodes. We do this before doing any rotations.
> (This order doesn't really matter, but if we wait until after the
> rotations to recolor the nodes, it's hard to know what to call them.)
> Here are the steps:

1.  Switch the color of X's grandparent (25 in this example).

2.  Switch the color of X (*not* its parent; X is 18 here).

3.  Rotate with X's parent P at the top (*not* the grandparent; the
    parent is 12), in the direction that raises X (a left rotation in
    this example).

4.  Rotate again with X's grandparent (25) at the top, in the direction
    that raises X (a right rotation).

> The rotations and recoloring restore the tree to red-black correctness
> and also balance it (as much as possible). As with Possibility 2,
> there is an analogous case in which P is the right child of G rather
> than the left.

####### What About Other Possibilities?

> Do the three Post-Insertion Possibilities we just discussed really
> cover all situations?
>
> Suppose, for example, that X has a sibling S, the other child of P.
> This scenario might complicate the rotations necessary to insert X.
> But if P is black, there's no problem inserting X (that's Possibility
> 1). If P is red, both its children must be black (to avoid violating
> Rule 3). It can't have a single child S that's black because the black
> heights would be different for S and the null child. However, we know
> X is red, so we conclude that it's impossible for X to have a sibling
> unless P is red.
>
> Another possibility is that G, the grandparent of P, has a child U,
> the sibling of P and the uncle of X. Again, this scenario would
> complicate any necessary rotations.
>
> However, if P is black, there's no need for rotations when inserting
> X, as we've seen. So let's assume P is red. Then U must also be red;
> otherwise, the black height going from G to P would be different from
> that going from G to U. But a black parent with two red children is
> flipped on the way down, so this situation can't exist either.
>
> Thus, the three possibilities just discussed are the only ones that
> can exist (except that, in Possibilities 2 and 3, X can be a right or
> left child and G can be a right or left child).

####### What the Color Flips Accomplished

> Suppose that performing a rotation and appropriate color changes
> caused other violations of the red-black rules to appear further up
> the tree. You can imagine situa- tions in which you would need to work
> your way all the way back up the tree, performing rotations and color
> switches, to remove rule violations.
>
> Fortunately, this situation can't arise. Using color flips on the way
> down has elimi- nated the situations in which a rotation could
> introduce any rule violations further up the tree. It ensures that one
> or two rotations will restore red-black correctness in
>
> 454 **CHAPTER 9** Red-Black Trees
>
> the entire tree. Actually, proving this is beyond the scope of this
> book, but such a proof is possible.
>
> The color flips on the way down make insertion in red-black trees more
> efficient than in other kinds of balanced trees, such as AVL trees.
> They ensure that you need to pass through the tree only once, on the
> way down.

##### Rotations on the Way Down

> Now we'll discuss the last of the three operations involved in
> inserting a node: making rotations on the way down to the insertion
> point. As we noted, although we're discussing this operation last, it
> actually takes place before the node is inserted. We've waited until
> now to discuss it only because it was easier to explain rotations for
> a just-installed node than for nodes in the middle of the tree.
>
> In the discussion of color flips during the insertion process, we
> noted that a color flip can cause a violation of Rule 3 (a parent and
> child can't both be red). We also noted that a rotation can fix this
> violation.
>
> On the way down there are two possibilities, corresponding to
> Possibility 2 and Possibility 3 during the insertion phase described
> earlier. The offending node can be an outside grandchild, or it can be
> an inside grandchild. (In the situation corre- sponding to Possibility
> 1, no action is required.)

####### Outside Grandchild

> First, we'll examine an example in which the offending node is an
> outside grand- child. By "offending node," we mean the child in the
> parent-child pair that caused the red-red conflict.
>
> Start a new tree with the 50 node, and insert the following nodes: 25,
> 75, 12, 37, 6, and 18. You'll need to do color flips when inserting 12
> and 6.
>
> Now try to insert a node with the value 3. You'll be told you must do
> a flip, of 12 and its children 6 and 18. You press the Flip button.
> The flip is carried out, but now the message says Error: parent and
> child are both red, referring to 25 and its child

12. The resulting tree is shown in Figure 9.16a.

> The procedure used to fix this rule violation is similar to the
> post-insertion operation with an outside grandchild, described
> earlier. We must perform two color switches and one rotation. So we
> can discuss this in the same terms we did when inserting a node, we'll
> call the node at the top of the triangle that was flipped (which is 12
> in this case) X. This looks a little odd, because we're used to
> thinking of X as the node being inserted, and here it's not even a
> leaf node. However, these on-the-way-down rotations can take place
> anywhere within the tree.
>
> The parent of X is P (25 in this case), and the grandparent of X---the
> parent of P---is G (50 in this case). We follow the same set of rules
> we did under Possibility 2, discussed earlier:

Inserting a New Node 455

1.  Switch the color of X's grandparent G (50 in this example). Ignore
    the message that the root must be black.

2.  Switch the color of X's parent P (25).

3.  Rotate with X's grandparent (50) at the top, in the direction that
    raises X (here a right rotation).

> ![](media/image112.png)G
>
> 50 Change color
>
> Rotate

P

a)  25 Change color 75

X

12 37

6 18

> ![](media/image54.png)Color flip changes 12 and 50
>
> ***FIGURE 9.16*** Outside grandchild on the way down.
>
> Suddenly, the tree is balanced! It has also become pleasantly
> symmetrical. This appears to be a bit of a miracle, but it's only the
> result of following the color rules.
>
> Now the node with value 3 can be inserted in the usual way. Because
> the node it connects to, 6, is black, there's no complexity about the
> insertion. One color flip (at
>
> 50\) is necessary. Figure 9.16b shows the tree after 3 is inserted.

####### Inside Grandchild

> If X is an inside grandchild when a red-red conflict occurs on the way
> down, two rotations are required to set it right. This situation is
> similar to the inside grandchild in the post-insertion phase, which we
> called Possibility 3.
>
> 456 **CHAPTER 9** Red-Black Trees
>
> Click Start in the RBTree Workshop applet to begin with 50, and insert
> 25, 75, 12, 37, 31, and 43. You'll need color flips before 12 and 31.
>
> Now try to insert a new node with the value 28. You'll be told you
> need a color flip (at 37). But when you perform the flip, 37 and 25
> are both red, and you get the Error: parent and child are both red
> message. Don't press Ins again.
>
> In this situation G is 50, P is 25, and X is 37, as shown in Figure
> 9.17a.

P

a\) 25

> G
>
> ![](media/image137.png)50 Change color
>
> 75

12 Rotate

> X
>
> 37 Change color

31 43

![](media/image145.png)

> ![](media/image158.png)c)
>
> ***FIGURE 9.17*** Inside grandchild on the way down.
>
> The Efficiency of Red-Black Trees 457
>
> To cure the red-red conflict, you must do the same two color changes
> and two rotations as in Possibility 3:

1.  Change the color of G (it's 50; ignore the message that the root
    must be black).

2.  Change the color of X (37).

3.  Rotate with P (25) as the top, in the direction that raises X (left
    in this example). The result is shown in Figure 9.17b.

4.  Rotate with G (50) as the top, in the direction that raises X (right
    in this example).

> Now you can insert the 28. A color flip changes 25 and 50 to black as
> you insert it. The result is shown in Figure 9.17c.
>
> This concludes the description of how a tree is kept red-black
> correct, and therefore balanced, during the insertion process.

#### Deletion

> As you may recall, coding for deletion in an ordinary binary search
> tree is consider- ably harder than for insertion. The same is true in
> red-black trees, but in addition, the deletion process is, as you
> might expect, complicated by the need to restore red- black
> correctness after the node is removed.
>
> In fact, the deletion process is so complicated that many programmers
> sidestep it in various ways. One approach, as with ordinary binary
> trees, is to mark a node as deleted without actually deleting it. Any
> search routine that finds the node knows not to tell anyone about it.
> This solution works in many situations, especially if dele- tions are
> not a common occurrence. In any case, we're going to forgo a
> discussion of the deletion process. You can refer to Appendix B,
> "Further Reading," if you want to pursue it.

#### The Efficiency of Red-Black Trees

> Like ordinary binary search trees, a red-black tree allows for
> searching, insertion, and deletion in O(log2N) time. Search times
> should be almost the same in the red-black tree as in the ordinary
> tree because the red-black characteristics of the tree aren't used
> during searches. The only penalty is that the storage required for
> each node is increased slightly to accommodate the red-black color (a
> boolean variable).
>
> More specifically, according to Sedgewick (see Appendix B), in
> practice a search in a red-black tree takes about log2N comparisons,
> and it can be shown that the search cannot require more than 2\*log2N
> comparisons.
>
> 458 **CHAPTER 9** Red-Black Trees
>
> The times for insertion and deletion are increased by a constant
> factor because of having to perform color flips and rotations on the
> way down and at the insertion point. On the average, an insertion
> requires about one rotation. Therefore, insertion still takes O(log2N)
> time but is slower than insertion in the ordinary binary tree.
>
> Because in most applications there will be more searches than
> insertions and dele- tions, there is probably not much overall time
> penalty for using a red-black tree instead of an ordinary tree. Of
> course, the advantage is that in a red-black tree sorted data doesn't
> lead to slow O(N) performance.

#### Red-Black Tree Implementation

> If you're writing an insertion routine for red-black trees, all you
> need to do (irony intended) is to write code to carry out the
> operations described in the preceding sections. As we noted, showing
> and describing such code is beyond the scope of this book. However,
> here's what you'll need to think about.
>
> You'll need to add a red-black field (which can be type boolean) to
> the Node class.
>
> You can adapt the insertion routine from the tree.java program
> (Listing 8.1) in Chapter 8. On the way down to the insertion point,
> check if the current node is black and its two children are both red.
> If so, change the color of all three (unless the parent is the root,
> which must be kept black).
>
> After a color flip, check that there are no violations of Rule 3. If
> so, perform the appropriate rotations: one for an outside grandchild,
> two for an inside grandchild.
>
> When you reach a leaf node, insert the new node as in tree.java,
> making sure the node is red. Check again for red-red conflicts, and
> perform any necessary rotations.
>
> Perhaps surprisingly, your software need not keep track of the black
> height of differ- ent parts of the tree (although you might want to
> check this during debugging). You need to check only for violations of
> Rule 3, a red parent with a red child, which can be done locally
> (unlike checks of black heights, Rule 4, which would require more
> complex bookkeeping).
>
> If you perform the color flips, color changes, and rotations described
> earlier, the black heights of the nodes should take care of themselves
> and the tree should remain balanced. The RBTree Workshop applet
> reports black-height errors only because the user is not forced to
> carry out the insertion algorithm correctly.

#### Other Balanced Trees

> The *AVL tree* is the earliest kind of balanced tree. It's named after
> its inventors: Adelson-Velskii and Landis. In AVL trees each node
> stores an additional piece of data: the difference between the heights
> of its left and right subtrees. This difference may

Summary 459

> not be larger than 1. That is, the height of a node's left subtree may
> be no more than one level different from the height of its right
> subtree.
>
> Following insertion, the root of the lowest subtree into which the new
> node was inserted is checked. If the height of its children differs by
> more than 1, a single or double rotation is performed to equalize
> their heights. The algorithm then moves up and checks the node above,
> equalizing heights if necessary. This check continues all the way back
> up to the root.
>
> Search times in an AVL tree are O(logN) because the tree is guaranteed
> to be balanced. However, because two passes through the tree are
> necessary to insert (or delete) a node, one down to find the insertion
> point and one up to rebalance the tree, AVL trees are not as efficient
> as red-black trees and are not used as often.
>
> The other important kind of balanced tree is the *multiway tree*, in
> which each node can have more than two children. We'll look at one
> version of multiway trees, the 2- 3-4 tree, in the next chapter. One
> problem with multiway trees is that each node must be larger than for
> a binary tree because it needs a reference to every one of its
> children.

#### Summary

-   It's important to keep a binary search tree balanced to ensure that
    the time necessary to find a given node is kept as short as
    possible.

-   Inserting data that has already been sorted can create a maximally
    unbalanced tree, which will have search times of O(N).

-   In the red-black balancing scheme, each node is given a new
    characteristic: a color that can be either red or black.

-   A set of rules, called red-black rules, specifies permissible ways
    that nodes of different colors can be arranged.

-   These rules are applied while inserting (or deleting) a node.

-   A color flip changes a black node with two red children to a red
    node with two black children.

-   In a rotation, one node is designated the top node.

-   A right rotation moves the top node into the position of its right
    child, and the top node's left child into its position.

-   A left rotation moves the top node into the position of its left
    child, and the top node's right child into its position.

-   Color flips, and sometimes rotations, are applied while searching
    down the tree to find where a new node should be inserted. These
    flips simplify returning the tree to red-black correctness following
    an insertion.

> 460 **CHAPTER 9** Red-Black Trees

-   After a new node is inserted, red-red conflicts are checked again.
    If a violation is found, appropriate rotations are carried out to
    make the tree red-black correct.

-   These adjustments result in the tree being balanced, or at least
    almost balanced.

-   Adding red-black balancing to a binary tree has only a small
    negative effect on average performance, and avoids worst-case
    performance when the data is already sorted.

#### Questions

> These questions are intended as a self-test for readers. Answers may
> be found in Appendix C.

1.  A balanced binary search tree is desirable because it avoids slow
    performance when data is inserted [ ]{.underline} .

2.  In a balanced tree,

    a.  the tree may need to be restructured during searches.

    b.  the paths from the root to all the leaf nodes are about the same
        length.

    c.  all left subtrees are the same height as all right subtrees.

    d.  the height of all subtrees is closely controlled.

3.  True or False: The red-black rules rearrange the nodes in a tree to
    balance it.

4.  A null child is

    e.  a child that doesn't exist but will be created next.

    f.  a child with no children of its own.

    g.  one of the two potential children of a leaf node where an
        insertion will be made.

    h.  a non-existent left child of a node with a right child (or vice
        versa).

5.  Which of the following is *not* a red-black rule?

    i.  Every path from a root to a leaf, or to a null child, must
        contain the same number of black nodes.

    j.  If a node is black, its children must be red.

    k.  The root is always black.

    l.  All three are valid rules.

Questions 461

6.  The two possible actions used to balance a tree are [ ]{.underline}
    and [ ]{.underline} .

7.  Newly inserted nodes are always colored [ ]{.underline} .

8.  Which of the following is *not* involved in a rotation?

    m.  rearranging nodes to restore the characteristics of a binary
        search tree

    n.  changing the color of nodes

    o.  ensuring the red-black rules are followed

    p.  attempting to balance the tree

9.  A "crossover" node or subtree starts as a [ ]{.underline} and
    becomes a [ ]{.underline} , or vice versa.

10. Which of the following is *not* true? Rotations may need to be made

    q.  before a node is inserted.

    r.  after a node is inserted.

    s.  during a search for the insertion point.

    t.  when searching for a node with a given key.

11. A color flip involves changing the color of [ ]{.underline} and [
    ]{.underline} .

12. An outside grandchild is

    u.  on the opposite side of its parent that its parent is of its
        sibling.

    v.  on the same side of its parent that its parent is of its parent.

    w.  one which is the left descendant of a right descendant (or vice
        versa).

    x.  on the opposite side of its parent that its sibling is of their
        grandparents.

13. True or False: When one rotation immediately follows another, they
    are in opposite directions.

14. Two rotations are necessary when

    y.  the node is an inside grandchild and the parent is red.

    z.  the node is an inside grandchild and the parent is black.

    a.  the node is an outside grandchild and the parent is red.

    b.  the node is an outside grandchild and the parent is black.

15. True or False: Deletion in a red-black tree may require some
    readjustment of the tree's structure.

> 462 **CHAPTER 9** Red-Black Trees

#### Experiments

> Carrying out these experiments will help to provide insights into the
> topics covered in the chapter. No programming is involved.

1.  Make an activity diagram or flowchart of all the node arrangements
    and colors you can encounter when inserting a new node in a
    red-black tree, and what you should do in each situation to insert a
    new node.

2.  Use the RBTree Workshop applet to set up all the situations depicted
    in Experiment 1 and follow the instructions for insertion.

3.  Do enough insertions to convince yourself that if red-black rules 1,
    2, and 3 are followed exactly, Rule 4 will take care of itself.

> **[NOTE ]{.underline}**
>
> Because no code was shown in this chapter, it hardly seems fair to
> include any programming projects. If you want a serious challenge,
> implement a red-black tree. You might start with the tree.java program
> (Listing 8.1) from Chapter 8.
