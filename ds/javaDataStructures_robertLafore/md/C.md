C
=

Answers to Questions
--------------------

#### Chapter 1, Overview

##### Answers to Questions

1.  insert, search for, delete

2.  sorting

3.  c

4.  search key

5.  b

6.  a

7.  d

8.  method

9.  dot

10. data types

#### Chapter 2, Arrays

##### Answers to Questions

1.  d

2.  True

3.  b

4.  False

5.  new

6.  d

##### IN THIS APPENDIX

-   Chapter 1, Overview

-   Chapter 2, Arrays

-   Chapter 3, Simple Sorting

-   Chapter 4, Stacks and Queues

-   Chapter 5, Linked Lists

-   Chapter 6, Recursion

-   Chapter 7, Advanced Sorting

-   Chapter 8, Binary Trees

-   Chapter 9, Red-Black Trees

-   Chapter 10, 2-3-4 Trees and External Storage

-   Chapter 11, Hash Tables

-   Chapter 12, Heaps

-   Chapter 13, Graphs

-   Chapter 14, Weighted Graphs

> 740 **APPENDIX C** Answers to Questions

7.  interface

8.  d

9.  raising to a power

> **10.** 3
>
> **11.** 8
>
> **12.** 6

13. False

14. a

15. constant

16. objects

#### Chapter 3, Simple Sorting

##### Answers to Questions

1.  d

2.  comparing and swapping (or copying)

3.  False

4.  a

5.  False

6.  b

7.  False

8.  three

9.  Items with indices less than or equal to outer are sorted.

10. c

11. d

12. copies

13. b

14. Items with indices less than [outer]{.underline} are partially
    sorted.

15. b

Chapter 5, Linked Lists 741

#### Chapter 4, Stacks and Queues

##### Answers to Questions

> **1.** 10

2.  b

3.  Last-In-First-Out; and First-In-First-Out

4.  False. It's the other way around.

5.  b

6.  It doesn't move at all.

> **7.** 45

8.  False. They take O(1) time.

9.  c

10. O(N)

11. c

12. True

13. b

14. Yes, you would need a method to find the minimum value.

15. a

#### Chapter 5, Linked Lists

##### Answers to Questions

1.  b

2.  first

3.  d

> **4.** 2
>
> **5.** 1

6.  c

7.  current.next=null;

8.  Java's garbage collection process destroys it.

> 742 **APPENDIX C** Answers to Questions

9.  a

10. empty

11. a linked list

12. once, if the links include a previous reference

13. a double-ended list

14. b

15. Usually, the list. They both do push() and pop() in O(1) time, but
    the list uses memory more efficiently.

#### Chapter 6, Recursion

##### Answers to Questions

> **1.** 10
>
> **2.** d
>
> **3.** 2
>
> **4.** 10

5.  false

6.  "ed"

7.  b

8.  c

9.  divide-and-conquer

10. the range of cells to search

11. the number of disks to transfer

12. c

13. b

14. b

15. stack

Chapter 8, Binary Trees 743

#### Chapter 7, Advanced Sorting

##### Answers to Questions

1.  c

> **2.** 40

3.  d

4.  false

5.  O(N\*logN), O(N2)

6.  a

7.  pivot

8.  d

9.  true

10. c

11. partitioning the resulting subarrays

12. b

13. pivot

14. log2N

15. true

#### Chapter 8, Binary Trees

##### Answers to Questions

1.  O(logN)

2.  b

3.  True

> **4.** 5

5.  c

6.  node, tree

7.  a

8.  c

> 744 **APPENDIX C** Answers to Questions

9.  finding

10. A, A's left-child descendents

11. d

> **12.** 2\*n+1

13. False

14. compress

15. c

#### Chapter 9, Red-Black Trees

##### Answers to Questions

1.  in order (or inverse order)

2.  b

3.  False

4.  d

5.  b

6.  rotations, changing the colors of nodes

7.  red

8.  a

9.  left child, right child

10. d

11. a node, its two children

12. b

13. True

14. a

15. True

Chapter 11, Hash Tables 745

#### Chapter 10, 2-3-4 Trees and External Storage

##### Answers to Questions

1.  b

2.  balanced

> **3.** 2

4.  False

5.  b

6.  the root is split

7.  a

> **8.** 2

9.  color flip

10. b

11. O(logN)

12. d

13. many

14. True

15. a

#### Chapter 11, Hash Tables

##### Answers to Questions

> **1.** O(1)

2.  hash function

3.  d

4.  linear probing

> **5.** 1, 4, 9, 16, 25

6.  b

7.  linked list

> 746 **APPENDIX C** Answers to Questions
>
> **8. 1.**0

9.  True

10. d

11. the array size

12. False

13. a

14. False

15. the same block

#### Chapter 12, Heaps

##### Answers to Questions

1.  b

2.  Both the right and left children have keys less than (or equal to)
    the parent.

3.  root

4.  a

5.  a

6.  c

7.  array (or linked list)

8.  up

9.  b

10. one

#### Chapter 13, Graphs

##### Answers to Questions

1.  edge, nodes (or vertices)

2.  Count the number of 1s and divide by 2 (assuming the identity
    diagonal is all 0s).

> Chapter 14, Weighted Graphs 747

3.  node

4.  d

> **5.** A:B, B:A---\>C---\>D, C:B, D:B
>
> **6.** a
>
> **7.** 3

8.  c

9.  tree

10. No

11. True

12. d

13. A directed acyclic graph

14. No, by definition

15. Some vertices remain, but none have no successors.

#### Chapter 14, Weighted Graphs

##### Answers to Questions

1.  edges

2.  d

3.  False

4.  the lowest-weight (cheapest) edge

5.  b

6.  is already the destination of an edge with a lower weight

7.  False

8.  a

9.  True

10. a

11. b

12. Warshall's algorithm

> 748 **APPENDIX C** Answers to Questions

13. adjacency matrix

14. 2N, where N is the number of squares on the board minus 1

15. No

> Index
>
> **Symbols**
>
> **. (dot operator), 17**
>
> **= (assignment operator), 23**
>
> **== (equality operator), 25**
>
> **% (modulo operator), hashing, 525 2-3 trees, 492**
>
> implementation, 494-495
>
> node splits, 492-494
>
> **2-3-4 trees, 463-465**
>
> balance, 466 efficiency
>
> speed, 491
>
> storage requirements, 491
>
> experiments, 474
>
> insertion, 466
>
> Java code, 475
>
> DataItem class, 475
>
> Node class, 475
>
> Tree234 class, 476
>
> Tree234App class, 477
>
> node splits, 467-468
>
> nodes per, 491
>
> organization, 465
>
> red-black trees, 486
>
> operational equivalence, 488-490
>
> transforming, 486
>
> root splits, 468-469
>
> searching, 466
>
> 750 2-3-4 trees
>
> Tree234 workshop applet, 470 fill button, 471
>
> find button, 471
>
> ins button, 472
>
> zoom button, 472-473
>
> tree234.java, 478

### A

> **abstract data type, 211 abstraction**
>
> ADTs, 211
>
> class interfaces, 52
>
> **access modifiers, 20 accessing, array elements, 40 addEdge() method,
> 656**
>
> **adjacency (graphs), 616**
>
> **adjacency list, 621**
>
> **adjacency matrix, 620**
>
> directed graphs, 650
>
> **adjust\_sPath() method, 701 ADTs (Abstract Data Types), 202**
>
> abstraction, 211
>
> data types, 210
>
> design tool, 212
>
> interfaces, 211
>
> lists, 211
>
> queue implementation, 206, 209-210
>
> stack implementation, 203, 206
>
> **algorithms, 9, 12**
>
> Big O notation, 70
>
> depth-first search (graphs), 629 Dijkstra's, 689
>
> intractable problems, 710-712
>
> minimum spanning trees for weighted graphs, 676
>
> partition, 330-332
>
> efficiency, 332-333
>
> stopping/swapping, 330-331
>
> quicksort, 333-334
>
> recursion, 272
>
> recursive (Towers of Hanoi), 276 stable, 108
>
> **all-pairs shortest-path problem, weighted graphs, 708-709**
>
> **anagram.java, 265**
>
> **anagrams, 262-265**
>
> **applets, 729**
>
> bubble sort workshop, 81 draw button, 84
>
> new button, 83
>
> run button, 82
>
> size button, 83
>
> step button, 83
>
> GraphD workshop, 652-653
>
> GraphDW workshop, 694-697 GraphN workshop
>
> BFS, 638
>
> DFS, 627
>
> minimum spanning trees, 644 GraphW workshop, 670-671
>
> Hash workshop, 528-532
>
> HashChain workshop, 552
>
> buckets, 554
>
> deletion, 554
>
> duplicates, 554
>
> load factors, 553
>
> table size, 554
>
> HashDouble workshop, 542-545
>
> Heap workshop, 587
>
> change, 588
>
> fill, 587

arrays 751

> insert, 588
>
> remove, 588
>
> insertSort workshop, 97
>
> 10 bars, 97
>
> 100 bars, 97
>
> LinkList workshop, 183
>
> deleting, 184
>
> find, 184
>
> inserting, 183
>
> sorted lists, 213
>
> mergeSort, 285-287
>
> Ordered workshop, 52
>
> binary search, 54
>
> linear search, 53
>
> Partition workshop, 325-327
>
> PriorityQ workshop, 144
>
> delete, 145
>
> implementation, 146
>
> insert, 145
>
> peek/new, 146
>
> queue workshop, 133
>
> empty/full, 135
>
> insert, 134
>
> new, 135
>
> peek, 135
>
> remove, 134
>
> quickSort1 workshop, 340-344
>
> quickSort2 workshop, 350
>
> RBTree workshop, 434 clicking on nodes, 435 del button, 436
>
> find button, 437
>
> flip button, 436
>
> ins button, 435
>
> r/b button, 436
>
> rol button, 436
>
> ror button, 436
>
> start button, 435
>
> text messages, 437
>
> selectSort workshop, 90
>
> Shellsort, 319-321
>
> stack workshop, 118
>
> new, 119
>
> peek, 120
>
> pop, 119
>
> push, 119
>
> size, 120
>
> Towers, 274
>
> Tree workshop, 371-372
>
> Tree234 workshop, 470
>
> fill button, 471
>
> find button, 471
>
> ins button, 472
>
> zoom button, 472-473
>
> **appletviewer utility, 730**
>
> **arguments, Java, 24-25**
>
> **arithmetic expressions, parsing, 149**
>
> evaluating postfix, 167-168, 172-173
>
> infix to postfix notation, 151-152, 155-161,
>
> 165-167
>
> postfix notation, 150
>
> **arithmetic operators, binary trees, 385 array index out of bounds
> exception, 331 array.java, 41, 44**
>
> **Array workshop applet, 34-35 arrays**
>
> accessing elements, 40
>
> Big O notation, 70 binary search, 71
>
> constants, 71
>
> insertion in unordered array, 70 linear search, 70
>
> binary trees, 403-404
>
> choosing, 720
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 752 arrays
>
> creating, 40
>
> example (array.java), 41-43
>
> deletion, 43
>
> displaying, 43
>
> insertion, 43
>
> program organization, 43
>
> searching, 43
>
> hashing, 520
>
> dictionary example, 522
>
> heap.java, 592
>
> holes, 37
>
> initializing, 41
>
> internal, external storage, 511-512 linear probing, 540
>
> logarithms, 62-64
>
> mergesort, 280-282
>
> quadratic probes, 544
>
> Shellsort, 317
>
> sPath, 698
>
> Stack workshop applet, 119 storing objects, 64
>
> versus linked lists, 182 workshop applet, 33-35
>
> deletion, 36-37
>
> duplicate keys, 37-39
>
> insertion, 35
>
> searching, 36
>
> *see also* hashing
>
> **ascending-priority queue, 144**
>
> **assignment, Java, 23 assignment operator (=), 23 atEnd() method,
> 242**
>
> **autoexec.bat, PATH statement (SDK), 731 AVL trees, 458**
>
> **B**
>
> **B-trees (external storage), 500**
>
> choosing, 726
>
> efficiency, 505-506
>
> insertion, 502-503
>
> one block per node, 501 searching, 501
>
> **balanced trees**
>
> AVL, 458
>
> choosing, 721
>
> **bank.java code listing, 18-19 BankAccount class, 20**
>
> constructor, 20
>
> public/private keywords, 20
>
> **BankApp class, 19**
>
> **base classes, 21**
>
> mergesort, 283
>
> **bfs.java, 639**
>
> **Big O notation, 70**
>
> binary search, 71
>
> constants, 71
>
> general-purpose storage structures, 722 insertion in unordered array,
> 70
>
> linear search, 70
>
> sorting algorithms, 725
>
> special-purpose data structures, 724
>
> **binary searches, 54**
>
> Big O notation, 71 find( ) method, 56-58 logarithms, 62
>
> recursion, 268
>
> algorithms, 272
>
> loops, 268-269, 272
>
> **binary search trees, 370**

check() method 753

> **binary trees**
>
> analogy, 370
>
> as arrays, 403-404
>
> choosing, 720
>
> duplicate keys, 404
>
> efficiency, 401
>
> heaps, 580
>
> Huffman code, 415-421
>
> Java code, 373
>
> Node class, 374
>
> Tree class, 375
>
> TreeApp class, 375
>
> max/min values, 388 nodes
>
> deleting, 389-401
>
> finding, 376-378
>
> inserting, 378-381 purpose
>
> linked list searching, 366 ordered array insertion, 365
>
> terms
>
> child, 369
>
> keys, 369
>
> leaf, 369
>
> levels, 369
>
> parent, 369
>
> path, 368
>
> root, 368
>
> subtree, 369
>
> traversing, 369
>
> visiting, 369
>
> traversing, 381
>
> 3-node, 382
>
> inorder, 381
>
> Java code, 382
>
> preorder/postorder, 385
>
> workshop applet, 384
>
> tree.java, 405
>
> workshop applet, 371-372
>
> **binary treesnodes, 366**
>
> **binarySearch.java, 269**
>
> **black height, 441**
>
> color flips, 447
>
> **blocks, 497-498**
>
> full, 573
>
> hashing and external storage, 571-572 insertion, 500
>
> sorting external files, 509
>
> **books, resource, 735-736**
>
> **bottom-up insertion, 430**
>
> **braces {}, 127**
>
> **brackets \[\], 127**
>
> **brackets.java, 128, 131**
>
> **BracketsApp class, 131**
>
> **breadth-first search, 636-638**
>
> bfs.java, 639
>
> GraphN applet, 638
>
> Java code, 638
>
> **bubble sort, 79**
>
> efficiency, 88-89
>
> invariants, 88
>
> Java code, 85-88
>
> workshop applet, 81-84
>
> **bubbleSort() method, 87**
>
> **buckets, 554**

### C

> **C++ (Java for C++ programmers), 22 change() method, heaps and, 591
> CharAt() method, 28**
>
> **check() method, BracketsApp class, 131**
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 754 child (binary trees)
>
> **child (binary trees), 369 children**
>
> 2-3-4 trees, 464
>
> red-black trees, null children, 441 unbalanced trees, 373
>
> **Chng key, 588**
>
> **circular queues, 136**
>
> **classes, 16**
>
> BankAccount, 20
>
> BankApp, 19
>
> data types, 210
>
> DataItem, 475
>
> DistPar, 698
>
> dividing programs into, 44-46 Graph, 622-623
>
> instances, 17
>
> interfaces, 46-51
>
> abstraction, 52
>
> iterator, 232
>
> HighArray, 48
>
> LinkList, 203
>
> ListIterator, 234
>
> LowArray, 46
>
> LowArrayApp, 46
>
> OrdArray, 58
>
> Node, 374-475
>
> heap.java, 592
>
> Params, 295
>
> Person, 65
>
> PostfixApp, 172
>
> Reverser, 126
>
> StackTriangleApp, 295
>
> StackX, 295
>
> methods, 122
>
> Tree, 375
>
> Tree234, 476
>
> inserting, 476
>
> searching, 476
>
> splitting, 476
>
> Tree234App, 477
>
> TreeApp, 375
>
> Vertex, 619
>
> **clustering, 542**
>
> open addressing, 533
>
> quadratic probes, 544
>
> **collisions**
>
> hashing and, 527-528
>
> hashing efficiency, 566
>
> **color flips, 447**

3.  node, 489

4.  node, 488

> accomplishments, 453
>
> **color rules, 433**
>
> **colors, switching, 451**
>
> **compareTo() method, 107 comparisons**
>
> balanced trees, 431
>
> lexicographical, 107
>
> mergesort, 292
>
> **compilers, references, 181 compiling example programs, 733**
>
> **compression, Huffman code, 415-421 connected graphs, 616**
>
> **connectivity, directed graphs, 661-664 console mode, 730**
>
> **constants, Big O notation, 71 constructors, BankAccount class, 20
> container classes, 46**
>
> **copies (mergesort), 291**
>
> **cutoff point, 350**
>
> **cycles (topological sorting), 653-654**

disk drives 755

### D

> **data records, 65**
>
> **data storage, 10**
>
> **data structures, 9**
>
> characteristics, 11
>
> general purpose, 717
>
> arrays, 720
>
> balanced trees, 721 Big O notation, 722
>
> binary search trees, 720 hash tables, 721
>
> libraries, 719
>
> linked lists, 720
>
> speed, 718-719
>
> special purpose, 722 Big O notation, 724 priority queues, 723
>
> queues, 723
>
> stacks, 723 **data types, ADTs, 210 databases, 13-14**
>
> **DataItem class, 475**
>
> **del button, 532**
>
> RBTree workshop, 436
>
> **delete() method**
>
> HighArray class, 52
>
> linear probing, 534
>
> links, 196
>
> **deleting**
>
> array data, 36-37
>
> duplicate keys, 38-39
>
> example (array.java), 43 doubly linked lists, 225 LinkList workshop
> applet, 184
>
> links, 193, 196
>
> delete() method, 196
>
> find() method, 196
>
> nodes, 389
>
> red-black trees, 457 with no children, 389 with one child, 391-393
>
> with two children, 393-401 PriorityQ Workshop applet, 145 separate
> chaining, 554
>
> vertices, 656
>
> **delimiter matching, 127-128, 131-132**
>
> brackets.java, 128-131
>
> opening delimiters, 127-128
>
> **depth-first search, 625-627**
>
> dfs.java, 631
>
> GraphN applet, 627
>
> Java code, 629-630
>
> **deques, 143**
>
> doubly linked lists, 231
>
> **derived classes, 21**
>
> **descending-priority queue, 144, 581**
>
> **destination vertices, 695**
>
> **development systems, 734**
>
> **dfs() method, 629**
>
> **dfs.java, 631**
>
> **dictionary, hashing, 521-524**
>
> **Dijkstra's algorithm, 689**
>
> key points, 694
>
> **directed graphs, 618**
>
> connectivity in, 661-664
>
> topological sorting, 649-652
>
> cycles/trees, 653
>
> GraphD applet, 652-653
>
> **disk drives**
>
> B-trees, insertion, 502
>
> reading, 497
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 756 display() method
>
> **display() method, HighArray class, 52 displayForward() method,
> doubly linked list, 222 displayList() method, iterators, 243
> displayNode() method, 374**
>
> **displayPerson() method, 65**
>
> **displayStack() method, 165**
>
> **displayWord() method, 267**
>
> **DistPar class, 698**
>
> **divide-and-conquer approach, 272**
>
> **doAnagram() method, 263**
>
> **doParse() method, 172**
>
> **doTrans() method, 165 dot operator (.), 17**
>
> **double-ended lists, 198, 201-202 double data type, input, 29 double
> hashing, 544**
>
> HashDouble applet, 545
>
> Java code, 546, 550
>
> **doubly linked lists, 221-222**
>
> deletion, 225-226, 230-231
>
> deques, 231
>
> insertion, 223-225
>
> traversal, 222
>
> **doublyLinked.java, 226, 230-231 duplicate keys**
>
> binary trees, 404
>
> red-black trees, 434
>
> **duplicates**
>
> arrays, 37
>
> deletion, 38-39
>
> insertion, 38
>
> searching, 38
>
> open addressing, 532
>
> priority queues, minimum spanning trees for weighted graphs, 678
>
> separate chaining, 554 versus no duplicates, 39
>
> **E**
>
> **edges, 620**
>
> adding, 622
>
> minimum spanning trees, 643 minimum spanning trees for weighted
>
> graphs, 677
>
> paths, 616
>
> weighted graphs, 670 **efficiency, weighted graphs, 710 equality
> operator (==), 25 equations**
>
> bubble sort, 88
>
> insert sort, 103
>
> logarithms, 63-64
>
> **error handling, stacks, 122 Euler, Leonard, graphs, 618**
>
> **exceptions, array index out of bounds, 331 experiments, 2-3-4 trees,
> 474**
>
> **explicit pointers, 22**
>
> **extended classes, 21**
>
> **external hashing, 571**
>
> **external storage, 496**
>
> B-trees, 500
>
> efficiency, 505-506
>
> insertion, 502-503
>
> one block per node, 501 searching, 501
>
> choosing, 725
>
> B-trees, 726
>
> hashing, 727
>
> indexed files, 726
>
> sequential, 726
>
> virtual memory, 727
>
> external data, 496
>
> one block at a time, 497 slow access, 497

getIterator() method 757

> hashing, 571
>
> full blocks, 572
>
> non-full blocks, 571 table of file pointers, 571
>
> indexing, 506
>
> file in memory, 507 multiple, 508
>
> searching, 507
>
> too large, 508
>
> search criteria, 509
>
> sequential ordering, 499-500 sorting external files, 509
>
> internal arrays, 511-512
>
> internal sort, 510
>
> merging, 510

### F

> **factorial() method, 261**
>
> anagramming, 262
>
> **factorials, 260-262**
>
> **fields, 13**
>
> linked lists, 180
>
> **Fill button, 530**
>
> **Fill key, 587**
>
> **Find button, 531**
>
> **find button, RBTree workshop, 437 find() method, 56-58**
>
> HighArray class, 52
>
> linear probing, 533
>
> links, 196
>
> recursion, 268
>
> Tree class, 377
>
> Tree234 class, 476
>
> **finding**
>
> LinkList workshop applet, 184 links, 193, 196
>
> delete() method, 196
>
> find() method, 196
>
> nodes, 376
>
> efficiency, 378
>
> Java code, 377-378
>
> workshop applet, 376-377
>
> **firstLastList.java, 198**
>
> **flip button, RBTree workshop, 436 floating-points, input, 29**
>
> **folding, hashing and, 566**
>
> **for loops, bubblesort.java, 87 functions**
>
> hash functions, 525
>
> objects, 16
>
> procedural languages, 15

### G

> **garbage collection, 24**
>
> **general-purpose data storage structures, Big O notation, 722**
>
> **general-purpose data structures, 717**
>
> arrays, 720
>
> balanced trees, 721 binary search trees, 720 hash tables, 721
>
> libraries, 719
>
> speed, 718-720
>
> **getAdjUnvisitedVertex() method, 629 getElem() method, LowArrayApp
> class, 48 getInt() method, 28**
>
> **getIterator() method, 232**
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 758 getMin() method
>
> **getMin() method, 700**
>
> **getSuccessor() method, 396**
>
> **Graph class, 622-623**
>
> **GraphDW workshop applet, 694-697**
>
> shortest-path array, 695
>
> **GraphN workshop applet**
>
> DFS, 627
>
> minimum spanning trees, 644
>
> **graphs, 615-616**
>
> adjacency, 616
>
> choosing, 725
>
> connected, 616
>
> critical path analysis, 652 directed, 618
>
> connectivity and, 661-664
>
> edges, adding, 622
>
> Graph class, 622-623
>
> lines, 616
>
> maze analogy, 627
>
> minimum spanning trees, 643 GraphN applet, 644
>
> Java code, 644-645
>
> mst.java, 645
>
> pins, 624
>
> representing in apps, 619 adjacency list, 621
>
> adjacency matrix, 620
>
> edges, 620
>
> vertices, 619
>
> searching, 623
>
> breadth-first search, 636-639
>
> depth-first search, 625-631
>
> sparse, 710
>
> topological sorting, 649-652
>
> cycles/trees, 653
>
> GraphD applet, 652-653
>
> Java code, 654-657
>
> traces, 624
>
> trees, 654
>
> vertices, 616
>
> adding, 622
>
> deleting, 656
>
> weighted, 618
>
> *see also* weighted graphs **GraphW workshop applet, 670-671
> Guess-a-Number game, 54**

### H

> **Hamiltonian cycles, 712**
>
> **hash functions, 525**
>
> computation, 561
>
> folding, 566
>
> hashing strings, 563, 565
>
> non-random keys, 562-563
>
> random keys, 562
>
> **hash tables, 519**
>
> choosing, 721
>
> **hash.java, linear probing, 535, 539-540**
>
> **hashChain.java, 535, 546, 555**
>
> **HashDouble Workshop applet, 542, 545**
>
> **hashFunc() method, 533**
>
> **hashFunc1() method, 564**
>
> **hashFunc2() method, 565**
>
> **hashFunc3() method, 565**
>
> **hashing, 520, 525-526**
>
> choosing, 727
>
> collisions, 527-528
>
> dictionary, 521-524
>
> efficiency, 566
>
> open addressing, 566-568
>
> open addressing versus separate chaining, 570

infix notation 759

> separate chaining, 568
>
> employee numbers (keys), 520, 524
>
> external, 571
>
> external storage, 571-572
>
> open addressing, 528
>
> double hashing, 544-546, 550
>
> linear probing, 528-535, 539-540
>
> quadratic probing, 542
>
> separate chaining, 552
>
> HashChain applet, 552-554
>
> Java code, 555
>
> **heap.java, 588**
>
> array, expanding, 599
>
> array size, 592
>
> insertion, 589-590
>
> key change, 591
>
> listing, 592
>
> removal, 590-591
>
> **heapify() method, 603**
>
> **heaps, 580**
>
> expansion, 599
>
> insertion, 585-586
>
> Java code, 588
>
> array expansion, 599
>
> array size, 592
>
> insertion, 589-590
>
> key change, 591
>
> removal, 590-591
>
> priority queues, 581
>
> removal, 583
>
> swapped, 586-587
>
> tree-based, 600-601
>
> weakly ordered, 582
>
> workshop applet, 587
>
> change, 588
>
> fill, 587
>
> insert, 588
>
> remove, 588
>
> **heapsort**
>
> efficiency, 610
>
> recursion, 603
>
> **heapSort.java, 605, 609**
>
> **HighArray class, 48**
>
> **HighArray.java, 49**
>
> **Hoare, C.A.R., 333**
>
> **Holes, 37**
>
> **Horner's method, 564**
>
> **Huffman code, 415-421**

### I

> **implementation**
>
> 2-3 trees, 494-495
>
> PriorityQ workshop applet, 146 queues, 141-142
>
> red-black trees, 458
>
> **increments, 316**
>
> **incrementSize() method, 609 indexed files, choosing, 726 indexes**
>
> arrays, 40
>
> hash tables, 571
>
> **indexing (external storage), 506** file in memory, 507 multiple, 508
>
> searching, 507
>
> too large, 508
>
> **induction, 260**
>
> **infix notation, 150**
>
> binary trees, 386
>
> translating to postfix, 151-152, 155-156
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 760 infix notation
>
> Java code, 161, 165-167 operators, saving on stack, 158 translation
> rules, 159-160
>
> **infix.java, 161, 173**
>
> **inheritance, 21**
>
> **initialization lists, 41**
>
> **initializing arrays, 41**
>
> **inorder traversal (binary trees), 381 inOrder() method, 382**
>
> **input**
>
> character, 28
>
> floating-point, 29
>
> integers, 28
>
> strings, 27-28
>
> **Ins button, 531**
>
> RBTree workshop, 435
>
> **Ins key, 588 insert() method**
>
> binary searches, 58
>
> binary trees, 379
>
> heaps, 589
>
> HighArray class, 52
>
> linear probing, 534
>
> priority queues, 149
>
> queues, 140
>
> sortedList.java, 215
>
> Tree234 class, 476
>
> **insertAfter() method, 197**
>
> doubly linked lists, 224, 231
>
> **inserting**
>
> 2-3-4 trees, 466
>
> array data, 35
>
> duplicate keys, 38
>
> example (array.java), 43
>
> B-trees, 502-503
>
> doubly linked lists, 223, 225 LinkList workshop applet, 183
>
> nodes, 378
>
> heaps, 585-586
>
> Java code, 379, 381
>
> red-black trees, 445-457
>
> workshop applet, 379 PriorityQ workshop applet, 145 queue workshop
> applet, 134 separate chaining, 570
>
> sequential ordering, 500
>
> Tree234 class, 476
>
> **insertion sort, 95, 218-221**
>
> efficiency, 103
>
> insertSort workshop applet, 97 invariants, 103
>
> Java code, 99
>
> partial, 95
>
> partitions, small, 351
>
> Shellsort, 315
>
> **insertSort program, 733**
>
> **inside grandchild, 443**
>
> rotations, 455
>
> **instantiating, 17**
>
> **int type, data types, 210 integers, input, 28 interfaces**
>
> ADTs, 211
>
> classes, 46-52
>
> **interIterator.java, 235, 241**
>
> **internal arrays, external storage, 511-512 interval sequence, 317**
>
> Shellsort, 324
>
> **intractable problems, algorithms, 710-712 invariants**
>
> bubble sort, 88
>
> insertion sort, 103
>
> selection sort, 95

java interpreter 761

> **iterators, 231**
>
> atEnd() method, 242
>
> classes, methods, 234
>
> interIterator.java, 235, 241
>
> iterator class, 232
>
> methods, 234
>
> operations, 243
>
> references, 232

### J

> **Java code**
>
> 2-3-4 trees, 475
>
> DataItem class, 475
>
> Node class, 475
>
> Tree234 class, 476
>
> tree234.java, 478
>
> Tree234App class, 477
>
> binary trees, 373
>
> Node class, 374
>
> nodes with one child, 392 traversing, 382
>
> Tree class, 375
>
> TreeApp class, 375
>
> brackets.java, 128
>
> breadth-first search, 638 for C++ programmers, 22 depth-first search,
> 629-630
>
> double hashing, 546, 550
>
> heap.java, 588
>
> array expansion, 599
>
> array size, 592
>
> insertion, 589-590
>
> key change, 591
>
> removal, 590-591
>
> infix, converting to postfix, 161, 165-167 input
>
> character, 28
>
> floating-point, 29
>
> integers, 28
>
> strings, 27-28
>
> library data structures, 29 methods, main(), 19
>
> minimum spanning trees, 644-645
>
> minimum spanning trees for weighted graphs, 678-680
>
> new operator, 24 nodes
>
> finding, 377-378
>
> inserting, 379-381
>
> output, 27
>
> overloaded operators, 25
>
> pointers, 22
>
> arguments, 24
>
> assignment, 23
>
> equality/identity, 25
>
> new operator, 24
>
> references, 22-23
>
> postfix expressions, evaluating, 168 primitive variable types, 25
>
> priority queue, 147-149
>
> queue, 137
>
> separate chaining, 555
>
> Shellsort, 321-323
>
> shortest-path problem, 698
>
> getMin() method, 700
>
> path() method, 698-700 sPath array/DistPar class, 698
>
> sorted lists, 213-215
>
> stacks, 120
>
> topological sorting, 654-657
>
> **java interpreter, 732**
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 762 key values

### K

> **key values, sorted lists, 212 keys, 14**
>
> binary trees, 369
>
> double hashing, 545
>
> hash functions, random keys, 562 hashing, 520, 524
>
> heap.java, 591
>
> **keywords**
>
> private, 20
>
> public, 20
>
> **Knapsack problem, recursion, 305-306 Knuth, interval sequence, 318**

### L

> **Last-In-First-Out (LIFO), 118 leaf (binary trees), 369 leafs**
>
> 2-3-4 trees, 464
>
> records, B-tree, 506
>
> **levels (binary trees), 369 lexicographical comparisons, 107**
>
> **libraries, general-purpose data structures, 719 library data
> structures, 29**
>
> **linear probing, 528**
>
> clustering, 533
>
> duplicates, 532
>
> Hash workshop applet, 528-532 hashing efficiency, 567
>
> Java code
>
> array expansion, 540
>
> delete() method, 534
>
> find() method, 533
>
> hash.java, 535, 539-540
>
> insert() method, 534
>
> **linear searches, 53**
>
> Big O notation, 70
>
> **lines, 367**
>
> graphs, 616
>
> **Link class, doubly linked lists, 222 linked lists**
>
> adjacency lists (graphs), 621
>
> binary trees, 366
>
> choosing, 720
>
> double-ended, 198, 201-202
>
> doubly, 221-222
>
> deletion, 225-226, 230-231
>
> deques, 231
>
> insertion, 223-225
>
> traversal, 222
>
> efficiency, 202
>
> iterators, 231
>
> atEnd() method, 242
>
> interIterator.java, 235, 241
>
> iterator class, 232
>
> methods, 234
>
> operations, 243
>
> references, 232
>
> LinkList class, 203
>
> LinkList workshop applet, 183 deleting, 184
>
> find, 184
>
> inserting, 183
>
> **linkList2.java, 193**
>
> **links, 179**
>
> basic types, 180-181
>
> finding/deleting, 193, 196
>
> delete() method, 196
>
> find() method, 196

main() method 763

> references, 180-181
>
> separate chaining, 552
>
> versus arrays, 182
>
> **listings**
>
> anagram.java, 265
>
> array.java, 41
>
> binarySearch.java, 269
>
> brackets.java, 128
>
> doublyLinked.java, 226
>
> firstLastList.java, 198
>
> hashChain.java, 535, 546, 555
>
> heap.java, 592
>
> heapSort.java, 605
>
> highArray.java, 49
>
> infix.java, 161, 173
>
> interIterator.java, 235
>
> linkList1.java, 190
>
> linkList2.java, 193
>
> listInsertionSort.java, 218
>
> lowArray.java, 44
>
> merge.java, 281
>
> mergeSort.java, 288
>
> orderedArray.java, 59, 66
>
> partition.java, 327
>
> path.java, 703
>
> postfix.java, 168
>
> priorityQ.java, 147
>
> queue.java, 138
>
> quickSort1.java, 337
>
> quickSort2.java, 347
>
> quickSort3.java, 351
>
> reverse.java, 124
>
> shellSort.java, 321
>
> sortedList.java, 215
>
> stackTriangle.java, 295
>
> stackTriangle2.java, 301
>
> towers.java, 278
>
> tree.java, 406
>
> tree234.java, 478
>
> triangle.java, 255
>
> **listInsertionSort.java, 218**
>
> **ListIterator class, 234 lists**
>
> ADTs, 211
>
> sorted, 212
>
> efficiency, 218
>
> insertion sort, 218-221
>
> Java code, 213-215
>
> LinkList workshop applet, 213 sortedList.java, 215-217
>
> **load factors, 553**
>
> **logarithms, 62**
>
> equation, 63-64
>
> inverse equation, 64
>
> Shellsort, 325
>
> **loops**
>
> bfs() method (Graph class), 638 recursion, 268-269, 272 triangular
> number nth term, 252
>
> **lowArray class, 46**
>
> **lowArray.java, 44**
>
> **lowArrayApp class, 46**

### M

> **main() method, 19**
>
> anagram.java, 265
>
> array.java, 43
>
> BracketsApp class, 131
>
> classDataArray.java, 66
>
> InfixApp class, 165
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 764 main() method
>
> linkList.java, 193
>
> LinkStack class, 206
>
> LowArray class, 48
>
> LowArrayApp class, 47
>
> PostfixApp class, 172
>
> Stack.java, 120
>
> **manualSort() method, 350 mathematical induction (recursion), 259
> maze analogy, 627**
>
> **median, quicksort pivot value, 344 median-of-three partitioning,
> 345**
>
> **medianOf3() method, 346 memory**
>
> blocks, 497-498
>
> index files, 507
>
> swaps, selection sort, 89
>
> **merge() method, 282**
>
> **merge.java, 281**
>
> **mergesort, 279**
>
> comparisons, 292
>
> copies, 291
>
> efficiency, 291-294
>
> external files, 509
>
> mergeSort.java, 287-291
>
> sorted arrays, 280-282 sorting by merging, 283-284 workshop applet,
> 285-287
>
> **mergeSort() method, 283**
>
> **mergeSort.java, 287-291 merging, external storage, 510 methods**
>
> accessing, 17
>
> addEdge(), 656
>
> adjust\_sPath(), 701
>
> atEnd(), 242
>
> BankAccount class, 20
>
> bubbleSort(), 87
>
> change(), 591
>
> charAt(), 28
>
> compareTo(), 107 delete()
>
> HighArray class, 52
>
> linear probing, 534
>
> links, 196
>
> deques, 143
>
> dfs(), 629
>
> display(), HighArray class, 52 displayForward(), 222
>
> displayList, iterators, 243
>
> displayNode(), 374
>
> displayPerson(), 65
>
> displayStack(), 165
>
> displayWord(), 267
>
> doAnagram(), 263
>
> doParse(), 172
>
> doTrans(), 165
>
> factorial(), 261 find()
>
> binary searches, 56, 58
>
> HighArray class, 52
>
> linear probing, 533
>
> links, 196
>
> recursion, 268
>
> Tree class, 377
>
> getAdjUnvisitedVertex(), 629 getElem(), LowArrayApp class, 48
> getInt(), 28
>
> getIterator(), 232
>
> getMin(), 700
>
> getSuccessor(), 396
>
> hashFunc(), 533
>
> hashFunc1(), 564
>
> minimum spanning trees 765
>
> hashFunc2(), 565
>
> hashFunc3(), 565
>
> heapify(), 603
>
> incrementSize(), 609
>
> inOrder(), 382 insert()
>
> heaps, 589
>
> HighArray class, 52
>
> linear probing, 534
>
> priority queues, 149
>
> queues, 140
>
> insertAfter(), 197
>
> doubly linked lists, 224, 231
>
> iterator, 234
>
> iterator class, 234
>
> main(), 19
>
> InfixApp class, 165
>
> linkList.java, 193
>
> LinkStack, 206
>
> LowArrayApp class, 47-48
>
> PostfixApp class, 172
>
> Stack.java, 120
>
> manualSort(), 350
>
> medianOf3(), 346
>
> merge(), 282
>
> mergeSort, 283
>
> mst(), 644
>
> mstw(), 678
>
> noSuccessors(), 655
>
> parseInt(), 28
>
> partitionIn(), pivot values, 335 partitionIt(), 327, 339
>
> path(), 698-700
>
> peek()
>
> queue workshop applet, 135 queues, 140
>
> StackX class, 122 pop(), StackX class, 122 preorder(), 386
>
> PriorityQ class, 146
>
> priorityQueue class, 582 push(), StackX class, 122 putInPQ(), 680
>
> quickSort(), 339
>
> readString(), 165
>
> recFind(), 272
>
> recMergeSort(), 287
>
> recQuickSort(), 334
>
> recursion, 259
>
> simulating, 294-300 remove()
>
> priority queues, 149
>
> queues, 140
>
> rotate(), 267
>
> selectSort(), 92
>
> shellSort(), 321
>
> size(), 58
>
> split( ), 495
>
> StackX class, 122
>
> sumAllColumns(), 254
>
> sumRemainingColumns(), 254
>
> swap(), 87
>
> topo(), 654
>
> triangle(), 253
>
> trickleDown(), 590
>
> trickleUp(), 589
>
> **minimum spanning trees, 643**
>
> GraphN applet, 644
>
> Java code, 644-645
>
> mst.java, 645
>
> weighted graphs, 669
>
> algorithm, 676
>
> GraphW applet, 670-671
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 766 minimum spanning trees
>
> Java code, 678-680
>
> mstw.java, 681
>
> **modulo operator (%), hashing, 525 Moore's Law, 719**
>
> **mst() method, 644**
>
> **mst.java, 645**
>
> **mstw() method, 678**
>
> **mstw.java, 681**

### N

> **n-sorting, 316-317**
>
> **navigating 2-3-4 trees, 473**
>
> **New button, 529 new operator**
>
> arrays, 40
>
> Java, 24
>
> vertices, adding to graphs, 622
>
> **Node class, 374, 475**
>
> heap.java, 592
>
> **node splits, 2-3 trees, 492-494**
>
> **nodes, 366**
>
> 2-3-4 transformation to red-black, 487
>
> 2-3-4 trees, 464
>
> inserting, 467, 475
>
> nodes per, 491
>
> splitting, 467
>
> viewing, 473
>
> binary trees, 370
>
> child, 369
>
> deleting, 389
>
> with no children, 389 with one child, 391-393
>
> with two children, 393-401
>
> finding, 376
>
> efficiency, 378
>
> Java code, 377-378
>
> workshop applet, 376-377 heaps
>
> insertion, 585-586
>
> removal, 583
>
> inserting, 378
>
> Java code, 379-381
>
> workshop applet, 379
>
> key values, 376
>
> leaf, 369
>
> levels, 369
>
> number required, 401
>
> path, 368
>
> parent, 369
>
> red-black trees, 433 clicking a node, 435 deleting, 457
>
> inserting, 445-457
>
> weird crossover, 442
>
> root, 368
>
> color flip, 448 splits

3.  node, 489

4.  node, 488

> B-trees, 503
>
> splitting (2-3-4 trees), 468
>
> subtrees, 369
>
> swapping, heaps, 586-587 two children, deleting, 396 visiting, 369
>
> *see also* red-black trees
>
> **noSuccessors() method, 655**

parentheses () 767

### O

> **objects, 16**
>
> accessing methods, 17
>
> arrays, 40
>
> classes, 16
>
> comp to nodes, 367 creating, 17
>
> sorting, 103
>
> Java code, 104
>
> lexicographical comparisons, 107
>
> stability, 107
>
> storing, 64
>
> classDataArray.java, 65, 69-70
>
> Person class, 65
>
> **OOP (object-oriented programming), 14**
>
> bank.java, 18-20
>
> inheritance, 21
>
> objects, 16-17
>
> polymorphism, 21
>
> procedural languages, 14-15
>
> **open addressing, 528**
>
> double hashing, 544
>
> HashDouble applet, 545
>
> Java code, 546, 550
>
> hashing efficiency, 566-568 linear probe Java code
>
> array expansion, 540
>
> delete() method, 534
>
> find() method, 533
>
> hash.java, 535, 539-540
>
> insert() method, 534
>
> linear probing, 528
>
> clustering, 533
>
> duplicates, 532
>
> Hash workshop applet, 528-532
>
> quadratic probing, 542
>
> HashDouble applet, 542
>
> step, 542
>
> **operators**
>
> assignment (=), 23
>
> dot (.), 17
>
> equality (==), 25
>
> new, 24
>
> arrays, 40
>
> overloaded, 25 saving on stack, 158
>
> **OrdArray class, 58**
>
> **ordered arrays, 52**
>
> advantages, 61
>
> binary search, 54
>
> binary trees, 365
>
> find() method, 56, 58
>
> linear search, 53
>
> OrdArray class, 58
>
> **Ordered Workshop applet, 52**
>
> binary search, Guess-a-Number game, 54 linear search, 53
>
> **OrderedArray.java, 59-61, 66**
>
> **output, 27**
>
> **outside grandchild, rotations, 454 overloading operators, 25**

### P

> **package access, 186**
>
> **Params class, 295**
>
> **parent (binary trees), 369 parent vertices, 695**
>
> **parentheses (), 127**
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 768 parsing arithmetic expressions
>
> **parsing arithmetic expressions, 149**
>
> evaluating postfix, 167-168, 172-173
>
> infix to postfix notation, 151-152, 155-161,
>
> 165, 167
>
> postfix notation, 150
>
> **parseInt() method, 28**
>
> **partition.java, 327**
>
> **partitioning, 325**
>
> partition algorithm, 330-333
>
> partition.java, 327-330
>
> small partitions, 350, 354
>
> workshop applet, 325, 327
>
> **partitionIt() method, 327, 339**
>
> pivot values, 335
>
> **path() method, 698, 700**
>
> **path.java, 703**
>
> **paths (binary trees), 368 peek() method**
>
> queue workshop applet, 135
>
> queues, 140
>
> StackX class, 122
>
> **peeking**
>
> PriorityQ workshop applet, 146 queue workshop applet, 135 stack
> workshop applet, 120
>
> **Person class, 65**
>
> **pins, 624**
>
> **pivot values, quicksort, 335-336, 339-340**
>
> **pointers, Java, 22**
>
> arguments, 24
>
> assignment, 23
>
> equality/identity, 25
>
> new operator, 24
>
> references, 22-23
>
> **polymorphism, 21**
>
> **pop() method, StackX class, 122**
>
> **popping, 118**
>
> parsing arithemetic expressions, 158 stack workshop applet, 119
>
> **postal analogy (stacks), 117-118 postfix notation, 150, 387**
>
> evaluating, 167-168, 172-173
>
> infix, translating to postfix, 151-152, 155-156
>
> Java code, 161, 165-167 operators, saving on stack, 158 translation
> rules, 159-160
>
> **postfix.java, 168**
>
> **PostfixApp class, 172 powers of two, 63**
>
> **preemptive multitasking operating system, pri- ority queues, 143**
>
> **prefix notation, 386**
>
> **preorder() method, 386 previous field, iterators, 233**
>
> **prime numbers, double hashing, 551 primitive types**
>
> ADTs, 210
>
> arrays, 43
>
> **primitive variable types, 25 priority queues, 143-144**
>
> choosing, 723
>
> efficiency, 149
>
> heaps, 581
>
> Java priority queue, 147, 149 minimum spanning trees for weighted
>
> graphs, 676
>
> PriorityQ workshop applet, 144-146 **PriorityQ class, mstw.java, 681
> PriorityQ workshop applet, 144**
>
> delete, 145
>
> implementation, 146
>
> insert, 145
>
> peek/new, 146

readString() method 769

> **priorityQ.java, 147**
>
> **priorityQueue class, methods, 582 private keyword, BankAccount
> class, 20 procedural languages**
>
> modeling, 15
>
> organizational units, 15
>
> problems, 14
>
> **programs**
>
> data storage structures, 11 dividing into classes, 44, 46
>
> **public keyword, BankAccount class, 20 push() method, StackX class,
> 122 pushing, 118**
>
> **putInPQ() method, 680**

### Q

> **quadratic probing, 542**
>
> HashDouble applet, 542
>
> step, 542
>
> **Queue.java, 138**
>
> **queues, 132-133**
>
> breadth-first search, 637
>
> choosing, 723
>
> circular, 136
>
> deques, 143
>
> efficiency, 142
>
> examples, 132
>
> implementing, ADTs, 206, 209-210
>
> Java code, 137, 140
>
> implementation, 141-142
>
> insert() method, 140
>
> peek() method, 140
>
> remove() method, 140
>
> priority queues, 143
>
> workshop applet, 133-135
>
> **quicksort, 333**
>
> algorithm, 333-334
>
> efficiency, 355-357
>
> O(Nsquared) performance, 344-345
>
> partitioning, 325
>
> partition algorithm, 330-333
>
> partition.java, 327-330
>
> workshop applet, 325-327
>
> partitions, small, 350, 354
>
> pivot value, 335-336, 339-340 quickSort1 workshop applet, 340-344
> quickSort2 workshop applet, 350 quickSort2.java, 346, 350
>
> recursion, removing, 354
>
> three partitioning, median, 345-346
>
> **quickSort() method, 339**
>
> **quickSort1.java, 337**
>
> **quickSort2.java, 347**
>
> **quickSort3.java, 351**

### R

> **Radix sort, 357**
>
> algorithm, 358
>
> efficiency, 359
>
> program design, 358
>
> **radix-exchange sort, 358**
>
> **railroad line, 687-688**
>
> **range conversion, 525 ranges, powers of two, 63**
>
> **r/b button, RBTree workshop, 436 RBTree workshop applet, 434-437
> readString() method, 165**
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 770 real-world data
>
> **real-world data, 10**
>
> **recFind() method, 272**
>
> **recMergeSort() method, 287**
>
> **records, 13**
>
> B-trees, 500
>
> hashing, 520
>
> memory blocks, 501
>
> searching, 501
>
> **recQuickSort() method, 334**
>
> **recTriangle() method, stackTriangle.java, 295 recursion**
>
> anagrams, 262-265
>
> applications for, 303-307
>
> binary search, 268
>
> algorithms, 272
>
> loops, 268-269, 272
>
> combinations, 306-307
>
> eliminating, 294
>
> simulating a method, 294-295, 298-300
>
> stacks, 294
>
> factorials, 260, 262
>
> heapsort, 603
>
> inorder traversal (binary trees), 381 Knapsack problem, 305-306
>
> mergesort, 279
>
> efficiency, 291-294
>
> mergeSort.java, 287-291
>
> sorted arrays, 280, 282 sorting by merging, 283-284 workshop applet,
> 285, 287
>
> removing from quicksort, 354 Towers of Hanoi, 273
>
> recursive algorithm, 276
>
> subtrees, 275
>
> Towers workshop applet, 274 towers.java, 277, 279
>
> triangular numbers, 251

efficiency, 259

> mathematical induction, 259

methods, 259

> nth term with loop, 252
>
> nth term with recursion, 253-255 triangle.java, 255-257

**red-black trees, 429**

> 2-3-4 trees, 486
>
> operational equivalence, 488, 490
>
> transforming, 486
>
> balance, 432
>
> colored nodes, 433
>
> duplicate keys, 434
>
> efficiency, 457
>
> experiment 1, 437
>
> experiment 2, 438
>
> experiment 3, 439
>
> experiment 4, 439
>
> implementing, 458 nodes

deleting, 457

> inserting, 445-457
>
> null children, 441
>
> red-black rules, 433
>
> rotations, 441-442

subtrees, 444

> weird crossover node, 442 rules and balanced trees, 440 top-down
> insertion, 430
>
> **references**
>
> algorithms, speed of, 719 Java, 22-23
>
> linked lists, 232
>
> links, 180-181
>
> **Rem button, 588**

Shellsort 771

> **removal, heap.java, 590-591 remove() method**
>
> priority queues, 149
>
> queues, 140
>
> **removing, queue workshop applet, 134 resources, 735-736**
>
> **reverse.java, 124**
>
> **Reverser class, 126**
>
> **rol button, RBTree workshop, 436 root**
>
> color flip, 448
>
> splitting (2-3-4 trees), 468-469
>
> **root (binary trees), 368**
>
> **ror button, RBTree workshop, 436 rotate() method, 267**
>
> **rotating, 262 rotations**
>
> inside grandchild, 455
>
> outside grandchild, 454
>
> red-black trees, 441-442
>
> experiment 2, 438
>
> subtrees, 444
>
> weird crossover node, 442
>
> **rules, red-black, 433**
>
> **runtime errors, array null objects, 41**

### S

> **SDK, 731**
>
> **searching**
>
> 2-3-4 trees, 466
>
> array data, 36
>
> example (array.java), 43 arrays, duplicate keys, 38
>
> B-trees, 501
>
> binary, Guess-a-Number game, 54 external storage, search criteria, 509
> graphs, 623
>
> breadth-first search, 636-639
>
> depth-first search, 625-631
>
> indexing, 507
>
> linear, 53
>
> separate chaining, 569
>
> sequential ordering, 499-500
>
> Tree234 class, 476
>
> **selection sort, 89-90**
>
> efficiency, 95
>
> invariant, 95
>
> Java code, 92, 95
>
> selectSort workshop applet, 90
>
> **selectSort() method, 92**
>
> **separate chaining, 528, 552**
>
> HashChain applet, 552
>
> buckets, 554
>
> deletion, 554
>
> duplicates, 554
>
> load factors, 553
>
> table size, 554
>
> hashing efficiency, 568
>
> Java code, 555
>
> **sequential ordering**
>
> block insertion, 500
>
> external storage, 499-500
>
> searching, 499-500 **Shell, Donald L., 315 Shellsort, 315-316**
>
> diminishing gaps, 317, 319
>
> efficiency, 324
>
> interval sequences, 324
>
> Java code, 321-323
>
> n-sorting, 316-317
>
> workshop applet, 319-321
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 772 shellSort() method
>
> **shellSort() method, 321**
>
> **shellSort.java, 321**
>
> **shortest-path array, minimum distance, 697 shortest-path problem,
> 687-694**
>
> Dijkstra's algorithm, 689
>
> GraphDW applet, 694-697
>
> Java code, 698-699
>
> getMin() method, 700
>
> path() method, 698, 700 sPath array/DistPar class, 698
>
> path.java, 703
>
> railroad line, 687-688
>
> **simple sorts, 108**
>
> **size() method, 58**
>
> **software engineering, 21**
>
> **sorted lists, 212**
>
> efficency, 218
>
> insertion sort, 218, 220-221
>
> Java code, 213, 215
>
> LinkList workshop applet, 213 listInsertionSort.java, 218
>
> sortedList.java, 215, 217
>
> **sortedList.java, 215, 217**
>
> **sorting, 78**
>
> algorithms compared, 725
>
> bubble sort, 79
>
> efficiency, 88-89
>
> invariants, 88
>
> Java code, 85, 87-88
>
> workshop applet, 81-84
>
> choosing, 724
>
> external storage, 509
>
> internal arrays, 511-512
>
> internal sort, 510
>
> merging, 510
>
> insertion sort, 95
>
> efficiency, 103
>
> insertSort workshop applet, 97 invariants, 103
>
> Java code, 99
>
> partial, 95
>
> merging (mergesort), 283-284
>
> objects, 103
>
> Java code, 104
>
> lexicographical comparisons, 107
>
> stability, 107
>
> partitioning, 325
>
> partition algorithm, 330-333
>
> partition.java, 327-330
>
> workshop applet, 325-327
>
> quicksort, 333
>
> algorithm, 333-334
>
> efficiency, 355-357
>
> O(Nsquared) performance, 344-345
>
> partitions, small, 350, 354
>
> pivot value, 335-336, 339-340 quickSort1 workshop applet, 340-344
> quickSort2 workshop applet, 350 quickSort2.java, 346, 350
>
> recursion, removing, 354
>
> three partitioning, median, 345-346 Radix, 357
>
> algorithm, 358
>
> efficiency, 359
>
> program design, 358
>
> selection sort, 89-90
>
> efficiency, 95
>
> invariant, 95
>
> Java code, 92, 95
>
> selectSort workshop applet, 90

successors 773

> Shellsort, 315-316
>
> diminishing gaps, 317, 319
>
> efficiency, 324
>
> interval sequences, 324
>
> Java code, 321-323
>
> n-sorting, 316-317
>
> workshop applet, 319-321
>
> simple sorts, 108 **source code, editing, 733 sPath array, 698**
>
> **special-purpose data structures, 722**
>
> Big O notation, 724 priority queues, 723
>
> queues, 723
>
> stacks, 723
>
> **split( ) method, 495**
>
> Tree234 class, 476
>
> **stack workshop applet, 118**
>
> new, 119
>
> peek, 120
>
> pop, 119
>
> push, 119
>
> size, 120
>
> **stacks, 116**
>
> choosing, 723
>
> efficiency, 132 examples
>
> delimiter matching, 127-128, 131-132 reversing a word, 124-126
>
> implementing, ADTs, 203, 206
>
> Java code, 120, 122
>
> error handling, 122 StackX class methods, 122
>
> postal analogy, 117-118
>
> recursion, 294
>
> saving operators to, 158
>
> workshop applet, 118
>
> new, 119
>
> peek, 120
>
> pop, 119
>
> push, 119
>
> size, 120
>
> **stackTriangle.java, 295**
>
> **stackTriangle2.java, 301**
>
> **StackTriangleApp class, 295**
>
> **StackX class, 295**
>
> methods, 122
>
> **storage, 2-3-4 trees, 491 storage structures**
>
> external storage, 725
>
> B-trees, 726
>
> hashing, 727
>
> indexed files, 726
>
> sequential, 726
>
> virtual memory, 727
>
> graphs, 725
>
> sorting, 724
>
> **storing objects, 64**
>
> classDataArray.java, 65, 69-70
>
> Person class, 65 **string object, input, 27 strings**
>
> converting to numbers, 522 hashing, 563, 565
>
> reversing order, 124
>
> **subclassing, 21 subtrees**
>
> binary trees, 369
>
> red-black trees, weird crossover, 444 Towers of Hanoi, 275
>
> **successors**
>
> left descendant, 399
>
> right child, 397
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 774 sumAllColumns() method
>
> **sumAllColumns() method, 254**
>
> **sumRemainingColumns() method, 254**
>
> **superclasses, 21**
>
> **swap() method, 87 swapping**
>
> nodes, heaps, 586-587
>
> selection sort, 89
>
> **symbol tables, 521**

### T

> **text messages, RBTree workshop, 437 throws IOException, 28**
>
> **top node, 438**
>
> **top-down 2-3-4 tree, 467**
>
> **top-down insertion, 430**
>
> **topo() method, 654**
>
> **topo.java, 657**
>
> **topological sorting, 649-652**
>
> (directed graphs), 649
>
> cycles/trees, 653
>
> GraphD applet, 652-653
>
> Java code, 654-656
>
> topo.java, 657
>
> **Towers of Hanoi, 273**
>
> recursive algorithm, 276
>
> subtrees, 275
>
> towers.java, 277-279
>
> workshop applet, 274
>
> **towers.java, 277-279**
>
> **traveling salesman problem, 711 traversal (doubly linked lists), 222
> traversing (binary trees), 369**
>
> **traversing trees, 381**
>
> 3-node, 382
>
> inorder, 381
>
> Java code, 382
>
> preorder/postorder, 385
>
> workshop applet, 384
>
> **Tree class, 375**
>
> **tree-based heaps, 600-601**
>
> **tree.java, 405**
>
> **Tree234 class, 476**
>
> **Tree234 workshop applet, 470-473 tree234.java, 478**
>
> DataItem class, 475
>
> Node class, 475
>
> Tree234 class, 476
>
> Tree234App class, 477
>
> **TreeApp class, 375 trees**
>
> 2-3 trees. *See* 2-3 trees
>
> AVL, 458
>
> balance, 430
>
> graphs, topological sorting, 653
>
> *see also* binary trees
>
> **triangle( ) method, 253, 257**
>
> efficiency, 259
>
> factorials, 260
>
> recursion, simulating, 295
>
> recursive, 258
>
> **triangle.java, 255, 257**
>
> **triangular numbers, 251**
>
> methods, 259 nth term
>
> loops, 252
>
> recursion, 253-255
>
> triangle.java, 255-257

workshop applets 775

> **trickleDown() method, 590**
>
> correct heaps, 602
>
> **trickleUp() method, 589**
>
> **trickling, 583**
>
> swaps and copies, 586

### U-V

> **unbalanced trees, O(N), 431**
>
> **variables**
>
> objects, 16
>
> procedural languages, 15 **vector class, linear probing, 541 vectors,
> choosing, 720**
>
> **Vertex class, 619**
>
> vertex flag, 700
>
> **vertices, 619**
>
> adding, 622
>
> adjacent, 616
>
> deleting, 656
>
> Graph class, 622
>
> parent, 695
>
> shortest-path problem, 687
>
> **vertices, graphs, 616**
>
> **virtual memory, external storage, choosing, 727 visiting (binary
> trees), 369**

### W

> **Warshall's Algorithm, connectivity and, 662 weighted graphs, 618**
>
> all-pairs shortest-path problem, 708-709
>
> efficiency, 710
>
> intractable problems, algorithms, 710-712 minimum spanning trees, 669
>
> algorithm, 676
>
> GraphW applet, 670-671
>
> Java code, 678-680
>
> mstw.java, 681
>
> shortest-path problem, 687-694
>
> Dijkstra's algorithm, 689
>
> GraphDW applet, 694-697
>
> Java code, 698-700
>
> path.java, 703
>
> railroad line, 687-688
>
> **while loop**
>
> delete() method (linked lists), 197 find( ) method binary search, 57
> insert() function, 380
>
> mergesort, 282
>
> partition algorithm, 330
>
> sorted list, 215
>
> Tree class, 378
>
> **workshop applets**
>
> arrays, 33-39
>
> bubble sort, 81-84
>
> GraphD, 652-653
>
> GraphDW, 694-697
>
> GraphN
>
> BFS, 638
>
> DFS, 627
>
> minimum spanning trees, 644 GraphW, 670-671
>
> Hash, 528, 530, 532
>
> HashChain, 552
>
> buckets, 554
>
> deletion, 554
>
> duplicates, 554
>
> load factors, 553
>
> table size, 554
>
> *How can we make this index more useful? Email us at
> <indexes@samspublishing.com>*
>
> 776 workshop applets
>
> HashDouble, 542, 545
>
> Heap, 587
>
> change, 588
>
> fill, 587
>
> insert, 588
>
> remove, 588
>
> insertSort, 97
>
> 10 bars, 97
>
> 100 bars, 97
>
> LinkList, 183
>
> deleting, 184
>
> find, 184
>
> inserting, 183
>
> sorted lists, 213
>
> mergeSort, 285, 287
>
> Ordered applet, 52
>
> binary search, 54
>
> linear search, 53
>
> Partition, 325, 327
>
> PriorityQ, 144
>
> delete, 145
>
> implementation, 146
>
> insert, 145
>
> peek/new, 146
>
> queue, 133
>
> empty/full, 135
>
> insert, 134
>
> new, 135
>
> peek, 135
>
> remove, 134
>
> quickSort1, 340-344
>
> quickSort2, 350
>
> RBTree, 434
>
> clicking nodes, 435
>
> del button, 436
>
> find button, 437
>
> flip button, 436
>
> ins button, 435
>
> r/b button, 436
>
> rol button, 436
>
> ror button, 436
>
> start button, 435
>
> text messages, 437
>
> running, 729
>
> selectSort, 90
>
> Shellsort, 319-321
>
> stack, 118-120
>
> Towers, 274
>
> Tree, 371-372
>
> Tree234, 470-473
>
> **wrapping around, queues, 136**

### X-Y-Z

> **zoom button, 472-473**
