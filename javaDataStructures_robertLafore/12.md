12
==

Heaps
-----

> We saw in Chapter 4, "Stacks and Queues," that a prior- ity queue is a
> data structure that offers convenient access to the data item with the
> smallest (or largest) key.
>
> Priority queues may be used for task scheduling in computers, where
> some programs and activities should be executed sooner than others and
> are therefore given a higher priority.
>
> Another example is in weapons systems, say in a navy cruiser. Numerous
> threats---airplanes, missiles, submarines, and so on---are detected
> and must be prioritized. For example, a missile that's a short
> distance from the cruiser is assigned a higher priority than an
> aircraft a long distance away so that countermeasures (surface-to-air
> missiles, for example) can deal with it first.
>
> Priority queues are also used internally in other computer algorithms.
> In Chapter 14, "Weighted Graphs," we'll see priority queues used in
> graph algorithms, such as Dijkstra's algorithm.
>
> A priority queue is an Abstract Data Type (ADT) offering methods that
> allow removal of the item with the maximum (or minimum) key value,
> insertion, and some- times other operations. As with other ADTs,
> priority queues can be implemented using a variety of underlying
> structures. In Chapter 4 we saw a priority queue imple- mented as an
> ordered array. The trouble with that approach is that, even though
> removal of the largest item is accomplished in fast O(1) time,
> insertion requires slow O(N) time, because an average of half the
> items in the array must be moved to insert the new one in order.

##### IN THIS CHAPTER

-   Introduction to Heaps

-   Java Code for Heaps

-   A Tree-based Heap

-   Heapsort

> 580 **CHAPTER 12** Heaps
>
> In this chapter we'll describe another structure that can be used to
> implement a priority queue: the heap. A heap is a kind of tree. It
> offers both insertion and dele- tion in O(logN) time. Thus, it's not
> quite as fast for deletion, but much faster for insertion. It's the
> method of choice for implementing priority queues where speed is
> important and there will be many insertions.
>
> **[NOTE ]{.underline}**
>
> Don't confuse the term *heap*, used here for a special kind of binary
> tree, with the same term used to mean the portion of computer memory
> available to a programmer with new in languages like Java and C++.

#### Introduction to Heaps

> A heap is a binary tree with these characteristics:

-   It's complete. This means it's completely filled in, reading from
    left to right across each row, although the last row need not be
    full. Figure 12.1 shows complete and incomplete trees.

-   It's (usually) implemented as an array. We described in Chapter 8,
    "Binary Trees," how binary trees can be stored in arrays, rather
    than using references to connect the nodes.

-   Each node in a heap satisfies the *heap condition*, which states
    that every node's key is larger than (or equal to) the keys of its
    children.

![](media/image1.png)![](media/image9.png)

> a\) Complete b) Incomplete
>
> ***FIGURE 12.1*** Complete and incomplete binary trees.
>
> Figure 12.2 shows a heap and its relationship to the array used to
> implement it. The array is what's stored in memory; the heap is only a
> conceptual representation.
>
> Notice that the tree is complete and that the heap condition is
> satisfied for all the nodes.

Introduction to Heaps 581

![](media/image13.png)Heap Array

0

1

Heap

100

90 0

> Root
>
> 80
>
> 2
>
> 3
>
> 4 30

3

> 5
>
> 6
>
> 7
>
> 8
>
> 9
>
> 10
>
> 11
>
> 12
>
> 1 2
>
> 60 50 70
>
> 4 5 6
>
> ***FIGURE 12.2*** A heap and its underlying array.
>
> The fact that a heap is a complete binary tree implies that there are
> no "holes" in the array used to represent it. Every cell is filled,
> from 0 to N-1. (N is 13 in Figure 12.2.)
>
> We'll assume in this chapter that the maximum key (rather than the
> minimum) is in the root. A priority queue based on such a heap is a
> *descending-priority* queue. (We discussed ascending-priority queues
> in Chapter 4.)

##### Priority Queues, Heaps, and ADTs

> We'll be talking about heaps in this chapter, although heaps are
> mostly used to implement priority queues. However, there's a very
> close relationship between a priority queue and the heap used to
> implement it. This relationship is demonstrated in the following
> abbreviated code:
>
> class Heap
>
> {
>
> private Node heapArray\[\];
>
> public void insert(Node nd)
>
> { }
>
> public Node remove()
>
> { }
>
> }
>
> 582 **CHAPTER 12** Heaps
>
> class priorityQueue
>
> {
>
> private Heap theHeap;
>
> public void insert(Node nd)
>
> { theHeap.insert(nd); } public Node remove()
>
> ( return theHeap.remove() }
>
> }
>
> The methods for the priorityQueue class are simply wrapped around the
> methods for the underlying Heap class; they have the same
> functionality. This example makes it conceptually clear that a
> priority queue is an ADT that can be implemented in a variety of ways,
> while a heap is a more fundamental kind of data structure. In this
> chapter, for simplicity, we'll simply show the heap's methods without
> the priority- queue wrapping.

##### Weakly Ordered

> A heap is weakly ordered compared with a binary search tree, in which
> all a node's left descendants have keys less than all its right
> descendants. This implies, as we saw, that in a binary search tree you
> can traverse the nodes in order by following a simple algorithm.
>
> In a heap, traversing the nodes in order is difficult because the
> organizing principle (the heap condition) is not as strong as the
> organizing principle in a tree. All you can say about a heap is that,
> along every path from the root to a leaf, the nodes are arranged in
> descending order. As you can see in Figure 12.2, the nodes to the left
> or right of a given node, or on higher or lower levels---provided
> they're not on the same path---can have keys larger or smaller than
> the node's key. Except where they share the same nodes, paths are
> independent of each other.
>
> Because heaps are weakly ordered, some operations are difficult or
> impossible. Besides its failure to support traversal, a heap also does
> not allow convenient search- ing for a specified key. This is because
> there's not enough information to decide which of a node's two
> children to pick in trying to descend to a lower level during the
> search. It follows that a node with a specified key can't be deleted,
> at least in O(logN) time, because there's no way to find it. (These
> operations can be carried out, by looking at every cell of the array
> in sequence, but this is only possible in slow O(N) time.)
>
> Thus, the organization of a heap may seem dangerously close to
> randomness. Nevertheless, the ordering is just sufficient to allow
> fast removal of the maximum node and fast insertion of new nodes.
> These operations are all that's needed to use a

Introduction to Heaps 583

> heap as a priority queue. We'll discuss briefly how these operations
> are carried out and then see them in action in a Workshop applet.

##### Removal

> Removal means removing the node with the maximum key. This node is
> always the root, so removing it is easy. The root is always at index 0
> of the heap array:
>
> maxNode = heapArray\[0\];
>
> The problem is that once the root is gone, the tree is no longer
> complete; there's an empty cell. This "hole" must be filled in. We
> could shift all the elements in the array down one cell, but there's a
> much faster approach. Here are the steps for removing the maximum
> node:

1.  Remove the root.

2.  Move the last node into the root.

3.  Trickle the last node down until it's below a larger node and above
    a smaller one.

> The *last* node is the rightmost node in the lowest occupied level of
> the tree. This corresponds to the last filled cell in the array. (See
> the node at index 12, with the value 5, in Figure 12.2.) To copy this
> node into the root is straightforward:
>
> heapArray\[0\] = heapArray\[N-1\]; N\--;
>
> The removal of the root decreases the size of the array by one.
>
> To *trickle* (the terms *bubble* or *percolate* are also used) a node
> up or down means to move it along a path step by step, swapping it
> with the node ahead of it, checking at each step to see whether it's
> in its proper position. In step 3 the node at the root is too small
> for that position, so it's trickled down the heap into its proper
> place. We'll see the code for this later.
>
> Step 2 restores the completeness characteristic of the heap (no
> holes), and step 3 restores the heap condition (every node larger than
> its children). The removal process is shown in Figure 12.3.
>
> In part a) of this figure the last node (30) is copied to the root,
> which is removed. In parts b), c), and d), the last node is trickled
> down to its appropriate position, which happens to be on the bottom
> row. (This isn't always the case; the trickle-down process may stop at
> a middle row as well.) Part e) shows the node in its correct position.
>
> ![](media/image20.png)![](media/image27.png)![](media/image35.png){width="0.1926935695538058in"
> height="0.19270778652668416in"}![](media/image36.png)![](media/image38.png){width="0.19268044619422572in"
> height="0.19270778652668416in"}![](media/image39.png){width="0.1926935695538058in"
> height="0.19270778652668416in"}![](media/image40.png)![](media/image39.png){width="0.1926935695538058in"
> height="0.19270778652668416in"}584 **CHAPTER 12** Heaps

![](media/image41.png)![](media/image51.png)

+---------------+------+------+------+---------------+------+------+
| > 63 70       | > 37 |      | > 10 | > 63 Swap 30  | > 37 | > 10 |
+===============+======+======+======+===============+======+======+
| > 43 27 55 34 |      |      |      | > 43 27 55 34 |      |      |
+---------------+------+------+------+---------------+------+------+
| 82            |      |      |      |               |      |      |
+---------------+------+------+------+---------------+------+------+
| > e)          |      | > 51 |      |               |      |      |
| >             |      |      |      |               |      |      |
| > 70          |      |      |      |               |      |      |
+---------------+------+------+------+---------------+------+------+
| > 63 55       | > 37 |      | > 10 |               |      |      |
+---------------+------+------+------+---------------+------+------+
| > 43 27 30 34 |      |      |      |               |      |      |
+---------------+------+------+------+---------------+------+------+

> ![](media/image61.png)***FIGURE 12.3*** Removing the maximum node.
>
> At each position of the target node the trickle-down algorithm checks
> which child is larger. It then swaps the target node with the larger
> child. If it tried to swap with the smaller child, that child would
> become the parent of a larger child, which violates the heap
> condition. Correct and incorrect swaps are shown in Figure 12.4.

![](media/image70.png)

> ***FIGURE 12.4*** Which child to swap?

Introduction to Heaps 585

##### Insertion

> Inserting a node is also easy. Insertion uses trickle up, rather than
> trickle down. Initially, the node to be inserted is placed in the
> first open position at the end of the array, increasing the array size
> by one:
>
> heapArray\[N\] = newNode;
>
> N++;
>
> The problem is that it's likely that this will destroy the heap
> condition. This happens if the new node's key is larger than its newly
> acquired parent. Because this parent is on the bottom of the heap,
> it's likely to be small, so the new node is likely to be larger. Thus,
> the new node will usually need to be trickled upward until it's below
> a node with a larger key and above a node with a smaller key. The
> insertion process is shown in Figure 12.5.

![](media/image79.png)

> ![](media/image91.png)To be Inserted

![](media/image99.png)![](media/image106.png)

> ***FIGURE 12.5*** Inserting a node.
>
> 586 **CHAPTER 12** Heaps
>
> The trickle-up algorithm is somewhat simpler than trickling down
> because two chil- dren don't need to be compared. A node has only one
> parent, and the target node is simply swapped with its parent. In the
> figure the final correct position for the new node happens to be the
> root, but a new node can also end up at an intermediate level.
>
> By comparing Figures 12.4 and 12.5, you can see that if you remove a
> node and then insert the same node the result is not necessarily the
> restoration of the original heap. A given set of nodes can be arranged
> in many valid heaps, depending on the order in which nodes are
> inserted.

##### Not Really Swapped

> In Figures 12.4 and 12.5 we showed nodes being swapped in the
> trickle-down and trickle-up processes. Swapping is conceptually the
> easiest way to understand inser- tion and deletion, and indeed some
> heap implementations actually use swaps. Figure 12.6a shows a
> simplified version of swaps used in the trickle-down process. After
> three swaps, node A will end up in position D, and nodes B, C, and D
> will each move up one level.

2\. Swap

1.  Swap

A

B

2.  Copy

C

3.  Swap

D

4.  Cop

    a.  Swaps b) Copies

> ***FIGURE 12.6*** Trickling with swaps and copies.
>
> However, a swap requires three copies, so the three swaps shown in
> Figure 12.6a take nine copies. We can reduce the total number of
> copies necessary in a trickle algo- rithm by substituting copies for
> swaps.
>
> Figure 12.6b shows how five copies do the work of three swaps. First,
> node A is saved temporarily. Then B is copied over A, C is copied over
> B, and D is copied over C. Finally, A is copied back from temporary
> storage onto position D. We have reduced the number of copies from
> nine to five.
>
> In the figure we're moving node A three levels. The savings in copy
> time grow larger as the number of levels increases because the two
> copies from and to temporary
>
> The Heap Workshop Applet 587
>
> storage account for less of the total. For a large number of levels
> the savings in the number of copies approach a factor of three.
>
> Another way to visualize trickle-up and trickle-down processes being
> carried out with copies is to think of a "hole"---the absence of a
> node---moving down in a trickle up and up in a trickle down. For
> example, in Figure 12.6b, copying A to Temp creates a "hole" at A. The
> "hole" actually consists of the earlier copy of a node that will be
> moved; it's still there but it's irrelevant. Copying B to A moves the
> "hole" from A to B, in the opposite direction from the node. Step by
> step the "hole" trickles down- ward.

#### The Heap Workshop Applet

> The Heap Workshop applet demonstrates the operations we discussed in
> the preced- ing section: It allows you to insert new items into a heap
> and remove the largest item. In addition, you can change the priority
> of a given item.
>
> When you start up the Heap Workshop applet, you'll see a display
> similar to Figure 12.7.

![](media/image117.png){width="2.7927351268591427in"
height="2.2866655730533685in"}

> ***FIGURE 12.7*** The Heap Workshop applet.
>
> There are four buttons: Fill, Chng, Rem, and Ins, for fill, change,
> remove, and insert. Let's see how they work.

##### The Fill Button

> The heap contains 10 nodes when the applet is first started. Using the
> Fill button, you can create a new heap with any number of nodes from 1
> to 31. Press Fill repeatedly, and type in the desired number when
> prompted.
>
> 588 **CHAPTER 12** Heaps

##### The Change Button

> It's possible to change the priority of an existing node. This
> procedure is useful in many situations. For example, in our cruiser
> example, a threat such as an approach- ing airplane may reverse course
> away from the carrier; its priority should be lowered to reflect this
> new development, although the aircraft would remain in the priority
> queue until it was out of radar range.
>
> To change the priority of a node, repeatedly press the Chng button.
> When prompted, click on the node with the mouse. This will position
> the red arrow on the node. Then, when prompted, type in the node's new
> priority.
>
> If the node's priority is raised, it will trickle upward to a new
> position. If the priority is lowered, the node will trickle downward.

##### The Remove Button

> Repeatedly pressing the Rem button causes the node with the highest
> key, located at the root, to be removed. You'll see it disappear, and
> then be replaced by the last (rightmost) node on the bottom row.
> Finally, this node will trickle down until it reaches the position
> that reestablishes the heap order.

##### The Insert Button

> A new node is always inserted initially in the first available array
> cell, just to the right of the last node on the bottom row of the
> heap. From there it trickles up to the appropriate position. Pressing
> the Ins button repeatedly carries out this operation.

#### Java Code for Heaps

> The complete code for heap.java is shown later in this section. Before
> we get to it, we'll focus on the individual operations of insertion,
> removal, and change.
>
> Here are some points to remember from Chapter 8 about representing a
> tree as an array. For a node at index x in the array,

-   Its parent is (x-1) / 2.

-   Its left child is 2\*x + 1.

-   Its right child is 2\*x + 2.

> These relationships can be seen in Figure 12.2.
>
> **[NOTE ]{.underline}**
>
> Remember that the / symbol, when applied to integers, performs integer
> division, in which the answer is rounded to the lowest integer.

Java Code for Heaps 589

##### Insertion

> We place the trickle-up algorithm in its own method. The insert()
> method, which includes a call to this trickleUp() method, is
> straightforward:
>
> public boolean insert(int key)
>
> {
>
> if(currentSize==maxSize) // if array is full, return false; // failure
>
> Node newNode = new Node(key); // make a new node
> heapArray\[currentSize\] = newNode; // put it at the end
> trickleUp(currentSize++); // trickle it up
>
> return true; // success
>
> } // end insert()
>
> We check to make sure the array isn't full and then make a new node
> using the key value passed as an argument. This node is inserted at
> the end of the array. Finally, the trickleUp() routine is called to
> move this node up to its proper position.
>
> In trickleUp() (shown below) the argument is the index of the newly
> inserted item. We find the parent of this position and then save the
> node in a variable called bottom. Inside the while loop, the variable
> index will trickle up the path toward the root, pointing to each node
> in turn. The while loop runs as long as we haven't reached the root
> (index\>0), and the key (iData) of index's parent is less than the new
> node.
>
> The body of the while loop executes one step of the trickle-up
> process. It first copies the parent node into index, moving the node
> down. (This has the effect of moving the "hole" upward.) Then it moves
> index upward by giving it its parent's index, and giving its parent
> *its* parent's index.
>
> public void trickleUp(int index)
>
> {
>
> int parent = (index-1) / 2; Node bottom = heapArray\[index\];
>
> while( index \> 0 &&
>
> heapArray\[parent\].getKey() \< bottom.getKey() )
>
> {
>
> heapArray\[index\] = heapArray\[parent\]; // move node down index =
> parent; // move index up parent = (parent-1) / 2; // parent \<- its
> parent
>
> } // end while heapArray\[index\] = bottom;
>
> } // end trickleUp()
>
> 590 **CHAPTER 12** Heaps
>
> Finally, when the loop has exited, the newly inserted node, which has
> been temporarily stored in bottom, is inserted into the cell pointed
> to by index. This is the first location where it's not larger than its
> parent, so inserting it here satisfies the heap condition.

##### Removal

> The removal algorithm is also not complicated if we subsume the
> trickle-down algo- rithm into its own routine. We save the node from
> the root, copy the last node (at index currentSize-1) into the root,
> and call trickleDown() to place this node in its appropriate location.
>
> public Node remove() // delete item with max key
>
> { // (assumes non-empty list)
>
> Node root = heapArray\[0\]; // save the root
>
> heapArray\[0\] = heapArray\[\--currentSize\]; // root \<- last
> trickleDown(0); // trickle down the root
>
> return root; // return removed node
>
> } // end remove()
>
> This method returns the node that was removed; the user of the heap
> usually needs to process it in some way.
>
> The trickleDown() routine is more complicated than trickleUp() because
> we must determine which of the two children is larger. First, we save
> the node at index in a variable called top. If trickleDown() has been
> called from remove(), index is the root, but, as we'll see, it can be
> called from other routines as well.
>
> The while loop will run as long as index is not on the bottom
> row---that is, as long as it has at least one child. Within the loop
> we check if there is a right child (there may be only a left), and if
> so, compare the children's keys, setting largerChild appropri- ately.
>
> Then we check if the key of the original node (now in top) is greater
> than that of
>
> largerChild; if so, the trickle-down process is complete and we exit
> the loop.
>
> public void trickleDown(int index)
>
> {
>
> int largerChild;
>
> Node top = heapArray\[index\]; // save root while(index \<
> currentSize/2) // while node has at
>
> { // least one child,
>
> int leftChild = 2\*index+1; int rightChild = leftChild+1;
>
> // find larger child

Java Code for Heaps 591

> if( rightChild \< currentSize && // (rightChild exists?)
>
> heapArray\[leftChild\].getKey() \< heapArray\[rightChild\].getKey() )
>
> largerChild = rightChild; else
>
> largerChild = leftChild;
>
> // top \>= largerChild? if(top.getKey() \>=
> heapArray\[largerChild\].getKey())
>
> break;
>
> // shift child up heapArray\[index\] = heapArray\[largerChild\];
>
> index = largerChild; // go down
>
> } // end while
>
> heapArray\[index\] = top; // index \<- root

} // end trickleDown()

> On exiting the loop we need only restore the node stored in top to its
> appropriate position, pointed to by index.

##### Key Change

> After we've created the trickleDown() and trickleUp() methods, we can
> easily imple- ment an algorithm to change the priority (the key) of a
> node and then trickle it up or down to its proper position. The
> change() method accomplishes this:
>
> public boolean change(int index, int newValue)
>
> {
>
> if(index\<0 \|\| index\>=currentSize) return false;
>
> int oldValue = heapArray\[index\].getKey(); // remember old
> heapArray\[index\].setKey(newValue); // change to new
>
> if(oldValue \< newValue) // if raised, trickleUp(index); // trickle it
> up
>
> else // if lowered,
>
> trickleDown(index); // trickle it down return true;
>
> } // end change()
>
> This routine first checks that the index given in the first argument
> is valid, and if so, changes the iData field of the node at that index
> to the value specified as the second argument.
>
> 592 **CHAPTER 12** Heaps
>
> Then, if the priority has been raised, the node is trickled up; if
> it's been lowered, it's trickled down.
>
> Actually, the difficult part of changing a node's priority is not
> shown in this routine: finding the node you want to change. In the
> change() method just shown, we supply the index as an argument, and in
> the Heap Workshop applet, the user simply clicks on the selected node.
> In a real-world application a mechanism would be needed to find the
> appropriate node; as we've seen, the only node to which we normally
> have convenient access in a heap is the one with the largest key.
>
> The problem can be solved in linear O(N) time by searching the array
> sequentially. Or, a separate data structure (perhaps a hash table)
> could be updated with the new index value whenever a node was moved in
> the priority queue. This would allow quick access to any node. Of
> course, keeping a second structure updated would itself be
> time-consuming.

##### The Array Size

> We should note that the array size, equivalent to the number of nodes
> in the heap, is a vital piece of information about the heap's state
> and a critical field in the Heap class. Nodes copied from the last
> position aren't erased, so the only way for algo- rithms to know the
> location of the last occupied cell is to refer to the current size of
> the array.
>
> **The** heap.java **Program**
>
> The heap.java program, shown in Listing 12.1, uses a Node class whose
> only field is the iData variable that serves as the node's key. As
> usual, this class would hold many other fields in a useful program.
> The Heap class contains the methods we discussed, plus isEmpty() and
> displayHeap(), which outputs a crude but comprehensible charac-
> ter-based representation of the heap.
>
> ***LISTING 12.1*** The heap.java Program
>
> // heap.java
>
> // demonstrates heaps
>
> // to run this program: C\>java HeapApp import java.io.\*;
>
> //////////////////////////////////////////////////////////////// class
> Node
>
> {
>
> private int iData; // data item (key)
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Node(int key) // constructor

Java Code for Heaps 593

> ***LISTING 12.1*** Continued
>
> { iData = key; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int getKey()
>
> { return iData; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void setKey(int id)
>
> { iData = id; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Node
>
> //////////////////////////////////////////////////////////////// class
> Heap
>
> {
>
> private Node\[\] heapArray;
>
> private int maxSize; // size of array
>
> private int currentSize; // number of nodes in array
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Heap(int mx) // constructor
>
> {
>
> maxSize = mx; currentSize = 0;
>
> heapArray = new Node\[maxSize\]; // create array
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty()
>
> { return currentSize==0; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean insert(int key)
>
> {
>
> if(currentSize==maxSize) return false;
>
> Node newNode = new Node(key); heapArray\[currentSize\] = newNode;
> trickleUp(currentSize++);
>
> return true;
>
> } // end insert()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void trickleUp(int index)
>
> {
>
> int parent = (index-1) / 2; Node bottom = heapArray\[index\];
>
> 594 **CHAPTER 12** Heaps
>
> ***LISTING 12.1*** Continued
>
> while( index \> 0 &&
>
> heapArray\[parent\].getKey() \< bottom.getKey() )
>
> {
>
> heapArray\[index\] = heapArray\[parent\]; // move it down index =
> parent;
>
> parent = (parent-1) / 2;
>
> } // end while heapArray\[index\] = bottom;
>
> } // end trickleUp()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Node remove() // delete item with max key
>
> { // (assumes non-empty list) Node root = heapArray\[0\];
>
> heapArray\[0\] = heapArray\[\--currentSize\]; trickleDown(0);
>
> return root;
>
> } // end remove()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void trickleDown(int index)
>
> {
>
> int largerChild;
>
> Node top = heapArray\[index\]; // save root while(index \<
> currentSize/2) // while node has at
>
> { // least one child,
>
> int leftChild = 2\*index+1; int rightChild = leftChild+1;
>
> // find larger child if(rightChild \< currentSize && // (rightChild
> exists?)
>
> heapArray\[leftChild\].getKey() \< heapArray\[rightChild\].getKey())
>
> largerChild = rightChild; else
>
> largerChild = leftChild;
>
> // top \>= largerChild? if( top.getKey() \>=
> heapArray\[largerChild\].getKey() )
>
> break;
>
> // shift child up heapArray\[index\] = heapArray\[largerChild\];
>
> index = largerChild; // go down
>
> } // end while
>
> heapArray\[index\] = top; // root to index

Java Code for Heaps 595

> ***LISTING 12.1*** Continued
>
> } // end trickleDown()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean change(int index, int newValue)
>
> {
>
> if(index\<0 \|\| index\>=currentSize) return false;
>
> int oldValue = heapArray\[index\].getKey(); // remember old
> heapArray\[index\].setKey(newValue); // change to new
>
> if(oldValue \< newValue) // if raised, trickleUp(index); // trickle it
> up
>
> else // if lowered,
>
> trickleDown(index); // trickle it down return true;
>
> } // end change()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayHeap()
>
> {
>
> System.out.print("heapArray: "); // array format for(int m=0;
> m\<currentSize; m++)
>
> if(heapArray\[m\] != null)
>
> System.out.print( heapArray\[m\].getKey() + " "); else
>
> System.out.print( "\-- "); System.out.println();
>
> // heap format
>
> int nBlanks = 32; int itemsPerRow = 1; int column = 0;
>
> int j = 0; // current item
>
> String dots = "\...\...\...\...\...\...\...\...\...\....";
>
> System.out.println(dots+dots); // dotted top line
>
> while(currentSize \> 0) // for each heap item
>
> {
>
> if(column == 0) // first item in row? for(int k=0; k\<nBlanks; k++) //
> preceding blanks
>
> System.out.print(' ');
>
> // display item System.out.print(heapArray\[j\].getKey());
>
> 596 **CHAPTER 12** Heaps
>
> ***LISTING 12.1*** Continued
>
> if(++j == currentSize) // done? break;
>
> if(++column==itemsPerRow) // end of row?
>
> {
>
> nBlanks /= 2; // half the blanks
>
> itemsPerRow \*= 2; // twice the items
>
> column = 0; // start over on
>
> System.out.println(); // new row
>
> }
>
> else // next item on row
>
> for(int k=0; k\<nBlanks\*2-2; k++) System.out.print(' '); // interim
> blanks
>
> } // end for
>
> System.out.println("\\n"+dots+dots); // dotted bottom line
>
> } // end displayHeap()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

} // end class Heap

> //////////////////////////////////////////////////////////////// class
> HeapApp
>
> {

public static void main(String\[\] args) throws IOException

> {
>
> int value, value2;
>
> Heap theHeap = new Heap(31); // make a Heap; max size 31 boolean
> success;
>
> theHeap.insert(70); // insert 10 items theHeap.insert(40);
>
> theHeap.insert(50); theHeap.insert(20); theHeap.insert(60);
> theHeap.insert(100); theHeap.insert(80); theHeap.insert(30);
> theHeap.insert(10); theHeap.insert(90);
>
> while(true) // until \[Ctrl\]-\[C\]
>
> {
>
> System.out.print("Enter first letter of ");

Java Code for Heaps 597

> ***LISTING 12.1*** Continued
>
> System.out.print("show, insert, remove, change: "); int choice =
> getChar();
>
> switch(choice)
>
> {
>
> case 's': // show
>
> theHeap.displayHeap(); break;
>
> case 'i': // insert
>
> System.out.print("Enter value to insert: "); value = getInt();
>
> success = theHeap.insert(value); if( !success )
>
> System.out.println("Can't insert; heap full"); break;
>
> case 'r': // remove
>
> if( !theHeap.isEmpty() ) theHeap.remove();
>
> else
>
> System.out.println("Can't remove; heap empty"); break;
>
> case 'c': // change
>
> System.out.print("Enter current index of item: "); value = getInt();
>
> System.out.print("Enter new key: "); value2 = getInt();
>
> success = theHeap.change(value, value2); if( !success )
>
> System.out.println("Invalid index"); break;
>
> default:
>
> System.out.println("Invalid entry\\n");
>
> } // end switch
>
> } // end while
>
> } // end main()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static String getString() throws IOException
>
> {
>
> InputStreamReader isr = new InputStreamReader(System.in);
> BufferedReader br = new BufferedReader(isr);
>
> String s = br.readLine(); return s;
>
> 598 **CHAPTER 12** Heaps
>
> ***LISTING 12.1*** Continued
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static char getChar() throws IOException
>
> {
>
> String s = getString(); return s.charAt(0);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static int getInt() throws IOException
>
> {
>
> String s = getString(); return Integer.parseInt(s);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class HeapApp
>
> ////////////////////////////////////////////////////////////////
>
> The array places the heap's root at index 0. Some heap implementations
> start the array with the root at 1, using position 0 as a sentinel
> value with the largest possible key. This saves an instruction in some
> of the algorithms but complicates things conceptually.
>
> The main() routine in HeapApp creates a heap with a maximum size of 31
> (dictated by the limitations of the display routine) and inserts into
> it 10 nodes with random keys. Then it enters a loop in which the user
> can enter s, i, r, or c, for show, insert, remove, or change.
>
> Here's some sample interaction with the program:
>
> Enter first letter of show, insert, remove, change: s heapArray: 100
> 90 80 30 60 50 70 20 10 40
>
> \...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\.....
>
> 100

90 80

30 60 50 70

> 20 10 40
>
> \...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\.....
>
> Enter first letter of show, insert, remove, change: i Enter value to
> insert: 53
>
> Enter first letter of show, insert, remove, change: s heapArray: 100
> 90 80 30 60 50 70 20 10 40 53
>
> \...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\.....

Java Code for Heaps 599

> 100

90 80

30 60 50 70

> 20 10 40 53
>
> \...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\.....
>
> Enter first letter of show, insert, remove, change: r Enter first
> letter of show, insert, remove, change: s heapArray: 90 60 80 30 53 50
> 70 20 10 40
>
> \...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\.....
>
> 90

60 80

30 53 50 70

> 20 10 40
>
> \...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\.....
>
> Enter first letter of show, insert, remove, change:
>
> The user displays the heap, adds an item with a key of 53, shows the
> heap again, removes the item with the greatest key, and shows the heap
> a third time. The show() routine displays both the array and the tree
> versions of the heap. You'll need to use your imagination to fill in
> the connections between nodes.

##### Expanding the Heap Array

> What happens if, while a program is running, too many items are
> inserted for the size of the heap array? A new array can be created,
> and the data from the old array copied into it. (Unlike the situation
> with hash tables, changing the size of a heap doesn't require
> reordering the data.) The copying operation takes linear time, but
> enlarging the array size shouldn't be necessary very often, especially
> if the array size is increased substantially each time it's expanded
> (by doubling it, for example).
>
> **[TIP ]{.underline}**
>
> In Java, a Vector class object could be used instead of an array;
> vectors can be expanded dynamically.

##### Efficiency of Heap Operations

> For a heap with a substantial number of items, the trickle-up and
> trickle-down algo- rithms are the most time-consuming part of the
> operations we've seen. These algo- rithms spend time in a loop,
> repeatedly moving nodes up or down along a path. The number of copies
> necessary is bounded by the height of the heap; if there are five
> levels, four copies will carry the "hole" from the top to the bottom.
> (We'll ignore the two moves used to transfer the end node to and from
> temporary storage; they're always necessary, so they require constant
> time.)
>
> 600 **CHAPTER 12** Heaps
>
> The trickleUp() method has only one major operation in its loop:
> comparing the key of the new node with the node at the current
> location. The trickleDown() method needs two comparisons: one to find
> the largest child and a second to compare this child with the "last"
> node. They must both copy a node from top to bottom or bottom to top
> to complete the operation.
>
> A heap is a special kind of binary tree, and as we saw in Chapter 8,
> the number of levels L in a binary tree equals log2(N+1), where N is
> the number of nodes. The trickleUp() and trickleDown() routines cycle
> through their loops L-1 times, so the first takes time proportional to
> log2N, and the second somewhat more because of the extra comparison.
> Thus, the heap operations we've talked about here all operate in
> O(logN) time.

#### A Tree-based Heap

> In the figures in this chapter we've shown heaps as if they were trees
> because it's easier to visualize them that way, but the implementation
> has been based on an array. However, it's possible to use an actual
> tree-based implementation. The tree will be a binary tree, but it
> won't be a search tree because, as we've seen, the ordering principle
> is not that strong. It will also be a complete tree, with no missing
> nodes.
>
> Let's call such a tree a *tree heap*.
>
> One problem with tree heaps is finding the last node. You need to find
> this node to remove the maximum item, because it's the last node
> that's inserted in place of the deleted root (and then trickled down).
> You also need to find the first empty node, because that's where you
> insert a new node (and then trickle it up). You can't search for these
> nodes because you don't know their values, and anyway it's not a
> search tree. However, these locations are not hard to find in a
> complete tree if you keep track of the number of nodes in the tree.
>
> As we saw in the discussion of the Huffman tree in Chapter 8, you can
> represent the path from root to leaf as a binary number, with the
> binary digits indicating the path from each parent to its child: 0 for
> left and 1 for right.
>
> It turns out there's a simple relationship between the number of nodes
> in the tree and the binary number that codes the path to the last
> node. Assume the root is numbered 1; the next row has nodes 2 and 3;
> the third row has nodes 4, 5, 6, and 7; and so on. Start with the node
> number you want to find. This will be the last node or the first null
> node. Convert the node number to binary. For example, say there are 29
> nodes in the tree and you want to find the last node. The number 29
> decimal is 11101 binary. Remove the initial 1, leaving 1101. This is
> the path from the root to node 29: right, right, left, right. The
> first available null node is 30, which (after removing the initial 1)
> is 1110 binary: right, right, right, left.
>
> To carry out the calculation, you can repeatedly use the % operator to
> find the remainder (0 or 1) when the node number n is divided by 2 and
> then use the /

Heapsort 601

> operator to actually divide n by 2. When n is less than 1, you're
> done. The sequence of remainders, which you can save in an array or
> string, is the binary number. (The least significant bits correspond
> to the lower end of the path.) Here's how you might calculate it:
>
> while(n \>= 1)
>
> {
>
> path\[j++\] = n % 2; n = n / 2;
>
> }
>
> You could also use a recursive approach in which the remainders are
> calculated each time the function calls itself and the appropriate
> direction is taken each time it returns.
>
> After the appropriate node (or null child) is found, the heap
> operations are fairly straightforward. When trickling up or down, the
> structure of the tree doesn't change, so you don't need to move the
> actual nodes around. You can simply copy the data from one node to the
> next. This way, you don't need to connect and disconnect all the
> children and parents for a simple move. The Node class will need a
> field for the parent node because you'll need to access the parent
> when you trickle up. We'll leave the implementation of the tree heap
> as a programming project.
>
> The tree heap operates in O(logN) time. As in the array-based heap the
> time is mostly spent doing the trickle-up and trickle-down operations,
> which take time proportional to the height of the tree.

#### Heapsort

> The efficiency of the heap data structure lends itself to a
> surprisingly simple and very efficient sorting algorithm called
> *heapsort*.
>
> The basic idea is to insert all the unordered items into a heap using
> the normal insert() routine. Repeated application of the remove()
> routine will then remove the items in sorted order. Here's how that
> might look:
>
> for(j=0; j\<size; j++)
>
> theHeap.insert( anArray\[j\] ); // from unsorted array for(j=0;
> j\<size; j++)
>
> anArray\[j\] = theHeap.remove(); // to sorted array
>
> Because insert() and remove() operate in O(logN) time, and each must
> be applied N times, the entire sort requires O(N\*logN) time, which is
> the same as quicksort.
>
> However, it's not quite as fast as quicksort, partly because there are
> more operations in the inner while loop in trickleDown() than in the
> inner loop in quicksort.
>
> 602 **CHAPTER 12** Heaps
>
> However, several tricks can make heapsort more efficient. The first
> saves time, and the second saves memory.

##### Trickling Down in Place

> If we insert N new items into a heap, we apply the trickleUp() method
> N times. However, all the items can be placed in random locations in
> the array and then rearranged into a heap with only N/2 applications
> of trickleDown(). This offers a small speed advantage.

####### Two Correct Subheaps Make a Correct Heap

> To see how this approach works, you should know that trickleDown()
> will create a correct heap if, when an out-of-order item is placed at
> the root, both the child subheaps of this root are correct heaps. (The
> root can itself be the root of a subheap as well as of the entire
> heap.) This is shown in Figure 12.8.

A

> ***FIGURE 12.8*** Both subheaps must be correct.
>
> If this is a correct heap, and
>
> this is a correct heap, then, if trickleDown ( )
>
> is applied to node A, this will be a
>
> correct heap
>
> This suggests a way to transform an unordered array into a heap. We
> can apply trickleDown() to the nodes on the bottom of the (potential)
> heap---that is, at the end of the array---and work our way upward to
> the root at index 0. At each step the subheaps below us will already
> be correct heaps because we already applied trickleDown() to them.
> After we apply trickleDown() to the root, the unordered array will
> have been transformed into a heap.
>
> Notice, however, that the nodes on the bottom row---those with no
> children---are already correct heaps, because they are trees with only
> one node; they have no rela- tionships to be out of order. Therefore,
> we don't need to apply trickleDown() to these nodes. We can start at
> node N/2-1, the rightmost node with children, instead of N-1, the last
> node. Thus, we need only half as many trickle operations as we would
> using

Heapsort 603

> insert() N times. Figure 12.9 shows the order in which the
> trickle-down algorithm is applied, starting at node 6 in a 15-node
> heap.
>
> ***FIGURE 12.9*** Order of applying trickleDown().
>
> The following code fragment applies trickleDown() to all nodes, except
> those on the bottom row, starting at N/2-1 and working back to the
> root:
>
> for(j=size/2-1; j \>=0; j\--) theHeap.trickleDown(j);

####### A Recursive Approach

> A recursive approach can also be used to form a heap from an array. A
> heapify() method is applied to the root. It calls itself for the
> root's two children, then for each of these children's two children,
> and so on. Eventually, it works its way down to the bottom row, where
> it returns immediately whenever it finds a node with no children.
>
> After it has called itself for two child subtrees, heapify() then
> applies trickleDown() to the root of the subtree. This ensures that
> the subtree is a correct heap. Then heapify() returns and works on the
> subtree one level higher.
>
> heapify(int index) // transform array into heap
>
> {
>
> if(index \> N/2-1) // if node has no children, return; // return
>
> heapify(index\*2+2); // turn right subtree into heap
> heapify(index\*2+1); // turn left subtree into heap
> trickleDown(index); // apply trickle-down to this node
>
> }
>
> This recursive approach is probably not quite as efficient as the
> simple loop.
>
> 604 **CHAPTER 12** Heaps

##### Using the Same Array

> Our initial code fragment showed unordered data in an array. This data
> was then inserted into a heap, and finally removed from the heap and
> written back to the array in sorted order. In this procedure two
> size-N arrays are required: the initial array and the array used by
> the heap.
>
> In fact, the same array can be used both for the heap and for the
> initial array. This cuts in half the amount of memory needed for
> heapsort; no memory beyond the initial array is necessary.
>
> We've already seen how trickleDown() can be applied to half the
> elements of an array to transform them into a heap. We transform the
> unordered array data into a heap in place; only one array is necessary
> for this task. Thus, the first step in heapsort requires only one
> array.
>
> However, the situation becomes more complicated when we apply remove()
> repeat- edly to the heap. Where are we going to put the items that are
> removed?
>
> Each time an item is removed from the heap, an element at the end of
> the heap array becomes empty; the heap shrinks by one. We can put the
> recently removed item in this newly freed cell. As more items are
> removed, the heap array becomes smaller and smaller, while the array
> of ordered data becomes larger and larger. Thus, with a little
> planning, it's possible for the ordered array and the heap array to
> share the same space. This is shown in Figure 12.10.

a)  0 1 2 3 4

> ![](media/image118.png){width="0.214332895888014in"
> height="0.18768044619422572in"}c) 0 1 2 3

+------+--+
| > 50 |  |
+======+==+
| > 30 |  |
+------+--+
| > 40 |  |
+------+--+
| > 10 |  |
+------+--+
| > 20 |  |
+------+--+

Heap

b)  0 1 2 3 4

> d\) 0 20
>
> 1
>
> 2 10
>
> 3
>
> 4 Sorted Array
>
> e)
>
> 4

f)  0 1 2 3 4

> Sorted Array
>
> Sorted Array
>
> ***FIGURE 12.10*** Dual-purpose array.

Heapsort 605

> **The** heapSort.java **Program**
>
> We can put these two tricks---applying trickleDown() without using
> insert(), and using the same array for the initial data and the
> heap---together in a program that performs heapsort. Listing 12.2
> shows the complete heapSort.java program.
>
> ***LISTING 12.2*** The heapSort.java Program
>
> // heapSort.java
>
> // demonstrates heap sort
>
> // to run this program: C\>java HeapSortApp import java.io.\*;
>
> //////////////////////////////////////////////////////////////// class
> Node
>
> {
>
> private int iData; // data item (key)
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Node(int key) // constructor
>
> { iData = key; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int getKey()
>
> { return iData; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Node
>
> //////////////////////////////////////////////////////////////// class
> Heap
>
> {
>
> private Node\[\] heapArray;
>
> private int maxSize; // size of array
>
> private int currentSize; // number of items in array
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Heap(int mx) // constructor
>
> {
>
> maxSize = mx; currentSize = 0;
>
> heapArray = new Node\[maxSize\];
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Node remove() // delete item with max key
>
> { // (assumes non-empty list) Node root = heapArray\[0\];
>
> heapArray\[0\] = heapArray\[\--currentSize\]; trickleDown(0);
>
> 606 **CHAPTER 12** Heaps
>
> ***LISTING 12.2*** Continued
>
> return root;
>
> } // end remove()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void trickleDown(int index)
>
> {
>
> int largerChild;
>
> Node top = heapArray\[index\]; // save root while(index \<
> currentSize/2) // not on bottom row
>
> {
>
> int leftChild = 2\*index+1; int rightChild = leftChild+1;
>
> // find larger child if(rightChild \< currentSize && // right ch
> exists?
>
> heapArray\[leftChild\].getKey() \< heapArray\[rightChild\].getKey())
>
> largerChild = rightChild; else
>
> largerChild = leftChild;
>
> // top \>= largerChild? if(top.getKey() \>=
> heapArray\[largerChild\].getKey())
>
> break;
>
> // shift child up heapArray\[index\] = heapArray\[largerChild\];
>
> index = largerChild; // go down
>
> } // end while
>
> heapArray\[index\] = top; // root to index
>
> } // end trickleDown()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void displayHeap()

> {
>
> int nBlanks = 32; int itemsPerRow = 1; int column = 0;
>
> int j = 0; // current item
>
> String dots = "\...\...\...\...\...\...\...\...\...\....";
>
> System.out.println(dots+dots); // dotted top line
>
> while(currentSize \> 0) // for each heap item
>
> {
>
> if(column == 0) // first item in row? for(int k=0; k\<nBlanks; k++) //
> preceding blanks

Heapsort 607

> ***LISTING 12.2*** Continued
>
> System.out.print(' ');
>
> // display item
>
> System.out.print(heapArray\[j\].getKey());
>
> if(++j == currentSize) // done? break;
>
> if(++column==itemsPerRow) // end of row?
>
> {
>
> nBlanks /= 2; // half the blanks
>
> itemsPerRow \*= 2; // twice the items
>
> column = 0; // start over on
>
> System.out.println(); // new row
>
> }
>
> else // next item on row
>
> for(int k=0; k\<nBlanks\*2-2; k++) System.out.print(' '); // interim
> blanks
>
> } // end for
>
> System.out.println("\\n"+dots+dots); // dotted bottom line
>
> } // end displayHeap()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayArray()
>
> {
>
> for(int j=0; j\<maxSize; j++) System.out.print(heapArray\[j\].getKey()
> + " ");
>
> System.out.println("");
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void insertAt(int index, Node newNode)
>
> { heapArray\[index\] = newNode; }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void incrementSize()
>
> { currentSize++; }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> } // end class Heap
>
> //////////////////////////////////////////////////////////////// class
> HeapSortApp
>
> {
>
> public static void main(String\[\] args) throws IOException
>
> {
>
> int size, j;
>
> 608 **CHAPTER 12** Heaps
>
> ***LISTING 12.2*** Continued
>
> System.out.print("Enter number of items: "); size = getInt();
>
> Heap theHeap = new Heap(size);
>
> for(j=0; j\<size; j++) // fill array with
>
> { // random nodes
>
> int random = (int)(java.lang.Math.random()\*100); Node newNode = new
> Node(random); theHeap.insertAt(j, newNode); theHeap.incrementSize();
>
> }
>
> System.out.print("Random: "); theHeap.displayArray(); // display
> random array
>
> for(j=size/2-1; j\>=0; j\--) // make random array into heap
> theHeap.trickleDown(j);
>
> System.out.print("Heap: "); theHeap.displayArray(); // display heap
> array theHeap.displayHeap(); // display heap
>
> for(j=size-1; j\>=0; j\--) // remove from heap and
>
> { // store at array end Node biggestNode = theHeap.remove();
> theHeap.insertAt(j, biggestNode);
>
> }
>
> System.out.print("Sorted: "); theHeap.displayArray(); // display
> sorted array
>
> } // end main()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static String getString() throws IOException
>
> {
>
> InputStreamReader isr = new InputStreamReader(System.in);
> BufferedReader br = new BufferedReader(isr);
>
> String s = br.readLine(); return s;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static int getInt() throws IOException
>
> {

Heapsort 609

> ***LISTING 12.2*** Continued
>
> String s = getString(); return Integer.parseInt(s);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class HeapSortApp
>
> The Heap class is much the same as in the heap.java program (Listing
> 12.1), except that to save space we've removed the trickleUp() and
> insert() methods, which aren't necessary for heapsort. We've also
> added an insertAt() method, which allows direct insertion into the
> heap's array.
>
> Notice that this addition is not in the spirit of object-oriented
> programming. The Heap class interface is supposed to shield class
> users from the underlying implementa- tion of the heap. The underlying
> array should be invisible, but insertAt() allows direct access to it.
> In this situation we accept the violation of OOP principles because
> the array is so closely tied to the heap architecture.
>
> An incrementSize() method is another addition to the heap class. It
> might seem as though we could combine this with insertAt(), but when
> we're inserting into the array in its role as an ordered array, we
> don't want to increase the heap size, so we keep these functions
> separate.
>
> The main() routine in the HeapSortApp class does the following:

1.  Gets the array size from the user.

2.  Fills the array with random data.

3.  Turns the array into a heap with N/2 applications of trickleDown().

4.  Removes the items from the heap and writes them back at the end of
    the array.

> After each step the array contents are displayed. The user selects the
> array size. Here's some sample output from heapSort.java:
>
> Enter number of items: 10
>
> Random: 81 6 23 38 95 71 72 39 34 53
>
> Heap: 95 81 72 39 53 71 23 38 34 6
>
> \...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\.....
>
> 95

81 72

39 53 71 23

38 34 6

> \...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\...\.....
> Sorted: 6 23 34 38 39 53 71 72 81 95
>
> 610 **CHAPTER 12** Heaps

##### The Efficiency of Heapsort

> As we noted, heapsort runs in O(N\*logN) time. Although it may be
> slightly slower than quicksort, an advantage over quicksort is that it
> is less sensitive to the initial distribution of data. Certain
> arrangements of key values can reduce quicksort to slow O(N2) time,
> whereas heapsort runs in O(N\*logN) time no matter how the data is
> distributed.

#### Summary

-   In an ascending-priority queue the item with the largest key is said
    to have the highest priority. (It's the smallest item in a
    descending queue.)

-   A priority queue is an Abstract Data Type (ADT) that offers methods
    for insertion of data and removal of the largest (or smallest) item.

-   A heap is an efficient implementation of an ADT priority queue.

-   A heap offers removal of the largest item, and insertion, in
    O(N\*logN) time.

-   The largest item is always in the root.

-   Heaps do not support ordered traversal of the data, locating an item
    with a specific key, or deletion.

-   A heap is usually implemented as an array representing a complete
    binary tree. The root is at index 0 and the last item at index N-1.

-   Each node has a key less than its parents and greater than its
    children.

-   An item to be inserted is always placed in the first vacant cell of
    the array and then trickled up to its appropriate position.

-   When an item is removed from the root, it's replaced by the last
    item in the array, which is then trickled down to its appropriate
    position.

-   The trickle-up and trickle-down processes can be thought of as a
    sequence of swaps, but are more efficiently implemented as a
    sequence of copies.

-   The priority of an arbitrary item can be changed. First, its key is
    changed. Then, if the key was increased, the item is trickled up,
    but if the key was decreased, the item is trickled down.

-   A heap can be based on a binary tree (not a search tree) that
    mirrors the heap structure; this is called a treeheap.

-   Algorithms exist to find the last occupied node or the first free
    node in a treeheap.

-   Heapsort is an efficient sorting procedure that requires O(N\*logN)
    time.

Questions 611

-   Conceptually, heapsort consists of making N insertions into a heap,
    followed by N removals.

-   Heapsort can be made to run faster by applying the trickle-down
    algorithm directly to N/2 items in the unsorted array, rather than
    inserting N items.

-   The same array can be used for the initial unordered data, for the
    heap array, and for the final sorted data. Thus, heapsort requires
    no extra memory.

#### Questions

> These questions are intended as a self-test for readers. Answers may
> be found in Appendix C.

1.  What does the term *complete* mean when applied to binary trees?

    a.  All the necessary data has been inserted.

    b.  All the rows are filled with nodes, except possibly the bottom
        one.

    c.  All existing nodes contain data.

    d.  The node arrangement satisfies the heap condition.

2.  What does the term *weakly ordered* mean when applied to heaps?

3.  A node is always removed from the [ ]{.underline} .

4.  To "trickle up" a node in a descending heap means

    e.  to repeatedly exchange it with its parent until it's larger than
        its parent.

    f.  to repeatedly exchange it with its child until it's larger than
        its child.

    g.  to repeatedly exchange it with its child until it's smaller than
        its child.

    h.  to repeatedly exchange it with its parent until it's smaller
        than its parent.

5.  A heap can be represented by an array because a heap

    i.  is complete.

    j.  is weakly ordered.

    k.  is a binary tree.

    l.  satisfies the heap condition.

> 612 **CHAPTER 12** Heaps

6.  The last node in a heap is

    m.  always a left child.

    n.  always a right child.

    o.  always on the bottom row.

    p.  never less than its sibling.

7.  A heap is to a priority queue as a(n) [ ]{.underline} is to a stack.

8.  Insertion into a descending heap involves trickle [ ]{.underline} .

9.  Heapsort involves

    q.  removing data from a heap and then inserting it again.

    r.  inserting data into a heap and then removing it.

    s.  copying data from one heap to another.

    t.  copying data from the array representing a heap to the heap.

10. How many arrays, each big enough to hold all the data, does it take
    to sort a heap?

#### Experiments

> Carrying out these experiments will help to provide insights into the
> topics covered in the chapter. No programming is involved.

1.  Does the order in which data is inserted in a heap affect the
    arrangement of the heap? Use the Heap Workshop applet to find out.

2.  Use the Workshop applet's Ins button to insert 10 items in ascending
    order into an empty heap. If you remove these items with the Rem
    button, will they come off in the reverse order?

3.  Insert some items with equal keys. Then remove them. Can you tell
    from this whether heapsort is stable? The color of the nodes is the
    secondary data item.

#### Programming Projects

> Writing programs to solve the Programming Projects helps to solidify
> your under- standing of the material and demonstrates how the
> chapter's concepts are applied. (As noted in the Introduction,
> qualified instructors may obtain completed solutions to the
> Programming Projects on the publisher's Web site.)

Programming Projects 613

1.  Convert the heap.java program (Listing 12.1) so the heap is an
    ascending, rather than a descending, heap. (That is, the node at the
    root is the smallest rather than the largest.) Make sure all
    operations work correctly.

    In the heap.java program the insert() method inserts a new node in
    the heap and ensures the heap condition is preserved. Write a toss()
    method that places a new node in the heap array without attempting
    to maintain the heap condi- tion. (Perhaps each new item can simply
    be placed at the end of the array.) Then write a restoreHeap()
    method that restores the heap condition through- out the entire
    heap. Using toss() repeatedly followed by a single restoreHeap() is
    more efficient than using insert() repeatedly when a large amount of
    data must be inserted at one time. See the description of heapsort
    for clues. To test your program, insert a few items, toss in some
    more, and then restore the heap.

    Implement the PriorityQ class in the priorityQ.java program (Listing
    4.6) using a heap instead of an array. You should be able to use the
    Heap class in the heap.java program (Listing 12.1) without
    modification. Make it a descending queue (largest item is removed).

    One problem with implementing a priority queue with an array-based
    heap is the fixed size of the array. If your data outgrows the
    array, you'll need to expand the array, as we did for hash tables in
    Programming Project 11.4 in Chapter 11, "Hash Tables." You can avoid
    this problem by implementing a priority queue with an ordinary
    binary search tree rather than a heap. A tree can grow as large as
    it wants (except for system-memory constraints).

> Start with the Tree class from the tree.java program (Listing 8.1).
> Modify this class so it supports priority queues by adding a
> removeMax() method that removes the largest item. In a heap this is
> easy, but in a tree it's slightly harder. How do you find the largest
> item in a tree? Do you need to worry about both its children when you
> delete it? Implementing change() is optional. It's easily handled in a
> binary search tree by deleting the old item and inserting a new one
> with a different key.
>
> The application should relate to a PriorityQ class; the Tree class
> should be invisible to main() (except perhaps for displaying the tree
> while you're debug- ging). Insertion and removeMax() will operate in
> O(logN) time.

5.  Write a program that implements the tree heap (the tree-based
    implementation of the heap) discussed in the text. Make sure you can
    remove the largest item, insert items, and change an item's key.
