5
=

Linked Lists
------------

> In Chapter 2, "Arrays," we saw that arrays had certain disadvantages
> as data storage structures. In an unordered array, searching is slow,
> whereas in an ordered array, inser-
>
> tion is slow. In both kinds of arrays, deletion is slow. Also, the
> size of an array can't be changed after it's created.
>
> In this chapter we'll look at a data storage structure that solves
> some of these problems: the *linked list*. Linked lists are probably
> the second most commonly used general- purpose storage structures
> after arrays.
>
> The linked list is a versatile mechanism suitable for use in many
> kinds of general-purpose databases. It can also replace an array as
> the basis for other storage structures such as stacks and queues. In
> fact, you can use a linked list in many cases in which you use an
> array, unless you need frequent random access to individual items
> using an index.
>
> Linked lists aren't the solution to all data storage problems, but
> they are surprisingly versatile and conceptually simpler than some
> other popular structures such as trees. We'll investigate their
> strengths and weaknesses as we go along.
>
> In this chapter we'll look at simple linked lists, double- ended
> lists, sorted lists, doubly linked lists, and lists with iterators (an
> approach to random access to list elements). We'll also examine the
> idea of Abstract Data Types (ADTs), and see how stacks and queues can
> be viewed as ADTs and how they can be implemented as linked lists
> instead of arrays.

#### Links

> In a linked list, each data item is embedded in a *link*. A link is an
> object of a class called something like Link. Because there are many
> similar links in a list, it makes sense to use a separate class for
> them, distinct from the

##### IN THIS CHAPTER

-   Links

-   A Simple Linked List

-   Finding and Deleting Specified Links

-   Double-Ended Lists

-   Linked-List Efficiency

-   Abstract Data Types

-   Sorted Lists

-   Doubly Linked Lists

-   Iterators

> 180 **CHAPTER 5** Linked Lists
>
> linked list itself. Each Link object contains a reference (usually
> called next) to the next link in the list. A field in the list itself
> contains a reference to the first link. This relationship is shown in
> Figure 5.1.
>
> Linked List

![](media/image1.png)Null

> ***FIGURE 5.1*** Links in a list.
>
> Here's part of the definition of a class Link. It contains some data
> and a reference to the next link:
>
> class Link
>
> {
>
> public int iData; // data public double dData; // data
>
> public Link next; // reference to next link
>
> }
>
> This kind of class definition is sometimes called *self-referential*
> because it contains a field---called next in this case---of the same
> type as itself.
>
> We show only two data items in the link: an int and a double. In a
> typical applica- tion there would be many more. A personnel record,
> for example, might have name, address, Social Security number, title,
> salary, and many other fields. Often an object of a class that
> contains this data is used instead of the items:
>
> class Link
>
> {
>
> public inventoryItem iI; // object holding data public Link next; //
> reference to next link
>
> }

##### References and Basic Types

> You can easily get confused about references in the context of linked
> lists, so let's review how they work.

Links 181

> Being able to put a field of type Link inside the class definition of
> this same type may seem odd. Wouldn't the compiler be confused? How
> can it figure out how big to make a Link object if a link contains a
> link and the compiler doesn't already know how big a Link object is?
>
> The answer is that in Java a Link object doesn't really contain
> another Link object, although it may look like it does. The next field
> of type Link is only a *reference to* another link, not an object.
>
> A reference is a number that *refers to* an object. It's the object's
> address in the computer's memory, but you don't need to know its
> value; you just treat it as a magic number that tells you where the
> object is. In a given computer/operating system, all references, no
> matter what they refer to, are the same size. Thus, it's no problem
> for the compiler to figure out how big this field should be and
> thereby construct an entire Link object.
>
> Note that in Java, primitive types such as int and double are stored
> quite differently than objects. Fields containing primitive types do
> not contain references, but actual numerical values like 7 or 3.14159.
> A variable definition like
>
> double salary = 65000.00;
>
> creates a space in memory and puts the number 65000.00 into this
> space. However, a reference to an object like
>
> Link aLink = someLink;
>
> puts a reference to an object of type Link, called someLink, into
> aLink. The someLink object itself is located elsewhere. It isn't
> moved, or even created, by this statement; it must have been created
> before. To create an object, you must always use new:
>
> Link someLink = new Link();
>
> Even the someLink field doesn't hold an object; it's still just a
> reference. The object is somewhere else in memory, as shown in Figure
> 5.2.
>
> Other languages, such as C++, handle objects quite differently than
> Java. In C++ a field like
>
> Link next;
>
> actually contains an object of type Link. You can't write a
> self-referential class defini- tion in C++ (although you can put a
> pointer to a Link in class Link; a pointer is similar to a reference).
> C++ programmers should keep in mind how Java handles objects; this
> usage may be counter-intuitive.
>
> 182 **CHAPTER 5** Linked Lists
>
> [aLink]{.underline}
>
> [someLink]{.underline}

![](media/image6.png)

> object of type [Link]{.underline}
>
> Memory
>
> ***FIGURE 5.2*** Objects and references in memory.

##### Relationship, Not Position

> Let's examine one of the major ways in which linked lists differ from
> arrays. In an array each item occupies a particular position. This
> position can be directly accessed using an index number. It's like a
> row of houses: You can find a particular house using its address.
>
> In a list the only way to find a particular element is to follow along
> the chain of elements. It's more like human relations. Maybe you ask
> Harry where Bob is. Harry doesn't know, but he thinks Jane might know,
> so you go and ask Jane. Jane saw Bob leave the office with Sally, so
> you call Sally's cell phone. She dropped Bob off at
>
> The LinkList Workshop Applet 183
>
> Peter's office, so...but you get the idea. You can't access a data
> item directly; you must use relationships between the items to locate
> it. You start with the first item, go to the second, then the third,
> until you find what you're looking for.

#### The LinkList Workshop Applet

> The LinkList Workshop applet provides three list operations. You can
> insert a new data item, search for a data item with a specified key,
> and delete a data item with a specified key. These operations are the
> same ones we explored in the Array Workshop applet in Chapter 2;
> they're suitable for a general-purpose database application.
>
> Figure 5.3 shows how the LinkList Workshop applet looks when it's
> started. Initially, there are 13 links on the list.

![](media/image7.png){width="2.7994936570428695in"
height="2.2933333333333334in"}

> ***FIGURE 5.3*** The LinkList Workshop applet.

##### The Insert Button

> If you think 13 is an unlucky number, you can insert a new link. Press
> the Ins button, and you'll be prompted to enter a key value between 0
> and 999. Subsequent presses will generate a link with this data in it,
> as shown in Figure 5.4.
>
> In this version of a linked list, new links are always inserted at the
> beginning of the list. This is the simplest approach, although you can
> also insert links anywhere in the list, as we'll see later.
>
> A final press on Ins will redraw the list so the newly inserted link
> lines up with the other links. This redrawing doesn't represent
> anything happening in the program itself, it just makes the display
> neater.
>
> 184 **CHAPTER 5** Linked Lists

![](media/image8.png){width="2.8125043744531935in" height="2.3in"}

> ***FIGURE 5.4*** A new link being inserted.

##### The Find Button

> The Find button allows you to find a link with a specified key value.
> When prompted, type in the value of an existing link, preferably one
> somewhere in the middle of the list. As you continue to press the
> button, you'll see the red arrow move along the list, looking for the
> link. A message informs you when the arrow finds the link. If you type
> a non-existent key value, the arrow will search all the way to the end
> of the list before reporting that the item can't be found.

##### The Delete Button

> You can also delete a key with a specified value. Type in the value of
> an existing link and repeatedly press Del. Again, the arrow will move
> along the list, looking for the link. When the arrow finds the link,
> it simply removes that link and connects the arrow from the previous
> link straight across to the following link. This is how links are
> removed: The reference to the preceding link is changed to point to
> the follow- ing link.
>
> A final keypress redraws the picture, but again redrawing just
> provides evenly spaced links for aesthetic reasons; the length of the
> arrows doesn't correspond to anything in the program.
>
> **[NOTE ]{.underline}**
>
> The LinkList Workshop applet can create both unsorted and sorted
> lists. Unsorted is the default. We'll show how to use the applet for
> sorted lists when we discuss them later in this chapter.

A Simple Linked List 185

#### A Simple Linked List

> Our first example program, linkList.java, demonstrates a simple linked
> list. The only operations allowed in this version of a list are

-   Inserting an item at the beginning of the list

-   Deleting the item at the beginning of the list

-   Iterating through the list to display its contents

> These operations are fairly easy to carry out, so we'll start with
> them. (As we'll see later, these operations are also all you need to
> use a linked list as the basis for a stack.)
>
> Before we get to the complete linkList.java program, we'll look at
> some important parts of the Link and LinkList classes.
>
> **The** Link **Class**
>
> You've already seen the data part of the Link class. Here's the
> complete class definition:
>
> class Link
>
> {
>
> public int iData; // data item
>
> public double dData; // data item
>
> public Link next; // next link in list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link(int id, double dd) // constructor
>
> {
>
> iData = id; // initialize data
>
> dData = dd; // ('next' is automatically
>
> } // set to null)
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayLink() // display ourself
>
> {
>
> System.out.print("{" + iData + ", " + dData + "} ");
>
> }
>
> } // end class Link
>
> In addition to the data, there's a constructor and a method,
> displayLink(), that displays the link's data in the format {22, 33.9}.
> Object purists would probably object to naming this method
> displayLink(), arguing that it should be simply display(). Using the
> shorter name would be in the spirit of polymorphism, but it makes the
> listing somewhat harder to understand when you see a statement like
>
> 186 **CHAPTER 5** Linked Lists
>
> current.display();
>
> and you've forgotten whether current is a Link object, a LinkList
> object, or something else.
>
> The constructor initializes the data. There's no need to initialize
> the next field because it's automatically set to null when it's
> created. (However, you could set it to null explicitly, for clarity.)
> The null value means it doesn't refer to anything, which is the
> situation until the link is connected to other links.
>
> We've made the storage type of the Link fields (iData and so on)
> public. If they were private, we would need to provide public methods
> to access them, which would require extra code, thus making the
> listing longer and harder to read. Ideally, for security we would
> probably want to restrict Link-object access to methods of the
> LinkList class. However, without an inheritance relationship between
> these classes, that's not very convenient. We could use the default
> access specifier (no keyword) to give the data *package access*
> (access restricted to classes in the same directory), but that has no
> effect in these demo programs, which occupy only one directory anyway.
> The public specifier at least makes it clear that this data isn't
> private. In a more serious program you would probably want to make all
> the data fields in the Link class private.
>
> **The** LinkList **Class**
>
> The LinkList class contains only one data item: a reference to the
> first link on the list. This reference is called first. It's the only
> permanent information the list main- tains about the location of any
> of the links. It finds the other links by following the chain of
> references from first, using each link's next field:
>
> class LinkList
>
> {
>
> private Link first; // ref to first link on list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void LinkList() // constructor
>
> {
>
> first = null; // no items on list yet
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if list is empty
>
> {
>
> return (first==null);
>
> }

A Simple Linked List 187

> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // \... other methods go here
>
> }
>
> The constructor for LinkList sets first to null. This isn't really
> necessary because, as we noted, references are set to null
> automatically when they're created. However, the explicit constructor
> makes it clear that this is how first begins.
>
> When first has the value null, we know there are no items on the list.
> If there were any items, first would contain a reference to the first
> one. The isEmpty() method uses this fact to determine whether the list
> is empty.
>
> **The** insertFirst() **Method**
>
> The insertFirst() method of LinkList inserts a new link at the
> beginning of the list. This is the easiest place to insert a link
> because first already points to the first link. To insert the new
> link, we need only set the next field in the newly created link to
> point to the old first link and then change first so it points to the
> newly created link. This situation is shown in Figure 5.5.

![](media/image9.png)Null

a)  Before Insertion

![](media/image12.png)Null

b)  After Insertion

> ***FIGURE 5.5*** Inserting a new link.
>
> 188 **CHAPTER 5** Linked Lists
>
> In insertFirst() we begin by creating the new link using the data
> passed as arguments. Then we change the link references as we just
> noted:
>
> // insert at start of list public void insertFirst(int id, double dd)
>
> { // make new link
>
> Link newLink = new Link(id, dd);
>
> newLink.next = first; // newLink \--\> old first first = newLink; //
> first \--\> newLink
>
> }
>
> The \--\> arrows in the comments in the last two statements mean that
> a link (or the first field) connects to the next (downstream) link.
> (In doubly linked lists we'll see upstream connections as well,
> symbolized by \<\-- arrows.) Compare these two state- ments with
> Figure 5.5. Make sure you understand how the statements cause the
> links to be changed, as shown in the figure. This kind of reference
> manipulation is the heart of linked-list algorithms.
>
> **The** deleteFirst() **Method**
>
> The deleteFirst() method is the reverse of insertFirst(). It
> disconnects the first link by rerouting first to point to the second
> link. This second link is found by looking at the next field in the
> first link:
>
> public Link deleteFirst() // delete first item
>
> { // (assumes list not empty) Link temp = first; // save reference to
> link first = first.next; // delete it: first\--\>old next return temp;
> // return deleted link
>
> }
>
> The second statement is all you need to remove the first link from the
> list. We choose to also return the link, for the convenience of the
> user of the linked list, so we save it in temp before deleting it and
> return the value of temp. Figure 5.6 shows how first is rerouted to
> delete the object.
>
> In C++ and similar languages, you would need to worry about deleting
> the link itself after it was disconnected from the list. It's in
> memory somewhere, but now nothing refers to it. What will become of
> it? In Java, the garbage collection process will destroy it at some
> point in the future; it's not your responsibility.
>
> Notice that the deleteFirst() method assumes the list is not empty.
> Before calling it, your program should verify this fact with the
> isEmpty() method.

A Simple Linked List 189

![](media/image15.png)Null

a)  Before Deletion

![](media/image18.png)Null

b)  After Deletion

> ***FIGURE 5.6*** Deleting a link.
>
> **The** displayList() **Method**
>
> To display the list, you start at first and follow the chain of
> references from link to link. A variable current points to (or
> technically *refers* to) each link in turn. It starts off pointing to
> first, which holds a reference to the first link. The statement
>
> current = current.next;
>
> changes current to point to the next link because that's what's in the
> next field in each link. Here's the entire displayList() method:
>
> public void displayList()
>
> {
>
> System.out.print("List (first\--\>last): ");
>
> Link current = first; // start at beginning of list while(current !=
> null) // until end of list,
>
> {
>
> current.displayLink(); // print data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");
>
> }
>
> The end of the list is indicated by the next field in the last link
> pointing to null rather than another link. How did this field get to
> be null? It started that way when the link was created and was never
> given any other value because it was always at
>
> 190 **CHAPTER 5** Linked Lists
>
> the end of the list. The while loop uses this condition to terminate
> itself when it reaches the end of the list. Figure 5.7 shows how
> current steps along the list.
>
> ![](media/image20.png)next next next next
>
> Null

a)  Before [current = current.next]{.underline}

> current
>
> ![](media/image23.png)next next next next

Null

b)  After [current = current.nex]{.underline}t

> ***FIGURE 5.7*** Stepping along the list.
>
> current
>
> At each link, the displayList() method calls the displayLink() method
> to display the data in the link.
>
> **The** linkList.java **Program**
>
> Listing 5.1 shows the complete linkList.java program. You've already
> seen all the components except the main() routine.
>
> ***LISTING 5.1*** The linkList.java Program
>
> // linkList.java
>
> // demonstrates linked list
>
> // to run this program: C\>java LinkListApp
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public int iData; // data item (key)
>
> public double dData; // data item
>
> public Link next; // next link in list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

A Simple Linked List 191

> ***LISTING 5.1*** Continued
>
> public Link(int id, double dd) // constructor
>
> {
>
> iData = id; // initialize data
>
> dData = dd; // ('next' is automatically
>
> } // set to null)
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayLink() // display ourself
>
> {
>
> System.out.print("{" + iData + ", " + dData + "} ");
>
> }
>
> } // end class Link
>
> //////////////////////////////////////////////////////////////// class
> LinkList
>
> {
>
> private Link first; // ref to first link on list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public LinkList() // constructor
>
> {
>
> first = null; // no items on list yet
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if list is empty
>
> {
>
> return (first==null);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // insert at start of list public void insertFirst(int id, double dd)
>
> { // make new link
>
> Link newLink = new Link(id, dd);
>
> newLink.next = first; // newLink \--\> old first first = newLink; //
> first \--\> newLink
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link deleteFirst() // delete first item
>
> { // (assumes list not empty) Link temp = first; // save reference to
> link first = first.next; // delete it: first\--\>old next return temp;
> // return deleted link
>
> }
>
> 192 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.1*** Continued
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayList()
>
> {
>
> System.out.print("List (first\--\>last): ");
>
> Link current = first; // start at beginning of list while(current !=
> null) // until end of list,
>
> {
>
> current.displayLink(); // print data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class LinkList
>
> //////////////////////////////////////////////////////////////// class
> LinkListApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> LinkList theList = new LinkList(); // make new list
>
> theList.insertFirst(22, 2.99); // insert four items
> theList.insertFirst(44, 4.99);
>
> theList.insertFirst(66, 6.99);
>
> theList.insertFirst(88, 8.99); theList.displayList(); // display list
>
> while( !theList.isEmpty() ) // until it's empty,
>
> {
>
> Link aLink = theList.deleteFirst(); // delete link
> System.out.print("Deleted "); // display it aLink.displayLink();
>
> System.out.println("");
>
> }
>
> theList.displayList(); // display list
>
> } // end main()
>
> } // end class LinkListApp
>
> ////////////////////////////////////////////////////////////////
>
> Finding and Deleting Specified Links 193
>
> In main() we create a new list, insert four new links into it with
> insertFirst(), and display it. Then, in the while loop, we remove the
> items one by one with deleteFirst() until the list is empty. The empty
> list is then displayed. Here's the output from linkList.java:
>
> List (first\--\>last): {88, 8.99} {66, 6.99} {44, 4.99} {22, 2.99}
>
> Deleted {88, 8.99}
>
> Deleted {66, 6.99}
>
> Deleted {44, 4.99}
>
> Deleted {22, 2.99} List (first\--\>last):

#### Finding and Deleting Specified Links

> Our next example program adds methods to search a linked list for a
> data item with a specified key value and to delete an item with a
> specified key value. These, along with insertion at the start of the
> list, are the same operations carried out by the LinkList Workshop
> applet. The complete linkList2.java program is shown in Listing 5.2.
>
> ***LISTING 5.2*** The linkList2.java Program
>
> // linkList2.java
>
> // demonstrates linked list
>
> // to run this program: C\>java LinkList2App
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public int iData; // data item (key)
>
> public double dData; // data item
>
> public Link next; // next link in list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link(int id, double dd) // constructor
>
> {
>
> iData = id; dData = dd;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayLink() // display ourself
>
> {
>
> System.out.print("{" + iData + ", " + dData + "} ");
>
> }
>
> } // end class Link
>
> 194 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.2*** Continued
>
> //////////////////////////////////////////////////////////////// class
> LinkList
>
> {
>
> private Link first; // ref to first link on list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public LinkList() // constructor
>
> {
>
> first = null; // no links on list yet
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insertFirst(int id, double dd)
>
> { // make new link
>
> Link newLink = new Link(id, dd);
>
> newLink.next = first; // it points to old first link first = newLink;
> // now first points to this
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link find(int key) // find link with given key
>
> { // (assumes non-empty list) Link current = first; // start at
> 'first' while(current.iData != key) // while no match,
>
> {
>
> if(current.next == null) // if end of list, return null; // didn't
> find it
>
> else // not end of list,

current = current.next; // go to next link

> }
>
> return current; // found it
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public Link delete(int key) // delete link with given key

> { // (assumes non-empty list) Link current = first; // search for link
> Link previous = first;
>
> while(current.iData != key)
>
> {
>
> if(current.next == null)
>
> return null; // didn't find it else
>
> {
>
> previous = current; // go to next link
>
> Finding and Deleting Specified Links 195
>
> ***LISTING 5.2*** Continued
>
> current = current.next;
>
> }
>
> } // found it
>
> if(current == first) // if first link,
>
> first = first.next; // change first else // otherwise,
>
> previous.next = current.next; // bypass it return current;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayList() // display the list
>
> {
>
> System.out.print("List (first\--\>last): ");
>
> Link current = first; // start at beginning of list while(current !=
> null) // until end of list,
>
> {
>
> current.displayLink(); // print data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class LinkList
>
> //////////////////////////////////////////////////////////////// class
> LinkList2App
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> LinkList theList = new LinkList(); // make list
>
> theList.insertFirst(22, 2.99); // insert 4 items
>
> theList.insertFirst(44, 4.99);
>
> theList.insertFirst(66, 6.99);
>
> theList.insertFirst(88, 8.99); theList.displayList(); // display list
>
> Link f = theList.find(44); // find item if( f != null)
>
> System.out.println("Found link with key " + f.iData); else
>
> 196 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.2*** Continued
>
> System.out.println("Can't find link");
>
> Link d = theList.delete(66); // delete item if( d != null )
>
> System.out.println("Deleted link with key " + d.iData); else
>
> System.out.println("Can't delete link");
>
> theList.displayList(); // display list
>
> } // end main()
>
> } // end class LinkList2App
>
> ////////////////////////////////////////////////////////////////
>
> The main() routine makes a list, inserts four items, and displays the
> resulting list. It then searches for the item with key 44, deletes the
> item with key 66, and displays the list again. Here's the output:
>
> List (first\--\>last): {88, 8.99} {66, 6.99} {44, 4.99} {22, 2.99}
>
> Found link with key 44 Deleted link with key 66
>
> List (first\--\>last): {88, 8.99} {44, 4.99} {22, 2.99}
>
> **The** find() **Method**
>
> The find() method works much like the displayList() method in the
> linkList.java program. The reference current initially points to first
> and then steps its way along the links by setting itself repeatedly to
> current.next. At each link, find() checks whether that link's key is
> the one it's looking for. If the key is found, it returns with a
> reference to that link. If find() reaches the end of the list without
> finding the desired link, it returns null.
>
> **The** delete() **Method**
>
> The delete() method is similar to find() in the way it searches for
> the link to be deleted. However, it needs to maintain a reference not
> only to the current link (current), but to the link preceding the
> current link (previous). It does so because, if it deletes the current
> link, it must connect the preceding link to the following link, as
> shown in Figure 5.8. The only way to tell where the preceding link is
> located is to maintain a reference to it.
>
> Finding and Deleting Specified Links 197

![](media/image26.png)Null

a)  Before deletion

> ![](media/image29.png)Previous Current

Null

b)  After deletion

> Previous Current
>
> ***FIGURE 5.8*** Deleting a specified link.
>
> At each cycle through the while loop, just before current is set to
> current.next, previous is set to current. This keeps it pointing at
> the link preceding current.
>
> To delete the current link once it's found, the next field of the
> previous link is set to the next link. A special case arises if the
> current link is the first link because the first link is pointed to by
> the LinkList's first field and not by another link. In this case the
> link is deleted by changing first to point to first.next, as we saw in
> the linkList.java program with the deleteFirst() method. Here's the
> code that covers these two possibilities:
>
> // found it
>
> if(current == first) // if first link,
>
> first = first.next; // change first else // otherwise,
>
> previous.next = current.next; // bypass link

##### Other Methods

> We've seen methods to insert and delete items at the start of a list,
> and to find a specified item and delete a specified item. You can
> imagine other useful list methods. For example, an insertAfter()
> method could find a link with a specified key value and insert a new
> link following it. We'll see such a method when we talk about list
> iterators at the end of this chapter.
>
> 198 **CHAPTER 5** Linked Lists

#### Double-Ended Lists

> A double-ended list is similar to an ordinary linked list, but it has
> one additional feature: a reference to the last link as well as to the
> first. Figure 5.9 shows such a list.

Null

> ***FIGURE 5.9*** A double-ended list.
>
> The reference to the last link permits you to insert a new link
> directly at the end of the list as well as at the beginning. Of
> course, you can insert a new link at the end of an ordinary
> single-ended list by iterating through the entire list until you reach
> the end, but this approach is inefficient.
>
> Access to the end of the list as well as the beginning makes the
> double-ended list suitable for certain situations that a single-ended
> list can't handle efficiently. One such situation is implementing a
> queue; we'll see how this technique works in the next section.
>
> Listing 5.3 contains the firstLastList.java program, which
> demonstrates a double- ended list. (Incidentally, don't confuse the
> double-ended list with the doubly linked list, which we'll explore
> later in this chapter.)
>
> ***LISTING 5.3*** The firstLastList.java Program
>
> // firstLastList.java
>
> // demonstrates list with first and last references
>
> // to run this program: C\>java FirstLastApp
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public long dData; // data item
>
> public Link next; // next link in list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link(long d) // constructor
>
> { dData = d; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayLink() // display this link
>
> { System.out.print(dData + " "); }

Double-Ended Lists 199

> ***LISTING 5.3*** Continued
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Link
>
> //////////////////////////////////////////////////////////////// class
> FirstLastList
>
> {
>
> private Link first; // ref to first link
>
> private Link last; // ref to last link
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public FirstLastList() // constructor
>
> {
>
> first = null; // no links on list yet last = null;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if no links
>
> { return first==null; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insertFirst(long dd) // insert at front of list
>
> {
>
> Link newLink = new Link(dd); // make new link
>
> if( isEmpty() ) // if empty list, last = newLink; // newLink \<\--
> last
>
> newLink.next = first; // newLink \--\> old first first = newLink; //
> first \--\> newLink
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insertLast(long dd) // insert at end of list
>
> {
>
> Link newLink = new Link(dd); // make new link if( isEmpty() ) // if
> empty list,
>
> first = newLink; // first \--\> newLink else
>
> last.next = newLink; // old last \--\> newLink last = newLink; //
> newLink \<\-- last
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public long deleteFirst() // delete first link
>
> { // (assumes non-empty list)
>
> long temp = first.dData;
>
> if(first.next == null) // if only one item
>
> 200 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.3*** Continued
>
> last = null; // null \<\-- last first = first.next; // first \--\> old
> next return temp;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayList()
>
> {
>
> System.out.print("List (first\--\>last): ");
>
> Link current = first; // start at beginning while(current != null) //
> until end of list,
>
> {
>
> current.displayLink(); // print data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class FirstLastList
>
> //////////////////////////////////////////////////////////////// class
> FirstLastApp
>
> {
>
> public static void main(String\[\] args)
>
> { // make a new list
>
> FirstLastList theList = new FirstLastList();
>
> theList.insertFirst(22); // insert at front theList.insertFirst(44);
>
> theList.insertFirst(66);
>
> theList.insertLast(11); // insert at rear theList.insertLast(33);
>
> theList.insertLast(55);
>
> theList.displayList(); // display the list
>
> theList.deleteFirst(); // delete first two items
> theList.deleteFirst();
>
> theList.displayList(); // display again
>
> } // end main()
>
> } // end class FirstLastApp
>
> ////////////////////////////////////////////////////////////////

Double-Ended Lists 201

> For simplicity, in this program we've reduced the number of data items
> in each link from two to one. This makes it easier to display the link
> contents. (Remember that in a serious program there would be many more
> data items, or a reference to another object containing many data
> items.)
>
> This program inserts three items at the front of the list, inserts
> three more at the end, and displays the resulting list. It then
> deletes the first two items and displays the list again. Here's the
> output:
>
> List (first\--\>last): 66 44 22 11 33 55
>
> List (first\--\>last): 22 11 33 55
>
> Notice how repeated insertions at the front of the list reverse the
> order of the items, while repeated insertions at the end preserve the
> order.
>
> The double-ended list class is called the FirstLastList. As discussed,
> it has two data items, first and last, which point to the first item
> and the last item in the list. If there is only one item in the list,
> both first and last point to it, and if there are no items, they are
> both null.
>
> The class has a new method, insertLast(), that inserts a new item at
> the end of the list. This process involves modifying last.next to
> point to the new link and then changing last to point to the new link,
> as shown in Figure 5.10.

![](media/image30.png)Null

a)  Before insertion

![](media/image33.png)Null

> ***FIGURE 5.10*** Insertion at the end of a list.
>
> 202 **CHAPTER 5** Linked Lists
>
> The insertion and deletion routines are similar to those in a
> single-ended list. However, both insertion routines must watch out for
> the special case when the list is empty prior to the insertion. That
> is, if isEmpty() is true, then insertFirst() must set last to the new
> link, and insertLast() must set first to the new link.
>
> If inserting at the beginning with insertFirst(), first is set to
> point to the new link, although when inserting at the end with
> insertLast(), last is set to point to the new link. Deleting from the
> start of the list is also a special case if it's the last item on the
> list: last must be set to point to null in this case.
>
> Unfortunately, making a list double-ended doesn't help you to delete
> the last link because there is still no reference to the next-to-last
> link, whose next field would need to be changed to null if the last
> link were deleted. To conveniently delete the last link, you would
> need a doubly linked list, which we'll look at soon. (Of course, you
> could also traverse the entire list to find the last link, but that's
> not very efficient.)

#### Linked-List Efficiency

> Insertion and deletion at the beginning of a linked list are very
> fast. They involve changing only one or two references, which takes
> O(1) time.
>
> Finding, deleting, or inserting next to a specific item requires
> searching through, on the average, half the items in the list. This
> requires O(N) comparisons. An array is also O(N) for these operations,
> but the linked list is nevertheless faster because nothing needs to be
> moved when an item is inserted or deleted. The increased effi- ciency
> can be significant, especially if a copy takes much longer than a
> comparison.
>
> Of course, another important advantage of linked lists over arrays is
> that a linked list uses exactly as much memory as it needs and can
> expand to fill all of available memory. The size of an array is fixed
> when it's created; this usually leads to ineffi- ciency because the
> array is too large, or to running out of room because the array is too
> small. Vectors, which are expandable arrays, may solve this problem to
> some extent, but they usually expand in fixed-sized increments (such
> as doubling the size of the array whenever it's about to overflow).
> This solution is still not as efficient a use of memory as a linked
> list.

#### Abstract Data Types

> In this section we'll shift gears and discuss a topic that's more
> general than linked lists: Abstract Data Types (ADTs). What is an ADT?
> Roughly speaking, it's a way of looking at a data structure: focusing
> on what it does and ignoring how it does
>
> its job.

Abstract Data Types 203

> Stacks and queues are examples of ADTs. We've already seen that both
> stacks and queues can be implemented using arrays. Before we return to
> a discussion of ADTs, let's see how stacks and queues can be
> implemented using linked lists. This discus- sion will demonstrate the
> "abstract" nature of stacks and queues: how they can be considered
> separately from their implementation.

##### A Stack Implemented by a Linked List

> When we created a stack in Chapter 4, "Stacks and Queues," we used an
> ordinary Java array to hold the stack's data. The stack's push() and
> pop() operations were actually carried out by array operations such as
>
> arr\[++top\] = data;
>
> and
>
> data = arr\[top\--\];
>
> which insert data into, and take it out of, an array.
>
> We can also use a linked list to hold a stack's data. In this case the
> push() and pop()
>
> operations would be carried out by operations like
>
> theList.insertFirst(data)
>
> and
>
> data = theList.deleteFirst()
>
> The user of the stack class calls push() and pop() to insert and
> delete items without knowing, or needing to know, whether the stack is
> implemented as an array or as a linked list. Listing 5.4 shows how a
> stack class called LinkStack can be implemented using the LinkList
> class instead of an array. (Object purists would argue that the name
> LinkStack should be simply Stack because users of this class shouldn't
> need to know that it's implemented as a list.)
>
> ***LISTING 5.4*** The linkStack.java Program
>
> // linkStack.java
>
> // demonstrates a stack implemented as a list
>
> // to run this program: C\>java LinkStackApp
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public long dData; // data item
>
> public Link next; // next link in list
>
> 204 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.4*** Continued
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link(long dd) // constructor
>
> { dData = dd; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayLink() // display ourself
>
> { System.out.print(dData + " "); }
>
> } // end class Link
>
> //////////////////////////////////////////////////////////////// class
> LinkList
>
> {
>
> private Link first; // ref to first item on list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public LinkList() // constructor
>
> { first = null; } // no items on list yet
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if list is empty
>
> { return (first==null); }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insertFirst(long dd) // insert at start of list
>
> { // make new link
>
> Link newLink = new Link(dd);
>
> newLink.next = first; // newLink \--\> old first first = newLink; //
> first \--\> newLink
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public long deleteFirst() // delete first item
>
> { // (assumes list not empty) Link temp = first; // save reference to
> link first = first.next; // delete it: first\--\>old next return
> temp.dData; // return deleted link
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayList()
>
> {
>
> Link current = first; // start at beginning of list while(current !=
> null) // until end of list,
>
> {
>
> current.displayLink(); // print data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");

Abstract Data Types 205

> ***LISTING 5.4*** Continued
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class LinkList
>
> //////////////////////////////////////////////////////////////// class
> LinkStack
>
> {
>
> private LinkList theList;
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public LinkStack() // constructor
>
> {
>
> theList = new LinkList();
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void push(long j) // put item on top of stack
>
> {
>
> theList.insertFirst(j);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public long pop() // take item from top of stack
>
> {
>
> return theList.deleteFirst();
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if stack is empty
>
> {
>
> return ( theList.isEmpty() );
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayStack()
>
> {
>
> System.out.print("Stack (top\--\>bottom): "); theList.displayList();
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class LinkStack
>
> //////////////////////////////////////////////////////////////// class
> LinkStackApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> LinkStack theStack = new LinkStack(); // make stack
>
> 206 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.4*** Continued
>
> theStack.push(20); // push items theStack.push(40);
>
> theStack.displayStack(); // display stack
>
> theStack.push(60); // push items theStack.push(80);
>
> theStack.displayStack(); // display stack
>
> theStack.pop(); // pop items theStack.pop();
>
> theStack.displayStack(); // display stack
>
> } // end main()

} // end class LinkStackApp

> ////////////////////////////////////////////////////////////////
>
> The main() routine creates a stack object, pushes two items on it,
> displays the stack, pushes two more items, and displays the stack
> again. Finally, it pops two items and displays the stack a third time.
> Here's the output:
>
> Stack (top\--\>bottom): 40 20
>
> Stack (top\--\>bottom): 80 60 40 20
>
> Stack (top\--\>bottom): 40 20
>
> Notice the overall organization of this program. The main() routine in
> the LinkStackApp class relates only to the LinkStack class. The
> LinkStack class relates only to the LinkList class. There's no
> communication between main() and the LinkList class.
>
> More specifically, when a statement in main() calls the push()
> operation in the LinkStack class, this method in turn calls
> insertFirst() in the LinkList class to actu- ally insert data.
> Similarly, pop() calls deleteFirst() to delete an item, and
> displayStack() calls displayList() to display the stack. To the class
> user, writing code in main(), there is no difference between using the
> list-based LinkStack class and using the array-based stack class from
> the stack.java program (Listing 4.1) in Chapter 4.

##### A Queue Implemented by a Linked List

> Here's a similar example of an ADT implemented with a linked list.
> Listing 5.5 shows a queue implemented as a double-ended linked list.

Abstract Data Types 207

> ***LISTING 5.5*** The linkQueue.java Program
>
> // linkQueue.java
>
> // demonstrates queue implemented as double-ended list
>
> // to run this program: C\>java LinkQueueApp
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public long dData; // data item
>
> public Link next; // next link in list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link(long d) // constructor
>
> { dData = d; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayLink() // display this link
>
> { System.out.print(dData + " "); }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Link
>
> //////////////////////////////////////////////////////////////// class
> FirstLastList
>
> {
>
> private Link first; // ref to first item
>
> private Link last; // ref to last item
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public FirstLastList() // constructor
>
> {
>
> first = null; // no items on list yet last = null;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if no links
>
> { return first==null; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insertLast(long dd) // insert at end of list
>
> {
>
> Link newLink = new Link(dd); // make new link if( isEmpty() ) // if
> empty list,
>
> first = newLink; // first \--\> newLink else
>
> last.next = newLink; // old last \--\> newLink last = newLink; //
> newLink \<\-- last
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> 208 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.5*** Continued
>
> public long deleteFirst() // delete first link
>
> { // (assumes non-empty list)
>
> long temp = first.dData;
>
> if(first.next == null) // if only one item last = null; // null \<\--
> last
>
> first = first.next; // first \--\> old next return temp;
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayList()
>
> {
>
> Link current = first; // start at beginning while(current != null) //
> until end of list,
>
> {
>
> current.displayLink(); // print data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> } // end class FirstLastList
>
> //////////////////////////////////////////////////////////////// class
> LinkQueue
>
> {
>
> private FirstLastList theList;

//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public LinkQueue() // constructor
>
> { theList = new FirstLastList(); } // make a 2-ended list

//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public boolean isEmpty() // true if queue is empty

> { return theList.isEmpty(); }

//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void insert(long j) // insert, rear of queue

> { theList.insertLast(j); }

//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public long remove() // remove, front of queue

> { return theList.deleteFirst(); }

//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayQueue()
>
> {
>
> System.out.print("Queue (front\--\>rear): ");

Abstract Data Types 209

> ***LISTING 5.5*** Continued
>
> theList.displayList();
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class LinkQueue
>
> //////////////////////////////////////////////////////////////// class
> LinkQueueApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> LinkQueue theQueue = new LinkQueue(); theQueue.insert(20); // insert
> items theQueue.insert(40);
>
> theQueue.displayQueue(); // display queue
>
> theQueue.insert(60); // insert items theQueue.insert(80);
>
> theQueue.displayQueue(); // display queue
>
> theQueue.remove(); // remove items theQueue.remove();
>
> theQueue.displayQueue(); // display queue
>
> } // end main()
>
> ////////////////////////////////////////////////////////////////
>
> The program creates a queue, inserts two items, inserts two more
> items, and removes two items; following each of these operations the
> queue is displayed. Here's the output:
>
> Queue (front\--\>rear): 20 40
>
> Queue (front\--\>rear): 20 40 60 80
>
> Queue (front\--\>rear): 60 80
>
> Here the methods insert() and remove() in the LinkQueue class are
> implemented by the insertLast() and deleteFirst() methods of the
> FirstLastList class. We've substi- tuted a linked list for the array
> used to implement the queue in the queue.java program (Listing 4.4) of
> Chapter 4.
>
> The linkStack.java and linkQueue.java programs emphasize that stacks
> and queues are conceptual entities, separate from their
> implementations. A stack can be imple- mented equally well by an array
> or by a linked list. What's important about a stack is
>
> 210 **CHAPTER 5** Linked Lists
>
> the push() and pop() operations and how they're used; it's not the
> underlying mechanism used to implement these operations.
>
> When would you use a linked list as opposed to an array as the
> implementation of a stack or queue? One consideration is how
> accurately you can predict the amount of data the stack or queue will
> need to hold. If this isn't clear, the linked list gives you more
> flexibility than an array. Both are fast, so speed is probably not a
> major consideration.

##### Data Types and Abstraction

> Where does the term *Abstract Data Type* come from? Let's look at the
> *data type* part of it first and then return to *abstract*.

####### Data Types

> The phrase *data type* covers a lot of ground. It was first applied to
> built-in types such as int and double. This is probably what you first
> think of when you hear the term.
>
> When you talk about a primitive type, you're actually referring to two
> things: a data item with certain characteristics and permissible
> operations on that data. For example, type int variables in Java can
> have whole-number values between
>
> --2,147,483,648 and +2,147,483,647, and the operators +, --, \*, /,
> and so on can be applied to them. The data type's permissible
> operations are an inseparable part of its identity; understanding the
> type means understanding what operations can be performed on it.
>
> With the advent of object-oriented programming, you could now create
> your own data types using classes. Some of these data types represent
> numerical quantities that are used in ways similar to primitive types.
> You can, for example, define a class for time (with fields for hours,
> minutes, seconds), a class for fractions (with numerator and
> denominator fields), and a class for extra-long numbers (characters in
> a string represent the digits). All these classes can be added and
> subtracted like int and double, except that in Java you must use
> methods with functional notation like add() and sub() rather than
> operators like + and --.
>
> The phrase *data type* seems to fit naturally with such
> quantity-oriented classes. However, it is also applied to classes that
> don't have this quantitative aspect. In fact, *any* class represents a
> data type, in the sense that a class is made up of data (fields) and
> permissible operations on that data (methods).
>
> By extension, when a data storage structure like a stack or queue is
> represented by a class, it too can be referred to as a data type. A
> stack is different in many ways from an int, but they are both defined
> as a certain arrangement of data and a set of operations on that data.

Abstract Data Types 211

####### Abstraction

> The word *abstract* means "considered apart from detailed
> specifications or implemen- tation." An abstraction is the essence or
> important characteristics of something. The office of president, for
> example, is an abstraction, considered apart from the individ- ual who
> happens to occupy that office. The powers and responsibilities of the
> office remain the same, while individual office-holders come and go.
>
> In object-oriented programming, then, an Abstract Data Type is a class
> considered without regard to its implementation. It's a description of
> the data in the class (fields), a list of operations (methods) that
> can be carried out on that data, and instructions on how to use these
> operations. Specifically excluded are the details of how the methods
> carry out their tasks. As a class user, you're told what methods to
> call, how to call them, and the results you can expect, but not how
> they work.
>
> The meaning of *Abstract Data Type* is further extended when it's
> applied to data structures such as stacks and queues. As with any
> class, it means the data and the operations that can be performed on
> it, but in this context even the fundamentals of how the data is
> stored become invisible to the user. Users not only don't know how the
> methods work, they also don't know what structure is used to store the
> data.
>
> For the stack, the user knows that push() and pop() (and perhaps a few
> other methods) exist and how they work. The user doesn't (at least not
> usually) need to know how push() and pop() work, or whether data is
> stored in an array, a linked list, or some other data structure like a
> tree.

####### The Interface

> An ADT specification is often called an *interface*. It's what the
> class user sees---usually its public methods. In a stack class, push()
> and pop() and similar methods form the interface.

##### ADT Lists

> Now that we know what an Abstract Data Type is, we can mention another
> one: the *list*. A list (sometimes called a linear list) is a group of
> items arranged in a linear order. That is, they're lined up in a
> certain way, like beads on a string or houses on a street. Lists
> support certain fundamental operations. You can insert an item, delete
> an item, and usually read an item from a specified location (the third
> item, say).
>
> Don't confuse the ADT list with the linked list we've been discussing
> in this chapter. A list is defined by its interface: the specific
> methods used to interact with it. This interface can be implemented by
> various structures, including arrays and linked lists. The list is an
> abstraction of such data structures.
>
> 212 **CHAPTER 5** Linked Lists

##### ADTs as a Design Tool

> The ADT concept is a useful aid in the software design process. If you
> need to store data, start by considering the operations that need to
> be performed on that data. Do you need access to the last item
> inserted? The first one? An item with a specified key? An item in a
> certain position? Answering such questions leads to the definition of
> an ADT. Only after the ADT is completely defined should you worry
> about the details of how to represent the data and how to code the
> methods that access the data.
>
> By decoupling the specification of the ADT from the implementation
> details, you can simplify the design process. You also make it easier
> to change the implementa- tion at some future time. If a user relates
> only to the ADT interface, you should be able to change the
> implementation without "breaking" the user's code.
>
> Of course, once the ADT has been designed, the underlying data
> structure must be carefully chosen to make the specified operations as
> efficient as possible. If you need random access to element N, for
> example, the linked-list representation isn't so good because random
> access isn't an efficient operation for a linked list. You'd be better
> off with an array.
>
> **[NOTE ]{.underline}**
>
> Remember that the ADT concept is only a conceptual tool. Data storage
> structures are not divided cleanly into some that are ADTs and some
> that are used to implement ADTs. A linked list, for example, doesn't
> need to be wrapped in a list interface to be useful; it can act as an
> ADT on its own, or it can be used to implement another data type such
> as a queue. A linked list can be implemented using an array, and an
> array-type structure can be implemented using a linked list. What's an
> ADT and what's a more basic structure must be determined in a given
> context.

#### Sorted Lists

> In the linked lists we've seen thus far, there was no requirement that
> data be stored in order. However, for certain applications it's useful
> to maintain the data in sorted order within the list. A list with this
> characteristic is called a *sorted list*.
>
> In a sorted list, the items are arranged in sorted order by key value.
> Deletion is often limited to the smallest (or the largest) item in the
> list, which is at the start of the list, although sometimes find() and
> delete() methods, which search through the list for specified links,
> are used as well.
>
> In general you can use a sorted list in most situations in which you
> use a sorted array. The advantages of a sorted list over a sorted
> array are speed of insertion (because elements don't need to be moved)
> and the fact that a list can expand to fill

Sorted Lists 213

> available memory, while an array is limited to a fixed size. However,
> a sorted list is somewhat more difficult to implement than a sorted
> array.
>
> Later we'll look at one application for sorted lists: sorting data. A
> sorted list can also be used to implement a priority queue, although a
> heap (see Chapter 12, "Heaps") is a more common implementation.
>
> The LinkList Workshop applet introduced at the beginning of this
> chapter demon- strates sorted as well as unsorted lists. To see how
> sorted lists work, use the New button to create a new list with about
> 20 links, and when prompted, click on the Sorted button. The result is
> a list with data in sorted order, as shown in Figure 5.11.

![](media/image35.png){width="2.7994936570428695in"
height="2.2933333333333334in"}

> ***FIGURE 5.11*** The LinkList Workshop applet with a sorted list.
>
> Use the Ins button to insert a new item. Type in a value that will
> fall somewhere in the middle of the list. Watch as the algorithm
> traverses the links, looking for the appropriate insertion place. When
> it finds the correct location, it inserts the new link, as shown in
> Figure 5.12.
>
> With the next press of Ins, the list will be redrawn to regularize its
> appearance. You can also find a specified link using the Find button
> and delete a specified link using the Del button.

##### Java Code to Insert an Item in a Sorted List

> To insert an item in a sorted list, the algorithm must first search
> through the list until it finds the appropriate place to put the item:
> this is just before the first item that's larger, as shown in Figure
> 5.12.
>
> 214 **CHAPTER 5** Linked Lists

![](media/image36.png){width="2.793244750656168in"
height="2.2933333333333334in"}

> ***FIGURE 5.12*** A newly inserted link.
>
> When the algorithm finds where to put it, the item can be inserted in
> the usual way by changing next in the new link to point to the next
> link and changing next in the previous link to point to the new link.
> However, we need to consider some special cases: The link might need
> to be inserted at the beginning of the list, or it might need to go at
> the end. Let's look at the code:
>
> public void insert(long key) // insert in order
>
> {
>
> Link newLink = new Link(key); // make new link Link previous = null;
> // start at first Link current = first;
>
> // until end of list, while(current != null && key \> current.dData)
>
> { // or key \> current,
>
> previous = current;
>
> current = current.next; // go to next item
>
> }
>
> if(previous==null) // at beginning of list
>
> first = newLink; // first \--\> newLink else // not at beginning
>
> previous.next = newLink; // old prev \--\> newLink newLink.next =
> current; // newLink \--\> old current
>
> } // end insert()
>
> We need to maintain a previous reference as we move along, so we can
> modify the previous link's next field to point to the new link. After
> creating the new link, we

Sorted Lists 215

> prepare to search for the insertion point by setting current to first
> in the usual way. We also set previous to null; this step is important
> because later we'll use this null value to determine whether we're
> still at the beginning of the list.
>
> The while loop is similar to those we've used before to search for the
> insertion point, but there's an added condition. The loop terminates
> when the key of the link currently being examined (current.dData) is
> no longer smaller than the key of the link being inserted (key); this
> is the most usual case, where a key is inserted some- where in the
> middle of the list.
>
> However, the while loop also terminates if current is null. This
> happens at the end of the list (the next field of the last element is
> null), or if the list is empty to begin with (first is null).
>
> When the while loop terminates, then, we may be at the beginning, the
> middle, or the end of the list, or the list may be empty.
>
> If we're at the beginning, or the list is empty, previous will be
> null; so we set first to the new link. Otherwise, we're in the middle
> of the list, or at the end, and we set previous.next to the new link.
>
> In any case we set the new link's next field to current. If we're at
> the end of the list,
>
> current is null, so the new link's next field is appropriately set to
> this value.
>
> **The** sortedList.java **Program**
>
> The sortedList.java example shown in Listing 5.6 presents a SortedList
> class with insert(), remove(), and displayList() methods. Only the
> insert() routine is different from its counterpart in non-sorted
> lists.
>
> ***LISTING 5.6*** The sortedList.java Program
>
> // sortedList.java
>
> // demonstrates sorted list
>
> // to run this program: C\>java SortedListApp
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public long dData; // data item
>
> public Link next; // next link in list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link(long dd) // constructor
>
> { dData = dd; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayLink() // display this link
>
> { System.out.print(dData + " "); }
>
> 216 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.6*** Continued
>
> } // end class Link
>
> //////////////////////////////////////////////////////////////// class
> SortedList
>
> {
>
> private Link first; // ref to first item on list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public SortedList() // constructor
>
> { first = null; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if no links
>
> { return (first==null); }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insert(long key) // insert, in order
>
> {
>
> Link newLink = new Link(key); // make new link Link previous = null;
> // start at first Link current = first;
>
> // until end of list, while(current != null && key \> current.dData)
>
> { // or key \> current,
>
> previous = current;

current = current.next; // go to next item

> }
>
> if(previous==null) // at beginning of list first = newLink; // first
> \--\> newLink
>
> else // not at beginning
>
> previous.next = newLink; // old prev \--\> newLink newLink.next =
> current; // newLink \--\> old current
>
> } // end insert()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public Link remove() // return & delete first link

> { // (assumes non-empty list)
>
> Link temp = first; // save first
>
> first = first.next; // delete first
>
> return temp; // return value
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayList()
>
> {
>
> System.out.print("List (first\--\>last): ");
>
> Link current = first; // start at beginning of list

Sorted Lists 217

> ***LISTING 5.6*** Continued
>
> while(current != null) // until end of list,
>
> {
>
> current.displayLink(); // print data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");
>
> }
>
> } // end class SortedList
>
> //////////////////////////////////////////////////////////////// class
> SortedListApp
>
> {
>
> public static void main(String\[\] args)
>
> { // create new list
>
> SortedList theSortedList = new SortedList(); theSortedList.insert(20);
> // insert 2 items theSortedList.insert(40);
>
> theSortedList.displayList(); // display list
>
> theSortedList.insert(10); // insert 3 more items
> theSortedList.insert(30);
>
> theSortedList.insert(50); theSortedList.displayList(); // display list
> theSortedList.remove(); // remove an item
>
> theSortedList.displayList(); // display list
>
> } // end main()
>
> } // end class SortedListApp
>
> ////////////////////////////////////////////////////////////////
>
> In main() we insert two items with key values 20 and 40. Then we
> insert three more items, with values 10, 30, and 50. These values are
> inserted at the beginning of the list, in the middle, and at the end,
> showing that the insert() routine correctly handles these special
> cases. Finally, we remove one item, to show removal is always from the
> front of the list. After each change, the list is displayed. Here's
> the output from sortedList.java:
>
> List (first\--\>last): 20 40
>
> List (first\--\>last): 10 20 30 40 50
>
> List (first\--\>last): 20 30 40 50
>
> 218 **CHAPTER 5** Linked Lists

##### Efficiency of Sorted Linked Lists

> Insertion and deletion of arbitrary items in the sorted linked list
> require O(N) comparisons (N/2 on the average) because the appropriate
> location must be found by stepping through the list. However, the
> minimum value can be found, or deleted, in O(1) time because it's at
> the beginning of the list. If an application frequently accesses the
> minimum item, and fast insertion isn't critical, then a sorted linked
> list is an effective choice. A priority queue might be implemented by
> a sorted linked list, for example.

##### List Insertion Sort

> A sorted list can be used as a fairly efficient sorting mechanism.
> Suppose you have an array of unsorted data items. If you take the
> items from the array and insert them one by one into the sorted list,
> they'll be placed in sorted order automatically. If you then remove
> them from the list and put them back in the array, the array will be
> sorted.
>
> This type of sort turns out to be substantially more efficient than
> the more usual insertion sort within an array, described in Chapter 3,
> "Simple Sorting," because fewer copies are necessary. It's still an
> O(N2) process because inserting each item into the sorted list
> involves comparing a new item with an average of half the items
> already in the list, and there are N items to insert, resulting in
> about N2/4 compar- isons. However, each item is copied only twice:
> once from the array to the list and once from the list to the array.
> N\*2 copies compares favorably with the insertion sort within an
> array, where there are about N2 copies.
>
> Listing 5.7 shows the listInsertionSort.java program, which starts
> with an array of unsorted items of type link, inserts them into a
> sorted list (using a constructor), and then removes them and places
> them back into the array.
>
> ***LISTING 5.7*** The listInsertionSort.java Program
>
> // listInsertionSort.java
>
> // demonstrates sorted list used for sorting
>
> // to run this program: C\>java ListInsertionSortApp
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public long dData; // data item
>
> public Link next; // next link in list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link(long dd) // constructor

{ dData = dd; }

> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

Sorted Lists 219

> ***LISTING 5.7*** Continued
>
> } // end class Link
>
> //////////////////////////////////////////////////////////////// class
> SortedList
>
> {
>
> private Link first; // ref to first item on list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public SortedList() // constructor (no args)
>
> { first = null; } // initialize list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public SortedList(Link\[\] linkArr) // constructor (array
>
> { // as argument)
>
> first = null; // initialize list for(int j=0; j\<linkArr.length; j++)
> // copy array

insert( linkArr\[j\] ); // to list

> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insert(Link k) // insert (in order)
>
> {
>
> Link previous = null; // start at first Link current = first;
>
> // until end of list, while(current != null && k.dData \>
> current.dData)
>
> { // or key \> current,
>
> previous = current;

current = current.next; // go to next item

> }
>
> if(previous==null) // at beginning of list first = k; // first \--\> k
>
> else // not at beginning
>
> previous.next = k; // old prev \--\> k k.next = current; // k \--\>
> old current
>
> } // end insert()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public Link remove() // return & delete first link

> { // (assumes non-empty list)
>
> Link temp = first; // save first
>
> first = first.next; // delete first
>
> return temp; // return value
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> } // end class SortedList
>
> 220 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.7*** Continued
>
> //////////////////////////////////////////////////////////////// class
> ListInsertionSortApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> int size = 10;
>
> // create array of links Link\[\] linkArray = new Link\[size\];
>
> for(int j=0; j\<size; j++) // fill array with links
>
> { // random number
>
> int n = (int)(java.lang.Math.random()\*99); Link newLink = new
> Link(n); // make link linkArray\[j\] = newLink; // put in array
>
> }
>
> // display array contents System.out.print("Unsorted array: ");
>
> for(int j=0; j\<size; j++)
>
> System.out.print( linkArray\[j\].dData + " " );
> System.out.println("");
>
> // create new list
>
> // initialized with array SortedList theSortedList = new
> SortedList(linkArray);
>
> for(int j=0; j\<size; j++) // links from list to array linkArray\[j\]
> = theSortedList.remove();
>
> // display array contents System.out.print("Sorted Array: ");
>
> for(int j=0; j\<size; j++) System.out.print(linkArray\[j\].dData + "
> ");
>
> System.out.println("");
>
> } // end main()
>
> } // end class ListInsertionSortApp
>
> ////////////////////////////////////////////////////////////////
>
> This program displays the values in the array before the sorting
> operation and again afterward. Here's some sample output:
>
> Unsorted array: 59 69 41 56 84 15 86 81 37 35
>
> Sorted array: 15 35 37 41 56 59 69 81 84 86

Doubly Linked Lists 221

> The output will be different each time because the initial values are
> generated randomly.
>
> A new constructor for SortedList takes an array of Link objects as an
> argument and inserts the entire contents of this array into the newly
> created list. By doing so, it helps make things easier for the client
> (the main() routine).
>
> We've also made a change to the insert() routine in this program. It
> now accepts a Link object as an argument, rather than a long. We do
> this so we can store Link objects in the array and insert them
> directly into the list. In the sortedList.java program (Listing 5.6),
> it was more convenient to have the insert() routine create each Link
> object, using the long value passed as an argument.
>
> The downside of the list insertion sort, compared with an array-based
> insertion sort, is that it takes somewhat more than twice as much
> memory: The array and linked list must be in memory at the same time.
> However, if you have a sorted linked list class handy, the list
> insertion sort is a convenient way to sort arrays that aren't too
> large.

#### Doubly Linked Lists

> Let's examine another variation on the linked list: the *doubly
> linked* list (not to be confused with the double-ended list). What's
> the advantage of a doubly linked list? A potential problem with
> ordinary linked lists is that it's difficult to traverse backward
> along the list. A statement like
>
> current=current.next
>
> steps conveniently to the next link, but there's no corresponding way
> to go to the previous link. Depending on the application, this
> limitation could pose problems.
>
> For example, imagine a text editor in which a linked list is used to
> store the text. Each text line on the screen is stored as a String
> object embedded in a link. When the editor's user moves the cursor
> downward on the screen, the program steps to the next link to
> manipulate or display the new line. But what happens if the user moves
> the cursor upward? In an ordinary linked list, you would need to
> return current (or its equivalent) to the start of the list and then
> step all the way down again to the new current link. This isn't very
> efficient. You want to make a single step upward.
>
> The doubly linked list provides this capability. It allows you to
> traverse backward as well as forward through the list. The secret is
> that each link has two references to other links instead of one. The
> first is to the next link, as in ordinary lists. The second is to the
> previous link. This type of list is shown in Figure 5.13.
>
> 222 **CHAPTER 5** Linked Lists

Null

> ***FIGURE 5.13*** A doubly linked list.
>
> The beginning of the specification for the Link class in a doubly
> linked list looks like this:
>
> class Link
>
> {
>
> public long dData; // data item
>
> public Link next; // next link in list
>
> public link previous; // previous link in list
>
> \...
>
> }
>
> The downside of doubly linked lists is that every time you insert or
> delete a link you must deal with four links instead of two: two
> attachments to the previous link and two attachments to the following
> one. Also, of course, each link is a little bigger because of the
> extra reference.
>
> A doubly linked list doesn't necessarily need to be a double-ended
> list (keeping a reference to the last element on the list) but
> creating it this way is useful, so we'll include it in our example.
>
> We'll show the complete listing for the doublyLinked.java program
> soon, but first let's examine some of the methods in its
> doublyLinkedList class.

##### Traversal

> Two display methods demonstrate traversal of a doubly linked list. The
> displayForward() method is the same as the displayList() method we've
> seen in ordi- nary linked lists. The displayBackward() method is
> similar but starts at the last element in the list and proceeds toward
> the start of the list, going to each element's previous field. This
> code fragment shows how this process works:
>
> Link current = last; // start at end while(current != null) // until
> start of list,
>
> current = current.previous; // move to previous link

Doubly Linked Lists 223

> Incidentally, some people take the view that, because you can go
> either way equally easily on a doubly linked list, there is no
> preferred direction and therefore terms like previous and next are
> inappropriate. If you prefer, you can substitute direction- neutral
> terms such as left and right.

##### Insertion

> We've included several insertion routines in the DoublyLinkedList
> class. The insertFirst() method inserts at the beginning of the list,
> insertLast() inserts at the end, and insertAfter() inserts following
> an element with a specified key.
>
> Unless the list is empty, the insertFirst() routine changes the
> previous field in the old first link to point to the new link and
> changes the next field in the new link to point to the old first link.
> Finally, it sets first to point to the new link. This process is shown
> in Figure 5.14.
>
> ![](media/image37.png)Old first link

Null

> ***FIGURE 5.14*** Insertion at the beginning.
>
> If the list is empty, the last field must be changed instead of the
> first.previous field. Here's the code:
>
> if( isEmpty() ) // if empty list, last = newLink; // newLink \<\--
> last
>
> else
>
> first.previous = newLink; // newLink \<\-- old first newLink.next =
> first; // newLink \--\> old first first = newLink; // first \--\>
> newLink
>
> 224 **CHAPTER 5** Linked Lists
>
> The insertLast() method is the same process applied to the end of the
> list; it's a mirror image of insertFirst().
>
> The insertAfter() method inserts a new link following the link with a
> specified key value. It's a bit more complicated because four
> connections must be made. First, the link with the specified key value
> must be found. This procedure is handled the same way as the find()
> routine in the linkList2.java program (Listing 5.2). Then, assum- ing
> we're not at the end of the list, two connections must be made between
> the new link and the next link, and two more between current and the
> new link. This process is shown in Figure 5.15.
>
> current

Null

> ***FIGURE 5.15*** Insertion at an arbitrary location.
>
> If the new link will be inserted at the end of the list, its next
> field must point to null, and last must point to the new link. Here's
> the insertAfter() code that deals with the links:
>
> if(current==last) // if last link,
>
> {
>
> newLink.next = null; // newLink \--\> null last = newLink; // newLink
> \<\-- last
>
> }
>
> else // not last link,
>
> {
>
> newLink.next = current.next; // newLink \--\> old next
>
> // newLink \<\-- old next current.next.previous = newLink;

Doubly Linked Lists 225

> }
>
> newLink.previous = current; // old current \<\-- newLink current.next
> = newLink; // old current \--\> newLink
>
> Perhaps you're unfamiliar with the use of two dot operators in the
> same expression. It's a natural extension of a single dot operator.
> The expression
>
> current.next.previous
>
> means the previous field of the link referred to by the next field in
> the link current.

##### Deletion

> There are three deletion routines: deleteFirst(), deleteLast(), and
> deleteKey(). The first two are fairly straightforward. In deleteKey(),
> the key being deleted is current. Assuming the link to be deleted is
> neither the first nor the last one in the list, the next field of
> current.previous (the link before the one being deleted) is set to
> point to current.next (the link following the one being deleted), and
> the previous field of current.next is set to point to
> current.previous. This disconnects the current link from the list.
> Figure 5.16 shows how this disconnection looks, and the following two
> statements carry it out:
>
> current.previous.next = current.next; current.next.previous =
> current.previous;
>
> current.prev current current.next

Null

> ***FIGURE 5.16*** Deleting an arbitrary link.
>
> Special cases arise if the link to be deleted is either the first or
> last in the list because first or last must be set to point to the
> next or the previous link. Here's the code from deleteKey() for
> dealing with link connections:
>
> if(current==first) // first item?
>
> first = current.next; // first \--\> old next else // not first
>
> // old previous \--\> old next
>
> 226 **CHAPTER 5** Linked Lists
>
> current.previous.next = current.next; if(current==last) // last item?
>
> last = current.previous; // old previous \<\-- last else // not last
>
> // old previous \<\-- old next current.next.previous =
> current.previous;
>
> **The** doublyLinked.java **Program**
>
> Listing 5.8 shows the complete doublyLinked.java program, which
> includes all the routines just discussed.
>
> ***LISTING 5.8*** The doublyLinked.java Program
>
> // doublyLinked.java
>
> // demonstrates doubly-linked list
>
> // to run this program: C\>java DoublyLinkedApp
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public long dData; // data item
>
> public Link next; // next link in list
>
> public Link previous; // previous link in list
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link(long d) // constructor
>
> { dData = d; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayLink() // display this link
>
> { System.out.print(dData + " "); }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Link
>
> //////////////////////////////////////////////////////////////// class
> DoublyLinkedList
>
> {
>
> private Link first; // ref to first item
>
> private Link last; // ref to last item
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public DoublyLinkedList() // constructor
>
> {
>
> first = null; // no items on list yet last = null;
>
> }

Doubly Linked Lists 227

> ***LISTING 5.8*** Continued

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public boolean isEmpty() // true if no links
>
> { return first==null; }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void insertFirst(long dd) // insert at front of list

> {
>
> Link newLink = new Link(dd); // make new link
>
> if( isEmpty() ) // if empty list, last = newLink; // newLink \<\--
> last
>
> else
>
> first.previous = newLink; // newLink \<\-- old first newLink.next =
> first; // newLink \--\> old first first = newLink; // first \--\>
> newLink
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void insertLast(long dd) // insert at end of list

> {
>
> Link newLink = new Link(dd); // make new link if( isEmpty() ) // if
> empty list,
>
> first = newLink; // first \--\> newLink else
>
> {
>
> last.next = newLink; // old last \--\> newLink newLink.previous =
> last; // old last \<\-- newLink
>
> }
>
> last = newLink; // newLink \<\-- last
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public Link deleteFirst() // delete first link

> { // (assumes non-empty list)
>
> Link temp = first;
>
> if(first.next == null) // if only one item last = null; // null \<\--
> last
>
> else
>
> first.next.previous = null; // null \<\-- old next first = first.next;
> // first \--\> old next return temp;
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public Link deleteLast() // delete last link
>
> 228 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.8*** Continued
>
> { // (assumes non-empty list)
>
> Link temp = last;
>
> if(first.next == null) // if only one item first = null; // first
> \--\> null
>
> else
>
> last.previous.next = null; // old previous \--\> null last =
> last.previous; // old previous \<\-- last return temp;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // insert dd just after key public boolean insertAfter(long key, long
> dd)
>
> { // (assumes non-empty list)
>
> Link current = first; // start at beginning while(current.dData !=
> key) // until match is found,
>
> {
>
> current = current.next; // move to next link if(current == null)

return false; // didn't find it

> }
>
> Link newLink = new Link(dd); // make new link
>
> if(current==last) // if last link,
>
> {
>
> newLink.next = null; // newLink \--\> null last = newLink; // newLink
> \<\-- last
>
> }
>
> else // not last link,
>
> {
>
> newLink.next = current.next; // newLink \--\> old next
>
> // newLink \<\-- old next current.next.previous = newLink;
>
> }
>
> newLink.previous = current; // old current \<\-- newLink current.next
> = newLink; // old current \--\> newLink return true; // found it, did
> insertion
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public Link deleteKey(long key) // delete item w/ given key

> { // (assumes non-empty list)
>
> Link current = first; // start at beginning

Doubly Linked Lists 229

> ***LISTING 5.8*** Continued
>
> while(current.dData != key) // until match is found,
>
> {
>
> current = current.next; // move to next link if(current == null)

return null; // didn't find it

> }
>
> if(current==first) // found it; first item? first = current.next; //
> first \--\> old next
>
> else // not first
>
> // old previous \--\> old next current.previous.next = current.next;
>
> if(current==last) // last item?
>
> last = current.previous; // old previous \<\-- last else // not last
>
> // old previous \<\-- old next current.next.previous =
> current.previous;
>
> return current; // return value
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void displayForward()

> {
>
> System.out.print("List (first\--\>last): ");
>
> Link current = first; // start at beginning while(current != null) //
> until end of list,
>
> {
>
> current.displayLink(); // display data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void displayBackward()

> {
>
> System.out.print("List (last\--\>first): ");
>
> Link current = last; // start at end while(current != null) // until
> start of list,
>
> {
>
> current.displayLink(); // display data
>
> current = current.previous; // move to previous link
>
> }
>
> 230 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.8*** Continued
>
> System.out.println("");
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class DoublyLinkedList
>
> //////////////////////////////////////////////////////////////// class
> DoublyLinkedApp
>
> {
>
> public static void main(String\[\] args)
>
> { // make a new list
>
> DoublyLinkedList theList = new DoublyLinkedList();
>
> theList.insertFirst(22); // insert at front theList.insertFirst(44);
> theList.insertFirst(66);
>
> theList.insertLast(11); // insert at rear theList.insertLast(33);
>
> theList.insertLast(55);
>
> theList.displayForward(); // display list forward
> theList.displayBackward(); // display list backward
>
> theList.deleteFirst(); // delete first item theList.deleteLast(); //
> delete last item theList.deleteKey(11); // delete item with key 11
>
> theList.displayForward(); // display list forward
>
> theList.insertAfter(22, 77); // insert 77 after 22
>
> theList.insertAfter(33, 88); // insert 88 after 33
>
> theList.displayForward(); // display list forward
>
> } // end main()
>
> } // end class DoublyLinkedApp
>
> ////////////////////////////////////////////////////////////////
>
> In main() we insert some items at the beginning of the list and at the
> end, display the items going both forward and backward, delete the
> first and last items and the item with key 11, display the list again
> (forward only), insert two items using the insertAfter() method, and
> display the list again. Here's the output:

Iterators 231

> List (first\--\>last): 66 44 22 11 33 55
>
> List (last\--\>first): 55 33 11 22 44 66
>
> List (first\--\>last): 44 22 33
>
> List (first\--\>last): 44 22 77 33 88
>
> The deletion methods and the insertAfter() method assume that the list
> isn't empty. Although for simplicity we don't show it in main(),
> isEmpty() should be used to verify that there's something in the list
> before attempting such insertions and deletions.

##### Doubly Linked List as Basis for Deques

> A doubly linked list can be used as the basis for a deque, mentioned
> in the preceding chapter. In a deque you can insert and delete at
> either end, and the doubly linked list provides this capability.

#### Iterators

> We've seen how the user of a list can find a link with a given key
> using a find() method. The method starts at the beginning of the list
> and examines each link until it finds one matching the search key.
> Other operations we've looked at, such as deleting a specified link or
> inserting before or after a specified link, also involve searching
> through the list to find the specified link. However, these methods
> don't give the user any control over the traversal to the specified
> item.
>
> Suppose you wanted to traverse a list, performing some operation on
> certain links. For example, imagine a personnel file stored as a
> linked list. You might want to increase the wages of all employees who
> were being paid minimum wage, without affecting employees already
> above the minimum. Or suppose that in a list of mail- order customers,
> you decided to delete all customers who had not ordered anything in
> six months.
>
> In an array, such operations are easy because you can use an array
> index to keep track of your position. You can operate on one item,
> then increment the index to point to the next item, and see if that
> item is a suitable candidate for the operation. However, in a linked
> list, the links don't have fixed index numbers. How can we provide a
> list's user with something analogous to an array index? You could
> repeat- edly use find() to look for appropriate items in a list, but
> that approach requires many comparisons to find each link. It's far
> more efficient to step from link to link, checking whether each one
> meets certain criteria and performing the appropriate operation if it
> does.
>
> 232 **CHAPTER 5** Linked Lists

##### A Reference in the List Itself?

> As users of a list class, what we need is access to a reference that
> can point to any arbitrary link. This way, we can examine or modify
> the link. We should be able to increment the reference so we can
> traverse along the list, looking at each link in turn, and we should
> be able to access the link pointed to by the reference.
>
> Assuming we create such a reference, where will it be installed? One
> possibility is to use a field in the list itself, called current or
> something similar. You could access a link using current and increment
> current to move to the next link.
>
> One problem with this approach is that you might need more than one
> such refer- ence, just as you often use several array indices at the
> same time. How many would be appropriate? There's no way to know how
> many the user might need. Thus, it seems easier to allow the user to
> create as many such references as necessary. To make this possible in
> an object-oriented language, it's natural to embed each refer- ence in
> a class object. This object can't be the same as the list class
> because there's only one list object, so it is normally implemented as
> a separate class.

##### An Iterator Class

> Objects containing references to items in data structures, used to
> traverse these struc- tures, are commonly called *iterators* (or
> sometimes, as in certain Java classes, *enumera- tors*). Here's a
> preliminary idea of how they look:
>
> class ListIterator()
>
> {
>
> private Link current;
>
> \...
>
> }
>
> The current field contains a reference to the link the iterator
> currently points to. (The term *points* as used here doesn't refer to
> pointers in C++; we're using it in its generic sense to mean "refers
> to.")
>
> To use such an iterator, the user might create a list and then create
> an iterator object associated with the list. Actually, as it turns
> out, letting the list create the iterator is easier, so it can pass
> the iterator certain information, such as a reference to its first
> field. Thus, we add a getIterator() method to the list class; this
> method returns a suitable iterator object to the user. Here's some
> abbreviated code in main() that shows how the class user would invoke
> an iterator:
>
> public static void main(\...)
>
> {
>
> LinkList theList = new LinkList(); // make list ListIterator iter1 =
> theList.getIterator(); // make iter

Iterators 233

> Link aLink = iter1.getCurrent(); // access link at iterator
> iter1.nextLink(); // move iter to next link
>
> }
>
> After we've made the iterator object, we can use it to access the link
> it points to or increment it so it points to the next link, as shown
> in the second two statements. We call the iterator object iter1 to
> emphasize that you could make more iterators (iter2 and so on) the
> same way.
>
> The iterator always points to some link in the list. It's associated
> with the list, but it's not the same as the list or the same as a
> link. Figure 5.17 shows two iterators point- ing to links in a list.
>
> Linked List

Null

> ***FIGURE 5.17*** List iterators.

##### Additional Iterator Features

> We've seen several programs in which the use of a previous field made
> performing certain operations simpler, such as deleting a link from an
> arbitrary location. Such a field is also useful in an iterator.
>
> Also, it may be that the iterator will need to change the value of the
> list's first field---for instance, if an item is inserted or deleted
> at the beginning of the list. If the iterator is an object of a
> separate class, how can it access a private field, such as first, in
> the list? One solution is for the list to pass a reference from itself
> to the iter- ator when it creates the iterator. This reference is
> stored in a field in the iterator.
>
> 234 **CHAPTER 5** Linked Lists
>
> The list must then provide public methods that allow the iterator to
> change first. These LinkList methods are getFirst() and setFirst().
> (The weakness of this approach is that these methods allow anyone to
> change first, which introduces an element of risk.)
>
> Here's a revised (although still incomplete) iterator class that
> incorporates these additional fields, along with reset() and
> nextLink() methods:
>
> class ListIterator()
>
> {
>
> private Link current; // reference to current link private Link
> previous; // reference to previous link private LinkList ourList; //
> reference to "parent" list
>
> public void reset() // set to start of list
>
> {
>
> current = ourList.getFirst(); // current \--\> first previous = null;
> // previous \--\> null
>
> }
>
> public void nextLink() // go to next link
>
> {
>
> previous = current; // set previous to this current = current.next; //
> set this to next
>
> }
>
> \...
>
> }
>
> We might note, for you old-time C++ programmers, that in C++ the
> connection between the iterator and the list is typically provided by
> making the iterator class a *friend* of the list class. However, Java
> has no friend classes, which are controversial in any case because
> they are a chink in the armor of data hiding.

##### Iterator Methods

> Additional methods can make the iterator a flexible and powerful
> class. All opera- tions previously performed by the class that involve
> iterating through the list, such as insertAfter(), are more naturally
> performed by the iterator. In our example the iterator includes the
> following methods:

-   reset()---Sets the iterator to the start of the list

-   nextLink()---Moves the iterator to the next link

-   getCurrent()---Returns the link at the iterator

-   atEnd()---Returns true if the iterator is at the end of the list

Iterators 235

-   insertAfter()---Inserts a new link after the iterator

-   insertBefore()---Inserts a new link before the iterator

-   deleteCurrent()---Deletes the link at the iterator

> The user can position the iterator using reset() and nextLink(), check
> whether it's at the end of the list with atEnd(), and perform the
> other operations shown.
>
> Deciding which tasks should be carried out by an iterator and which by
> the list itself is not always easy. An insertBefore() method works
> best in the iterator, but an insertFirst() routine that always inserts
> at the beginning of the list might be more appropriate in the list
> class. We've kept a displayList() routine in the list, but this
> operation could also be handled with getCurrent() and nextLink() calls
> to the iterator.
>
> **The** interIterator.java **Program**
>
> The interIterator.java program includes an interactive interface that
> permits the user to control the iterator directly. After you've
> started the program, you can perform the following actions by typing
> the appropriate letter:

-   s---Show the list contents

-   r---Reset the iterator to the start of the list

-   n---Go to the next link

-   g---Get the contents of the current link

-   b---Insert before the current link

-   a---Insert a new link after the current link

-   d---Delete the current link

> Listing 5.9 shows the complete interIterator.java program.
>
> ***LISTING 5.9*** The interIterator.java Program
>
> // interIterator.java
>
> // demonstrates iterators on a linked listListIterator
>
> // to run this program: C\>java InterIterApp import java.io.\*; // for
> I/O
>
> //////////////////////////////////////////////////////////////// class
> Link
>
> {
>
> public long dData; // data item
>
> 236 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.9*** Continued
>
> public Link next; // next link in list

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public Link(long dd) // constructor
>
> { dData = dd; }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayLink() // display ourself
>
> { System.out.print(dData + " "); }
>
> } // end class Link
>
> //////////////////////////////////////////////////////////////// class
> LinkList
>
> {
>
> private Link first; // ref to first item on list

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public LinkList() // constructor
>
> { first = null; } // no items on list yet

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public Link getFirst() // get value of first
>
> { return first; }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void setFirst(Link f) // set first to new link
>
> { first = f; }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public boolean isEmpty() // true if list is empty
>
> { return first==null; }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public ListIterator getIterator() // return iterator
>
> {
>
> return new ListIterator(this); // initialized with
>
> } // this list

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayList()
>
> {
>
> Link current = first; // start at beginning of list while(current !=
> null) // until end of list,
>
> {
>
> current.displayLink(); // print data current = current.next; // move
> to next link
>
> }
>
> System.out.println("");
>
> }

Iterators 237

> ***LISTING 5.9*** Continued
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class LinkList
>
> //////////////////////////////////////////////////////////////// class
> ListIterator
>
> {
>
> private Link current; // current link private Link previous; //
> previous link private LinkList ourList; // our linked list
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public ListIterator(LinkList list) // constructor
>
> {
>
> ourList = list; reset();
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void reset() // start at 'first'
>
> {
>
> current = ourList.getFirst(); previous = null;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean atEnd() // true if last link
>
> { return (current.next==null); }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void nextLink() // go to next link
>
> {
>
> previous = current; current = current.next;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Link getCurrent() // get current link
>
> { return current; }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insertAfter(long dd) // insert after
>
> { // current link
>
> Link newLink = new Link(dd);
>
> if( ourList.isEmpty() ) // empty list
>
> {
>
> ourList.setFirst(newLink); current = newLink;
>
> 238 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.9*** Continued
>
> }
>
> else // not empty
>
> {
>
> newLink.next = current.next; current.next = newLink;
>
> nextLink(); // point to new link
>
> }
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void insertBefore(long dd) // insert before

> { // current link
>
> Link newLink = new Link(dd);
>
> if(previous == null) // beginning of list
>
> { // (or empty list)
>
> newLink.next = ourList.getFirst(); ourList.setFirst(newLink); reset();
>
> }
>
> else // not beginning
>
> {
>
> newLink.next = previous.next; previous.next = newLink; current =
> newLink;
>
> }
>
> }

//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public long deleteCurrent() // delete item at current

> {
>
> long value = current.dData;
>
> if(previous == null) // beginning of list
>
> {
>
> ourList.setFirst(current.next); reset();
>
> }
>
> else // not beginning
>
> {
>
> previous.next = current.next; if( atEnd() )
>
> reset(); else

Iterators 239

> ***LISTING 5.9*** Continued
>
> current = current.next;
>
> }
>
> return value;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class ListIterator
>
> //////////////////////////////////////////////////////////////// class
> InterIterApp
>
> {
>
> public static void main(String\[\] args) throws IOException
>
> {
>
> LinkList theList = new LinkList(); // new list ListIterator iter1 =
> theList.getIterator(); // new iter long value;
>
> iter1.insertAfter(20); // insert items iter1.insertAfter(40);
>
> iter1.insertAfter(80); iter1.insertBefore(60);
>
> while(true)
>
> {
>
> System.out.print("Enter first letter of show, reset, ");
> System.out.print("next, get, before, after, delete: ");
> System.out.flush();
>
> int choice = getChar(); // get user's option switch(choice)
>
> {
>
> case 's': // show list if( !theList.isEmpty() )
>
> theList.displayList(); else
>
> System.out.println("List is empty"); break;
>
> case 'r': // reset (to first) iter1.reset();
>
> break;
>
> case 'n': // advance to next item if( !theList.isEmpty() &&
> !iter1.atEnd() )
>
> iter1.nextLink(); else
>
> 240 **CHAPTER 5** Linked Lists
>
> ***LISTING 5.9*** Continued
>
> System.out.println("Can't go to next link"); break;
>
> case 'g': // get current item if( !theList.isEmpty() )
>
> {
>
> value = iter1.getCurrent().dData; System.out.println("Returned " +
> value);
>
> }
>
> else
>
> System.out.println("List is empty"); break;
>
> case 'b': // insert before current System.out.print("Enter value to
> insert: "); System.out.flush();
>
> value = getInt(); iter1.insertBefore(value); break;
>
> case 'a': // insert after current System.out.print("Enter value to
> insert: "); System.out.flush();
>
> value = getInt(); iter1.insertAfter(value); break;
>
> case 'd': // delete current item if( !theList.isEmpty() )
>
> {
>
> value = iter1.deleteCurrent(); System.out.println("Deleted " + value);
>
> }
>
> else
>
> System.out.println("Can't delete"); break;
>
> default:
>
> System.out.println("Invalid entry");
>
> } // end switch

} // end while

> } // end main()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static String getString() throws IOException
>
> {
>
> InputStreamReader isr = new InputStreamReader(System.in);

Iterators 241

> ***LISTING 5.9*** Continued
>
> BufferedReader br = new BufferedReader(isr); String s = br.readLine();
>
> return s;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static char getChar() throws IOException
>
> {
>
> String s = getString(); return s.charAt(0);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static int getInt() throws IOException
>
> {
>
> String s = getString(); return Integer.parseInt(s);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class InterIterApp
>
> ////////////////////////////////////////////////////////////////
>
> The main() routine inserts four items into the list, using an iterator
> and its insertAfter() method. Then it waits for the user to interact
> with it. In the following sample interaction, the user displays the
> list, resets the iterator to the beginning, goes forward two links,
> gets the current link's key value (which is 60), inserts 100 before
> this, inserts 7 after the 100, and displays the list again:
>
> Enter first letter of
>
> show, reset, next, get, before, after, delete: s 20 40 60 80
>
> Enter first letter of
>
> show, reset, next, get, before, after, delete: r Enter first letter of
>
> show, reset, next, get, before, after, delete: n Enter first letter of
>
> show, reset, next, get, before, after, delete: n Enter first letter of
>
> show, reset, next, get, before, after, delete: g Returned 60
>
> Enter first letter of
>
> show, reset, next, get, before, after, delete: b Enter value to
> insert: 100
>
> 242 **CHAPTER 5** Linked Lists
>
> Enter first letter of
>
> show, reset, next, get, before, after, delete: a Enter value to
> insert: 7
>
> Enter first letter of
>
> show, reset, next, get, before, after, delete: s 20 40 100 7 60 80
>
> Experimenting with the interIterator.java program will give you a
> feeling for how the iterator moves along the links and how it can
> insert and delete links anywhere in the list.

##### Where Does the Iterator Point?

> One of the design issues in an iterator class is deciding where the
> iterator should point following various operations.
>
> When you delete an item with deleteCurrent(), should the iterator end
> up pointing to the next item, to the previous item, or back at the
> beginning of the list? Keeping the iterator in the vicinity of the
> deleted item is convenient because the chances are the class user will
> be carrying out other operations there. However, you can't move it to
> the previous item because there's no way to reset the list's previous
> field to the previous item. (You would need a doubly linked list for
> that task.) Our solution is to move the iterator to the link following
> the deleted link. If we've just deleted the item at the end of the
> list, the iterator is set to the beginning of the list.
>
> Following calls to insertBefore() and insertAfter(), we return with
> current pointing to the newly inserted item.
>
> **The** atEnd() **Method**
>
> There's another question about the atEnd() method. It could return
> true when the iterator points to the last valid link in the list, or
> it could return true when the iterator points *past* the last link
> (and is thus not pointing to a valid link).
>
> With the first approach, a loop condition used to iterate through the
> list becomes awkward because you need to perform an operation on the
> last link before checking whether it is the last link (and terminating
> the loop if it is).
>
> However, the second approach doesn't allow you to find out you're at
> the end of the list until it's too late to do anything with the last
> link. (You couldn't look for the last link and then delete it, for
> example.) This is because when atEnd() became true, the iterator would
> no longer point to the last link (or indeed any valid link), and you
> can't "back up" the iterator in a singly linked list.
>
> We take the first approach. This way, the iterator always points to a
> valid link, although you must be careful when writing a loop that
> iterates through the list, as we'll see next.

Iterators 243

##### Iterative Operations

> As we noted, an iterator allows you to traverse the list, performing
> operations on certain data items. Here's a code fragment that displays
> the list contents, using an iterator instead of the list's
> displayList() method:
>
> iter1.reset(); // start at first
>
> long value = iter1.getCurrent().dData; // display link
> System.out.println(value + " ");
>
> while( !iter1.atEnd() ) // until end,
>
> {
>
> iter1.nextLink(); // go to next link, long value =
> iter1.getCurrent().dData; // display it System.out.println(value + "
> ");
>
> }
>
> Although we don't do so here, you should check with isEmpty() to be
> sure the list is not empty before calling getCurrent().
>
> The following code shows how you could delete all items with keys that
> are multi- ples of 3. We show only the revised main() routine;
> everything else is the same as in interIterator.java (Listing 5.9).
>
> class InterIterApp
>
> {
>
> public static void main(String\[\] args) throws IOException
>
> {
>
> LinkList theList = new LinkList(); // new list ListIterator iter1 =
> theList.getIterator(); // new iter
>
> iter1.insertAfter(21); // insert links iter1.insertAfter(40);
>
> iter1.insertAfter(30); iter1.insertAfter(7); iter1.insertAfter(45);
>
> theList.displayList(); // display list
>
> iter1.reset(); // start at first link Link aLink = iter1.getCurrent();
> // get it if(aLink.dData % 3 == 0) // if divisible by 3,

iter1.deleteCurrent(); // delete it

> while( !iter1.atEnd() ) // until end of list,
>
> {
>
> 244 **CHAPTER 5** Linked Lists
>
> iter1.nextLink(); // go to next link
>
> aLink = iter1.getCurrent(); // get link if(aLink.dData % 3 == 0) // if
> divisible by 3,
>
> iter1.deleteCurrent(); // delete it

}

> theList.displayList(); // display list
>
> } // end main()
>
> } // end class InterIterApp
>
> We insert five links and display the list. Then we iterate through the
> list, deleting those links with keys divisible by 3, and display the
> list again. Here's the output:
>
> 21 40 30 7 45
>
> 40 7
>
> Again, although we don't show it here, it's important to check whether
> the list is empty before calling deleteCurrent().

##### Other Methods

> You could create other useful methods for the ListIterator class. For
> example, a find() method would return an item with a specified key
> value, as we've seen when find() is a list method. A replace() method
> could replace items that had certain key values with other items.
>
> Because it's a singly linked list, you can iterate along it only in
> the forward direction. If a doubly linked list were used, you could go
> either way, allowing operations such as deletion from the end of the
> list, just as with non-iterators. This capability would probably be a
> convenience in some applications.

#### Summary

-   A linked list consists of one linkedList object and a number of Link
    objects.

-   The linkedList object contains a reference, often called first, to
    the first link in the list.

-   Each Link object contains data and a reference, often called next,
    to the next link in the list.

-   A next value of null signals the end of the list.

-   Inserting an item at the beginning of a linked list involves
    changing the new link's next field to point to the old first link
    and changing first to point to the new item.

Questions 245

-   Deleting an item at the beginning of a list involves setting first
    to point to

> first.next.

-   To traverse a linked list, you start at first and then go from link
    to link, using each link's next field to find the next link.

-   A link with a specified key value can be found by traversing the
    list. Once found, an item can be displayed, deleted, or operated on
    in other ways.

-   A new link can be inserted before or after a link with a specified
    key value, following a traversal to find this link.

-   A double-ended list maintains a pointer to the last link in the
    list, often called last, as well as to the first.

-   A double-ended list allows insertion at the end of the list.

-   An Abstract Data Type (ADT) is a data storage class considered
    without reference to its implementation.

-   Stacks and queues are ADTs. They can be implemented using either
    arrays or linked lists.

-   In a sorted linked list, the links are arranged in order of
    ascending (or sometimes descending) key value.

-   Insertion in a sorted list takes O(N) time because the correct
    insertion point must be found. Deletion of the smallest link takes
    O(1) time.

-   In a doubly linked list, each link contains a reference to the
    previous link as well as the next link.

-   A doubly linked list permits backward traversal and deletion from
    the end of the list.

-   An iterator is a reference, encapsulated in a class object, that
    points to a link in an associated list.

-   Iterator methods allow the user to move the iterator along the list
    and access the link currently pointed to.

-   An iterator can be used to traverse through a list, performing some
    operation on selected links (or all links).

#### Questions

> These questions are intended as a self-test for readers. Answers may
> be found in Appendix C.
>
> 246 **CHAPTER 5** Linked Lists

1.  Which of the following is *not* true? A reference to a class object

    a.  can be used to access public methods in the object.

    b.  has a size dependant on its class.

    c.  has the data type of the class.

    d.  does not hold the object itself.

2.  Access to the links in a linked list is usually through the [
    ]{.underline} link.

3.  When you create a reference to a link in a linked list, it

    e.  must refer to the first link.

    f.  must refer to the link pointed to by current.

    g.  must refer to the link pointed to by next.

    h.  can refer to any link you want.

4.  How many references must you change to insert a link in the middle
    of a singly linked list?

5.  How many references must you change to insert a link at the end of a
    singly linked list?

6.  In the insertFirst() method in the linkList.java program (Listing
    5.1), the statement newLink.next=first; means that

    i.  the next new link to be inserted will refer to first.

    j.  first will refer to the new link.

    k.  the next field of the new link will refer to the old first link.

    l.  newLink.next will refer to the new first link in the list.

7.  Assuming current points to the next-to-last link in a singly linked
    list, what statement will delete the last link from the list?

8.  When all references to a link are changed to refer to something
    else, what happens to the link?

9.  A double-ended list

    m.  can be accessed from either end.

    n.  is a different name for a doubly linked list.

    o.  has pointers running both forward and backward between links.

    p.  has its first link connected to its last link.

Programming Projects 247

10. A special case often occurs for insertion and deletion routines when
    a list is

> [ ]{.underline} .

11. Assuming a copy takes longer than a comparison, is it faster to
    delete an item with a certain key from a linked list or from an
    unsorted array?

12. How many times would you need to traverse a singly linked list to
    delete the item with the largest key?

13. Of the lists discussed in this chapter, which one would be best for
    implementing a queue?

14. Which of the following is *not* true? Iterators would be useful if
    you wanted to

    q.  do an insertion sort on a linked list.

    r.  insert a new link at the beginning of a list.

    s.  swap two links at arbitrary locations.

    t.  delete all links with a certain key value.

15. Which do you think would be a better choice to implement a stack: a
    singly linked list or an array?

#### Experiments

> Carrying out these experiments will help to provide insights into the
> topics covered in the chapter. No programming is involved.

1.  Use the LinkList Workshop applet to execute insert, find, and delete
    operations on both sorted and unsorted lists. For the operations
    demonstrated by this applet, is there any advantage to the sorted
    list?

2.  Modify main() in the linkList.java program (Listing 5.1) so that it
    continu- ously inserts links into the list until memory is
    exhausted. After each 1,000 items, have it display the number of
    items inserted so far. This way, you can learn approximately how
    many links a list can hold in your particular machine. (Of course,
    the number will vary depending on what other programs are in memory
    and many other factors.) Don't try this experiment if it will crash
    your institution's network.

#### Programming Projects

> Writing programs that solve the Programming Projects helps to solidify
> your under- standing of the material and demonstrates how the
> chapter's concepts are applied.
>
> 248 **CHAPTER 5** Linked Lists
>
> (As noted in the Introduction, qualified instructors may obtain
> completed solutions to the Programming Projects on the publisher's Web
> site.)

1.  Implement a priority queue based on a sorted linked list. The remove
    operation on the priority queue should remove the item with the
    smallest key.

    Implement a deque based on a doubly linked list. (See Programming
    Project 4.2 in the preceding chapter.) The user should be able to
    carry out the normal operations on the deque.

    A circular list is a linked list in which the last link points back
    to the first link. There are many ways to design a circular list.
    Sometimes there is a pointer to the "start" of the list. However,
    this makes the list less like a real circle and more like an
    ordinary list that has its end attached to its beginning. Make a
    class for a singly linked circular list that has no end and no
    beginning. The only access to the list is a single reference,
    current, that can point to any link on the list. This reference can
    move around the list as needed. (See Programming Project 5.5 for a
    situation in which such a circular list is ideally suited.) Your
    list should handle insertion, searching, and deletion. You may find
    it convenient if these operations take place one link downstream of
    the link pointed to by current. (Because the upstream link is singly
    linked, you can't get at it without going all the way around the
    circle.) You should also be able to display the list (although
    you'll need to break the circle at some arbi- trary point to print
    it on the screen). A step() method that moves current along to the
    next link might come in handy too.

    Implement a stack class based on the circular list of Programming
    Project 5.3. This exercise is not too difficult. (However,
    implementing a queue can be harder, unless you make the circular
    list doubly linked.)

    The Josephus Problem is a famous mathematical puzzle that goes back
    to ancient times. There are many stories to go with the puzzle. One
    is that Josephus was one of a group of Jews who were about to be
    captured by the Romans. Rather than be enslaved, they chose to
    commit suicide. They arranged themselves in a circle and, starting
    at a certain person, started counting off around the circle. Every
    nth person had to leave the circle and commit suicide. Josephus
    decided he didn't want to die, so he arranged the rules so he would
    be the last person left. If there were (say) 20 people, and he was
    the seventh person from the start of the circle, what number should
    he tell them to use for counting off? The problem is made much more
    complicated because the circle shrinks as the counting continues.

> Create an application that uses a circular linked list (like that in
> Programming Project 5.3) to model this problem. Inputs are the number
> of people in the circle, the number used for counting off, and the
> number of the person where

Programming Projects 249

> counting starts (usually 1). The output is the list of persons being
> eliminated. When a person drops out of the circle, counting starts
> again from the person who was on his left (assuming you go around
> clockwise). Here's an example. There are seven people numbered 1
> through 7, and you start at 1 and count off by threes. People will be
> eliminated in the order 4, 1, 6, 5, 7, 3. Number 2 will be left.

6.  Let's try something a little different: a two-dimensional linked
    list, which we'll call a matrix. This is the list analogue of a
    two-dimensional array. It might be useful in applications such as
    spreadsheet programs. If a spreadsheet is based on an array, and you
    insert a new row near the top, you must move every cell in the lower
    rows N\*M cells, which is potentially a slow process. If the spread-
    sheet is implemented by a matrix, you need only change N pointers.

> For simplicity, we'll assume a singly linked approach (although a
> double-linked approach would probably be more appropriate for a
> spreadsheet). Each link (except those on the top row and left side) is
> pointed to by the link directly above it and by the link on its left.
> You can start at the upper-left link and navigate to, say, the link on
> the third row and fifth column by following the pointers down two rows
> and right four columns. Assume your matrix is created with specified
> dimensions (7 by 10, for example). You should be able to insert values
> in specified links and display the contents of the matrix.
