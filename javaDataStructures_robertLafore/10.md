10
==

2-3-4 Trees and External
------------------------

Storage

> In a binary tree, each node has one data item and can have up to two
> children. If we allow more data items and children per node, the
> result is a *multiway tree*. 2-3-4 trees,
>
> to which we devote the first part of this chapter, are multi- way
> trees that can have up to four children and three data items per node.
>
> 2-3-4 trees are interesting for several reasons. First, they're
> balanced trees like red-black trees. They're slightly less effi- cient
> than red-black trees but easier to program. Second, and most
> important, they serve as an easy-to-understand introduction to
> B-trees.
>
> A B-tree is another kind of multiway tree that's particularly useful
> for organizing data in external storage. (*External* means external to
> main memory; usually this is a disk drive). A node in a B-tree can
> have dozens or hundreds of children. We'll discuss external storage
> and B-trees at the end of this chapter.

#### Introduction to 2-3-4 Trees

> In this section we'll look at the characteristics of 2-3-4 trees.
> Later we'll see how a Workshop applet models a 2-3- 4 tree and how we
> can program a 2-3-4 tree in Java. We'll also look at the surprisingly
> close relationship between
>
> 2-3-4 trees and red-black trees.
>
> Figure 10.1 shows a small 2-3-4 tree. Each lozenge-shaped node can
> hold one, two, or three data items.

##### IN THIS CHAPTER

-   Introduction to 2-3-4 Trees

-   Java Code for a 2-3-4 Tree

-   2-3-4 Trees and Red-Black Trees

-   Efficiency of 2-3-4 Trees

-   2-3 Trees

-   External Storage

> 464 **CHAPTER 10** 2-3-4 Trees and External Storage

![](media/image1.png)

> ***FIGURE 10.1*** A 2-3-4 tree.
>
> Here the top three nodes have children, and the six nodes on the
> bottom row are all leaf nodes, which by definition have no children.
> In a 2-3-4 tree all the leaf nodes are always on the same level.

##### What's in a Name?

> The 2, 3, and 4 in the name *2-3-4 tree* refer to how many links to
> child nodes can potentially be contained in a given node. For non-leaf
> nodes, three arrangements are possible:

-   A node with one data item always has two children.

-   A node with two data items always has three children.

-   A node with three data items always has four children.

> In short, a non-leaf node must always have one more child than it has
> data items. Or, to put it symbolically, if the number of child links
> is L and the number of data items is D, then
>
> L = D + 1
>
> This critical relationship determines the structure of 2-3-4 trees. A
> leaf node, by contrast, has no children, but it can nevertheless
> contain one, two, or three data items. Empty nodes are not allowed.
>
> Because a *2-3-4 tree* can have nodes with up to four children, it's
> called *a multiway tree of order 4*.
>
> You may wonder why a 2-3-4 tree isn't called a 1-2-3-4 tree. Can't a
> node have only one child, as nodes in binary trees can? A binary tree
> (described in Chapter 8, "Binary Trees," and Chapter 9, "Red-Black
> Trees") can be thought of as a multiway tree of order 2 because each
> node can have up to two children. However, there's a difference
> (besides the maximum number of children) between binary trees and 2-3-
> 4 trees. In a binary tree, a node can have *up to* two child links. A
> single link, to its left or to its right child, is also perfectly
> permissible. The other link has a null value.
>
> Introduction to 2-3-4 Trees 465
>
> In a 2-3-4 tree, on the other hand, nodes with a single link are not
> permitted. A node with one data item must always have two links,
> unless it's a leaf, in which case it has no links.
>
> Figure 10.2 shows the possibilities. A node with two links is called a
> *2-node*, a node with three links is a *3-node*, and a node with four
> links is a *4-node*, but there is no such thing as a 1-node.

0 1 2

> 25 2-node

0 1

12 33 37

> ***FIGURE 10.2*** Nodes in a 2-3-4 tree.

##### Tree Organization

> For convenience we number the data items in a link from 0 to 2, and
> the child links from 0 to 3, as shown in Figure 10.2. The data items
> in a node are arranged in ascending key order, by convention from left
> to right (lower to higher numbers).
>
> An important aspect of any tree's structure is the relationship of its
> links to the key values of its data items. In a binary tree, all
> children with keys less than the node's key are in a subtree rooted in
> the node's left child, and all children with keys larger than or equal
> to the node's key are rooted in the node's right child. In a 2-3-4
> tree the principle is the same, but there's more to it:

-   All children in the subtree rooted at child 0 have key values less
    than key 0.

-   All children in the subtree rooted at child 1 have key values
    greater than key 0 but less than key 1.

> 466 **CHAPTER 10** 2-3-4 Trees and External Storage

-   All children in the subtree rooted at child 2 have key values
    greater than key 1 but less than key 2.

-   All children in the subtree rooted at child 3 have key values
    greater than key 2.

> This relationship is shown in Figure 10.3. Duplicate values are not
> usually permitted in 2-3-4 trees, so we don't need to worry about
> comparing equal keys.
>
> Nodes with
>
> keys less than A
>
> Nodes with
>
> keys between A and B
>
> Nodes with
>
> keys between B and C
>
> Nodes with
>
> keys greater than C
>
> ***FIGURE 10.3*** Keys and children.
>
> Refer back to the tree in Figure 10.1. As in all 2-3-4 trees, the
> leaves are all on the same level (the bottom row). Upper-level nodes
> are often not full; that is, they may contain only one or two data
> items instead of three.
>
> Also, notice that the tree is balanced. It retains its balance even if
> you insert a sequence of data in ascending (or descending) order. The
> 2-3-4 tree's self-balancing capability results from the way new data
> items are inserted, as we'll see in a moment.

##### Searching a 2-3-4 Tree

> Finding a data item with a particular key is similar to the search
> routine in a binary tree. You start at the root and, unless the search
> key is found there, select the link that leads to the subtree with the
> appropriate range of values.
>
> For example, to search for the data item with key 64 in the tree in
> Figure 10.1, you start at the root. You search the root but don't find
> the item. Because 64 is larger than 50, you go to child 1, which we
> will represent as 60/70/80. (Remember that child 1 is on the right
> because the numbering of children and links starts at 0 on the left.)
> You don't find the data item in this node either, so you must go to
> the next child. Here, because 64 is greater than 60 but less than 70,
> you go again to child 1. This time you find the specified item in the
> 62/64/66 link.

##### Insertion

> New data items are always inserted in leaves, which are on the bottom
> row of the tree. If items were inserted in nodes with children, the
> number of children would need to be changed to maintain the structure
> of the tree, which stipulates that there should be one more child than
> data items in a node.
>
> Introduction to 2-3-4 Trees 467
>
> Insertion into a 2-3-4 tree is sometimes quite easy and sometimes
> rather compli- cated. In any case the process begins by searching for
> the appropriate leaf node.
>
> If no full nodes are encountered during the search, insertion is easy.
> When the appropriate leaf node is reached, the new data item is simply
> inserted into it. Figure
>
> 10.4 shows a data item with key 18 being inserted into a 2-3-4 tree.

![](media/image2.png)![](media/image3.png)

> 18 inserted
>
> ***FIGURE 10.4*** Insertion with no splits.
>
> Insertion may involve moving one or two other items in a node so the
> keys will be in the correct order after the new item is inserted. In
> this example the 23 had to be shifted right to make room for the 18.

##### Node Splits

> Insertion becomes more complicated if a full node is encountered on
> the path down to the insertion point. When this happens, the node must
> be *split*. It's this splitting process that keeps the tree balanced.
> The kind of 2-3-4 tree we're discussing here is often called a
> *top-down* 2-3-4 tree because nodes are split on the way down to the
> insertion point.
>
> Let's name the data items in the node that's about to be split A, B,
> and C. Here's what happens in a split. (We assume the node being split
> is not the root; we'll examine splitting the root later.)

-   A new, empty node is created. It's a sibling of the node being
    split, and is placed to its right.

-   Data item C is moved into the new node.

> 468 **CHAPTER 10** 2-3-4 Trees and External Storage

-   Data item B is moved into the parent of the node being split.

-   Data item A remains where it is.

-   The rightmost two children are disconnected from the node being
    split and connected to the new node.

> An example of a node split is shown in Figure 10.5. Another way of
> describing a node split is to say that a 4-node has been transformed
> into two 2-nodes.

![](media/image5.png)

> ![](media/image6.png)
>
> ***FIGURE 10.5*** Splitting a node.
>
> 99 Inserted
>
> Notice that the effect of the node split is to move data up and to the
> right. It is this rearrangement that keeps the tree balanced.
>
> Here the insertion required only one node split, but more than one
> full node may be encountered on the path to the insertion point. When
> this is the case, there will be multiple splits.

##### Splitting the Root

> When a full root is encountered at the beginning of the search for the
> insertion point, the resulting split is slightly more complicated:

-   A new root is created. It becomes the parent of the node being
    split.

-   A second new node is created. It becomes a sibling of the node being
    split.

> Introduction to 2-3-4 Trees 469

-   Data item C is moved into the new sibling.

-   Data item B is moved into the new root.

-   Data item A remains where it is.

-   The two rightmost children of the node being split are disconnected
    from it and connected to the new right-hand node.

> Figure 10.6 shows the root being split. This process creates a new
> root that's at a higher level than the old one. Thus, the overall
> height of the tree is increased by one. Another way to describe
> splitting the root is to say that a 4-node is split into three
> 2-nodes.
>
> ![](media/image7.png)41 to be inserted

a)  Before insertion

> 26 49 72
>
> A B C
>
> The root is split
>
> 9 13 31 35 52 61 82

b)  After insertion

> 49 moves up

![](media/image9.png)49

B

> New root node

26 stays

put 26

> 72 moves
>
> right 72
>
> New right node
>
> A C
>
> 9 13 31 35 41 52 61 82
>
> ***FIGURE 10.6*** Splitting the root.
>
> 41 inserted
>
> Following a node split, the search for the insertion point continues
> down the tree. In Figure 10.6, the data item with a key of 41 is
> inserted into the appropriate leaf.

##### Splitting on the Way Down

> Notice that, because all full nodes are split on the way down, a split
> can't cause an effect that ripples back up through the tree. The
> parent of any node that's being split
>
> 470 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> is guaranteed not to be full and can therefore accept data item B
> without itself needing to be split. Of course, if this parent already
> had two children when its child was split, it will become full.
> However, that just means that it will be split when the next search
> encounters it.
>
> Figure 10.7 shows a series of insertions into an empty tree. There are
> four node splits: two of the root and two of leaves.

![](media/image13.png)

> f)
>
> ![](media/image22.png)
>
> g)
>
> ***FIGURE 10.7*** Insertions into a 2-3-4 tree.

#### The Tree234 Workshop Applet

> Operating the Tree234 Workshop applet provides a quick way to see how
> 2-3-4 trees work. When you start the applet, you'll see a screen
> similar to Figure 10.8.
>
> The Tree234 Workshop Applet 471

![](media/image23.png){width="2.7927351268591427in"
height="2.2866655730533685in"}

> ***FIGURE 10.8*** The Tree234 Workshop applet.

##### The Fill Button

> When it's first started, the Tree234 Workshop applet inserts 7 data
> items into the tree. You can use the Fill button to create a new tree
> with a different number of data items from 0 to 45. Click Fill and
> type the number into the field when prompted.
>
> Another click will create the new tree.
>
> The tree may not look very full with 45 nodes, but more nodes require
> more levels, which won't fit in the display.

##### The Find Button

> You can watch the applet locate a data item with a given key by
> repeatedly clicking the Find button. When prompted, type in the
> appropriate key. Then, as you click the button, watch the red arrow
> move from node to node as it searches for the item.
>
> Messages will say something like Went to child number 1. As we've
> seen, children are numbered from 0 to 3 from left to right, while data
> items are numbered from 0 to 2. After a little practice you should be
> able to predict the path the search will take.
>
> A search involves examining one node on each level. The applet
> supports a maximum of four levels, so any item can be found by
> examining a maximum of four nodes. Within each non-leaf node, the
> algorithm examines each data item, starting on the left, to see if it
> matches the search key or, if not, which child it should go to next.
> In a leaf node it examines each data item to see if it matches the
> search key. If it can't find the specified item in the leaf node, the
> search fails.
>
> 472 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> In the Tree234 Workshop applet it's important to complete each
> operation before attempting a new one. Continue to click the button
> until the message says Press any button. This is the signal that an
> operation is complete.

##### The Ins Button

> The Ins button causes a new data item, with a key specified in the
> text box, to be inserted in the tree. The algorithm first searches for
> the appropriate node. If it encounters a full node along the way, it
> splits that node before continuing.
>
> Experiment with the insertion process. Watch what happens when there
> are no full nodes on the path to the insertion point. This process is
> straightforward. Then try inserting at the end of a path that includes
> a full node, either at the root, at the leaf, or somewhere in between.
> Watch how new nodes are formed and the contents of the node being
> split are distributed among three different nodes.

##### The Zoom Button

> One of the problems with 2-3-4 trees is that there are a great many
> nodes and data items just a few levels down. The Tree234 Workshop
> applet supports only four levels, but there are potentially 64 nodes
> on the bottom level, each of which can hold up to three data items.
>
> Displaying so many items at once on one row is not practical, so the
> applet shows only some of them: the children of a selected node. (To
> see the children of another node, you click on it; we'll discuss that
> in a moment.) To see a zoomed-out view of the entire tree, click the
> Zoom button. Figure 10.9 shows what you'll see.

![](media/image24.png){width="2.7994936570428695in"
height="2.2933333333333334in"}

> ***FIGURE 10.9*** The zoomed-out view.
>
> The Tree234 Workshop Applet 473
>
> In this view nodes are shown as small rectangles; data items are not
> shown. Nodes that exist and are visible in the zoomed-in view (which
> you can restore by clicking Zoom again) are shown in green. Nodes that
> exist but aren't currently visible in the zoomed-out view are shown in
> magenta, and nodes that don't exist are shown in gray. These colors
> are hard to distinguish on the figure; you'll need to view the applet
> on your color monitor to make sense of the display.
>
> Using the Zoom button to toggle back and forth between the zoomed-out
> and zoomed-in views allows you to see both the big picture and the
> details and, we hope, put the two together in your mind.

##### Viewing Different Nodes

> In the zoomed-in view you can always see all the nodes in the top two
> rows: There's only one, the root, in the top row, and only four in the
> second row. Below the second row things get more complicated because
> there are too many nodes to fit on the screen: 16 on the third row, 64
> on the fourth. However, you can see any node you want by clicking on
> its parent, or sometimes its grandparent and then its parent.
>
> A blue triangle at the bottom of a node shows where a child is
> connected to a node. If a node's children are currently visible, the
> lines to the children can be seen running from the blue triangles to
> them. If the children aren't currently visible, there are no lines,
> but the blue triangles indicate that the node nevertheless has chil-
> dren. If you click on the parent node, its children, and the lines to
> them, will appear. By clicking the appropriate nodes, you can navigate
> all over the tree.
>
> For convenience, all the nodes are numbered, starting with 0 at the
> root and contin- uing up to 85 for the node on the far right of the
> bottom row. The numbers are displayed to the upper right of each node,
> as shown in Figure 10.8. Nodes are numbered whether they exist or not,
> so the numbers on existing nodes probably won't be contiguous.
>
> Figure 10.10 shows a small tree with four nodes in the third row. The
> user has clicked on node 1, so its two children, numbered 5 and 6, are
> visible.
>
> If the user clicks on node 2, its children, numbered 9 and 10, will
> appear, as shown in Figure 10.11.
>
> These figures show how to switch among different nodes in the third
> row by clicking nodes in the second row. To switch nodes in the fourth
> row, you'll need to click first on a grandparent in the second row and
> then on a parent in the third row.
>
> During searches and insertions with the Find and Ins buttons, the view
> will change automatically to show the node currently being pointed to
> by the red arrow.
>
> 474 **CHAPTER 10** 2-3-4 Trees and External Storage

![](media/image25.png){width="2.793244750656168in"
height="2.2933333333333334in"}

> ***FIGURE 10.10*** Selecting the leftmost children.

![](media/image26.png){width="2.7927351268591427in"
height="2.2866655730533685in"}

> ***FIGURE 10.11*** Selecting the rightmost children.

##### Experiments

> The Tree234 Workshop applet offers a quick way to learn about 2-3-4
> trees. Try inserting items into the tree. Watch for node splits. Stop
> before one is about to happen, and figure out where the three data
> items from the split node are going to go. Then press Ins again to see
> whether you're right.
>
> As the tree gets larger you'll need to move around it to see all the
> nodes. Click on a node to see its children (and their children, and so
> on). If you lose track of where you are, use the Zoom key to see the
> big picture.
>
> Java Code for a 2-3-4 Tree 475
>
> How many data items can you insert in the tree? There's a limit
> because only four levels are allowed. Four levels can potentially
> contain 1 + 4 + 16 + 64 nodes, for a total of 85 nodes (all visible on
> the zoomed-out display). If there were a full 3 items per node, there
> would be 255 data items. However, the nodes can't all be full at the
> same time. Long before they fill up, another root split, leading to
> five levels, would be necessary, and this is impossible because the
> applet supports only four levels.
>
> You can insert the most items by deliberately inserting them into
> nodes that lie on paths with no full nodes, so that no splits are
> necessary. Of course, this is not a reasonable procedure with real
> data. For random data you probably can't insert more than about 50
> items into the applet. The Fill button allows only 45, to minimize the
> possibility of overflow.

#### Java Code for a 2-3-4 Tree

> In this section we'll examine a Java program that models a 2-3-4 tree.
> We'll show the complete tree234.java program at the end of the
> section. This program is relatively complex, and the classes are
> extensively interrelated, so you'll need to peruse the entire listing
> to see how it works.
>
> There are four classes: DataItem, Node, Tree234, and Tree234App. We'll
> discuss them in turn.
>
> **The** DataItem **Class**
>
> Objects of the DataItem class represent the data items stored in
> nodes. In a real-world program each object would contain an entire
> personnel or inventory record, but here there's only one piece of
> data, of type long, associated with each DataItem object.
>
> The only actions that objects of this class can perform are to
> initialize themselves and display themselves. The display is the data
> value preceded by a slash: /27. (The display routine in the Node class
> will call this routine to display all the items in a node.)
>
> **The** Node **Class**
>
> The Node class contains two arrays: childArray and itemArray. The
> first is four cells long and holds references to whatever children the
> node might have. The second is three cells long and holds references
> to objects of type DataItem contained in the node.
>
> Note that the data items in itemArray comprise an ordered array. New
> items are added, or existing ones removed, in the same way they would
> be in any ordered array (as described in Chapter 2, "Arrays"). Items
> may need to be shifted to make room to insert a new item in order, or
> to close an empty cell when an item is removed.
>
> 476 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> We've chosen to store the number of items currently in the node
> (numItems) and the node's parent (parent) as fields in this class.
> Neither of these fields is strictly neces- sary and could be
> eliminated to make the nodes smaller. However, including them
> clarifies the programming, and only a small price is paid in increased
> node size.
>
> Various small utility routines are provided in the Node class to
> manage the connec- tions to child and parent and to check if the node
> is full and if it is a leaf. However, the major work is done by the
> findItem(), insertItem(), and removeItem() routines, which handle
> individual items within the node. They search through the node for a
> data item with a particular key; insert a new item into the node,
> moving existing items if necessary; and remove an item, again moving
> existing items if necessary.
>
> Don't confuse these methods with the find() and insert() routines in
> the Tree234
>
> class, which we'll look at next.
>
> A display routine displays a node with slashes separating the data
> items, like
>
> /27/56/89/, /14/66/, or /45/.
>
> Don't forget that in Java, references are automatically initialized to
> null and numbers to 0 when their object is created, so class Node
> doesn't need a constructor.
>
> **The** Tree234 **Class**
>
> An object of the Tree234 class represents the entire tree. The class
> has only one field: root, of type Node. All operations start at the
> root, so that's all a tree needs to remember.

####### Searching

> Searching for a data item with a specified key is carried out by the
> find() routine. It starts at the root and at each node calls that
> node's findItem() routine to see whether the item is there. If so, it
> returns the index of the item within the node's item array.
>
> If find() is at a leaf and can't find the item, the search has failed,
> so it returns --1. If it can't find the item in the current node, and
> the current node isn't a leaf, find() calls the getNextChild() method,
> which figures out which of a node's children the routine should go to
> next.

####### Inserting

> The insert() method starts with code similar to find(), except that it
> splits a full node if it finds one. Also, it assumes it can't fail; it
> keeps looking, going to deeper and deeper levels, until it finds a
> leaf node. At this point the method inserts the new data item into the
> leaf. (There is always room in the leaf; otherwise, the leaf would
> have been split.)

####### Splitting

> The split() method is the most complicated in this program. It is
> passed the node that will be split as an argument. First, the two
> rightmost data items are removed
>
> Java Code for a 2-3-4 Tree 477
>
> from the node and stored. Then the two rightmost children are
> disconnected; their references are also stored.
>
> A new node, called newRight, is created. It will be placed to the
> right of the node being split. If the node being split is the root, an
> additional new node is created: a new root.
>
> Next, appropriate connections are made to the parent of the node being
> split. It may be a pre-existing parent, or if the root is being split,
> it will be the newly created root node. Assume the three data items in
> the node being split are called A, B, and C. Item B is inserted in
> this parent node. If necessary, the parent's existing children are
> disconnected and reconnected one position to the right to make room
> for the new data item and new connections. The newRight node is
> connected to this parent. (Refer to Figures 10.5 and 10.6.)
>
> Now the focus shifts to the newRight node. Data Item C is inserted in
> it, and child 2 and child 3, which were previously disconnected from
> the node being split, are connected to it. The split is now complete,
> and the split() routine returns.
>
> **The** Tree234App **Class**
>
> In the Tree234App class, the main() routine inserts a few data items
> into the tree. It then presents a character-based interface for the
> user, who can enter s to see the tree, i to insert a new data item,
> and f to find an existing item. Here's some sample inter- action:
>
> Enter first letter of show, insert, or find: s level=0 child=0 /50/
>
> level=1 child=0 /30/40/ level=1 child=1 /60/70/
>
> Enter first letter of show, insert, or find: f Enter value to find: 40
>
> Found 40
>
> Enter first letter of show, insert, or find: i Enter value to insert:
> 20
>
> Enter first letter of show, insert, or find: s level=0 child=0 /50/
>
> level=1 child=0 /20/30/40/ level=1 child=1 /60/70/
>
> Enter first letter of show, insert, or find: i Enter value to insert:
> 10
>
> Enter first letter of show, insert, or find: s
>
> 478 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> level=0 child=0 /30/50/ level=1 child=0 /10/20/ level=1 child=1 /40/
> level=1 child=2 /60/70/
>
> The output is not very intuitive, but there's enough information to
> draw the tree if you want. The level, starting with 0 at the root, is
> shown, as well as the child number. The display algorithm is
> depth-first, so the root is shown first, then its first child and the
> subtree of which the first child is the root, then the second child
> and its subtree, and so on.
>
> The output shows two items being inserted: 20 and 10. The second of
> these caused a node (the root's child 0) to split. Figure 10.12
> depicts the tree that results from these insertions, following the
> final press of the s key.
>
> Child 0

Level 1

> Child 0 Child 1 Child 2
>
> ***FIGURE 10.12*** Sample output of the tree234.java program.
>
> **The Complete** tree234.java **Program**
>
> Listing 10.1 shows the complete tree234.java program, including all
> the classes just discussed. As with most object-oriented programs,
> it's probably easiest to start by examining the big picture classes
> first and then work down to the detail-oriented classes. In this
> program this order is Tree234App, Tree234, Node, DataItem.
>
> ***LISTING 10.1*** The tree234.java Program
>
> // tree234.java
>
> // demonstrates 234 tree
>
> // to run this program: C\>java Tree234App import java.io.\*;
>
> //////////////////////////////////////////////////////////////// class
> DataItem
>
> {
>
> Java Code for a 2-3-4 Tree 479
>
> ***LISTING 10.1*** Continued
>
> public long dData; // one data item
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public DataItem(long dd) // constructor
>
> { dData = dd; }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayItem() // display item, format "/27"
>
> { System.out.print("/"+dData); }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class DataItem
>
> //////////////////////////////////////////////////////////////// class
> Node
>
> {
>
> private static final int ORDER = 4; private int numItems;
>
> private Node parent;
>
> private Node childArray\[\] = new Node\[ORDER\];
>
> private DataItem itemArray\[\] = new DataItem\[ORDER-1\];
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // connect child to this node
>
> public void connectChild(int childNum, Node child)
>
> {
>
> childArray\[childNum\] = child; if(child != null)
>
> child.parent = this;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // disconnect child from this node, return it public Node
> disconnectChild(int childNum)
>
> {
>
> Node tempNode = childArray\[childNum\]; childArray\[childNum\] = null;
>
> return tempNode;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Node getChild(int childNum)
>
> { return childArray\[childNum\]; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Node getParent()
>
> { return parent; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isLeaf()
>
> 480 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> ***LISTING 10.1*** Continued
>
> { return (childArray\[0\]==null) ? true : false; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int getNumItems()
>
> { return numItems; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public DataItem getItem(int index) // get DataItem at index
>
> { return itemArray\[index\]; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isFull()
>
> { return (numItems==ORDER-1) ? true : false; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int findItem(long key) // return index of
>
> { // item (within node)
>
> for(int j=0; j\<ORDER-1; j++) // if found,

{ // otherwise,

> if(itemArray\[j\] == null) // return -1 break;
>
> else if(itemArray\[j\].dData == key) return j;
>
> }
>
> return -1;
>
> } // end findItem

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public int insertItem(DataItem newItem)
>
> {
>
> // assumes node is not full
>
> numItems++; // will add new item long newKey = newItem.dData; // key
> of new item
>
> for(int j=ORDER-2; j\>=0; j\--) // start on right,
>
> { // examine items
>
> if(itemArray\[j\] == null) // if item null, continue; // go left one
> cell
>
> else // not null,
>
> { // get its key
>
> long itsKey = itemArray\[j\].dData;
>
> if(newKey \< itsKey) // if it's bigger itemArray\[j+1\] =
> itemArray\[j\]; // shift it right
>
> else
>
> {
>
> itemArray\[j+1\] = newItem; // insert new item
>
> Java Code for a 2-3-4 Tree 481
>
> ***LISTING 10.1*** Continued
>
> return j+1; // return index to
>
> } // new item
>
> } // end else (not null)
>
> } // end for // shifted all items, itemArray\[0\] = newItem; // insert
> new item return 0;
>
> } // end insertItem()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public DataItem removeItem() // remove largest item

> {
>
> // assumes node not empty
>
> DataItem temp = itemArray\[numItems-1\]; // save item
> itemArray\[numItems-1\] = null; // disconnect it numItems\--; // one
> less item
>
> return temp; // return item
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void displayNode() // format "/24/56/74/"

> {
>
> for(int j=0; j\<numItems; j++) itemArray\[j\].displayItem(); // "/56"
>
> System.out.println("/"); // final "/"
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> } // end class Node
>
> //////////////////////////////////////////////////////////////// class
> Tree234
>
> {

private Node root = new Node(); // make root node

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public int find(long key)
>
> {
>
> Node curNode = root; int childNumber; while(true)
>
> {
>
> if(( childNumber=curNode.findItem(key) ) != -1) return childNumber; //
> found it
>
> else if( curNode.isLeaf() )
>
> return -1; // can't find it else // search deeper
>
> 482 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> ***LISTING 10.1*** Continued
>
> curNode = getNextChild(curNode, key);
>
> } // end while
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> // insert a DataItem
>
> public void insert(long dValue)
>
> {
>
> Node curNode = root;
>
> DataItem tempItem = new DataItem(dValue);
>
> while(true)
>
> {
>
> if( curNode.isFull() ) // if node full,
>
> {
>
> split(curNode); // split it curNode = curNode.getParent(); // back up
>
> // search once curNode = getNextChild(curNode, dValue);
>
> } // end if(node is full)
>
> else if( curNode.isLeaf() ) // if node is leaf, break; // go insert
>
> // node is not full, not a leaf; so go to lower level else
>
> curNode = getNextChild(curNode, dValue);
>
> } // end while
>
> curNode.insertItem(tempItem); // insert new DataItem
>
> } // end insert()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void split(Node thisNode) // split the node
>
> {
>
> // assumes node is full DataItem itemB, itemC;
>
> Node parent, child2, child3; int itemIndex;
>
> itemC = thisNode.removeItem(); // remove items from itemB =
> thisNode.removeItem(); // this node
>
> child2 = thisNode.disconnectChild(2); // remove children child3 =
> thisNode.disconnectChild(3); // from this node
>
> Java Code for a 2-3-4 Tree 483
>
> ***LISTING 10.1*** Continued
>
> Node newRight = new Node(); // make new node if(thisNode==root) // if
> this is the root,
>
> {
>
> root = new Node(); // make new root
>
> parent = root; // root is our parent root.connectChild(0, thisNode);
> // connect to parent
>
> }
>
> else // this node not the root
>
> parent = thisNode.getParent(); // get parent
>
> // deal with parent
>
> itemIndex = parent.insertItem(itemB); // item B to parent int n =
> parent.getNumItems(); // total items?
>
> for(int j=n-1; j\>itemIndex; j\--) // move parent's
>
> { // connections
>
> Node temp = parent.disconnectChild(j); // one child
> parent.connectChild(j+1, temp); // to the right
>
> }
>
> // connect newRight to parent parent.connectChild(itemIndex+1,
> newRight);
>
> // deal with newRight
>
> newRight.insertItem(itemC); // item C to newRight
> newRight.connectChild(0, child2); // connect to 0 and 1
> newRight.connectChild(1, child3); // on newRight
>
> } // end split()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // gets appropriate child of node during search for value public Node
> getNextChild(Node theNode, long theValue)
>
> {
>
> int j;
>
> // assumes node is not empty, not full, not a leaf int numItems =
> theNode.getNumItems();
>
> for(j=0; j\<numItems; j++) // for each item in node
>
> { // are we less?
>
> if( theValue \< theNode.getItem(j).dData )

return theNode.getChild(j); // return left child

> } // end for // we're greater, so
>
> 484 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> ***LISTING 10.1*** Continued
>
> return theNode.getChild(j); // return right child
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayTree()
>
> {
>
> recDisplayTree(root, 0, 0);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> private void recDisplayTree(Node thisNode, int level,
>
> int childNumber)
>
> {
>
> System.out.print("level="+level+" child="+childNumber+" ");
> thisNode.displayNode(); // display this node
>
> // call ourselves for each child of this node int numItems =
> thisNode.getNumItems(); for(int j=0; j\<numItems+1; j++)
>
> {
>
> Node nextNode = thisNode.getChild(j); if(nextNode != null)
>
> recDisplayTree(nextNode, level+1, j); else
>
> return;
>
> }
>
> } // end recDisplayTree()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--\\
>
> } // end class Tree234
>
> //////////////////////////////////////////////////////////////// class
> Tree234App
>
> {
>
> public static void main(String\[\] args) throws IOException
>
> {
>
> long value;
>
> Tree234 theTree = new Tree234();
>
> theTree.insert(50); theTree.insert(40); theTree.insert(60);
> theTree.insert(30); theTree.insert(70);
>
> Java Code for a 2-3-4 Tree 485
>
> ***LISTING 10.1*** Continued
>
> while(true)
>
> {
>
> System.out.print("Enter first letter of "); System.out.print("show,
> insert, or find: "); char choice = getChar();
>
> switch(choice)
>
> {
>
> case 's':
>
> theTree.displayTree(); break;
>
> case 'i':
>
> System.out.print("Enter value to insert: "); value = getInt();
>
> theTree.insert(value); break;
>
> case 'f':
>
> System.out.print("Enter value to find: "); value = getInt();
>
> int found = theTree.find(value); if(found != -1)
>
> System.out.println("Found "+value); else
>
> System.out.println("Could not find "+value); break;
>
> default:
>
> System.out.print("Invalid entry\\n");
>
> } // end switch
>
> } // end while
>
> } // end main()
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static String getString() throws IOException
>
> {
>
> InputStreamReader isr = new InputStreamReader(System.in);
> BufferedReader br = new BufferedReader(isr);
>
> String s = br.readLine(); return s;
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static char getChar() throws IOException
>
> {
>
> String s = getString();
>
> 486 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> ***LISTING 10.1*** Continued
>
> return s.charAt(0);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public static int getInt() throws IOException
>
> {
>
> String s = getString(); return Integer.parseInt(s);
>
> }
>
> //\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Tree234App
>
> ////////////////////////////////////////////////////////////////

#### 2-3-4 Trees and Red-Black Trees

> At this point 2-3-4 trees and red-black trees (described in Chapter 9)
> probably seem like entirely different entities. However, it turns out
> that in a certain sense they are completely equivalent. One can be
> transformed into the other by the application of a few simple rules,
> and even the operations needed to keep them balanced are equiv- alent.
> Mathematicians would say they were *isomorphic*.
>
> You probably won't ever need to transform a 2-3-4 tree into a
> red-black tree, but equivalence of these structures casts additional
> light on their operation and is useful in analyzing their efficiency.
>
> Historically, the 2-3-4 tree was developed first; later the red-black
> tree evolved from it.

##### Transformation from 2-3-4 to Red-Black

> A 2-3-4 tree can be transformed into a red-black tree by applying
> three rules, as shown in Figure 10.13.

-   Transform any 2-node in the 2-3-4 tree into a black node in the
    red-black tree. This is shown in Figure 10.13a.

-   Transform any 3-node into a child node and a parent node, as shown
    in Figure 10.13b. The child node has two children of its own: either
    W and X or X and

    Y.  The parent has one other child: either Y or W. It doesn't matter
        which item becomes the child and which the parent. The child is
        colored red and the parent is colored black.

> 2-3-4 Trees and Red-Black Trees 487

-   Transform any 4-node into a parent and two children, as shown in
    Figure 10.13c. The first child has its own children W and X; the
    second child has chil- dren Y and Z. As before, the children are
    colored red and the parent is black.

    a.  2-Node

> ![](media/image27.png)Black
>
> ![](media/image30.png)W X W X

![](media/image31.png)

> ![](media/image38.png)a)

Red

> W X Y Z
>
> ***FIGURE 10.13*** Transformations: 2-3-4 to red-black.
>
> Figure 10.14 shows a 2-3-4 tree and the corresponding red-black tree
> obtained by applying these transformations. Dotted lines surround the
> subtrees that were made from 3-nodes and 4-nodes. The red-black rules
> are automatically satisfied by the transformation. Check that this is
> so: Two red nodes are never connected, and there is the same number of
> black nodes on every path from root to leaf (or null child).
>
> You can say that a 3-node in a 2-3-4 tree is equivalent to a parent
> with a red child in a red-black tree, and a 4-node is equivalent to a
> parent with two red children. It follows that a black parent with a
> black child in a red-black tree does *not* represent a 3-node in a
> 2-3-4 tree; it simply represents a 2-node with another 2-node child.
>
> Similarly, a black parent with two black children does not represent a
> 4-node.
>
> 488 **CHAPTER 10** 2-3-4 Trees and External Storage

a)  ![](media/image43.png)2-3-4 tree

b)  Red-black tree

![](media/image44.png)d Node

> ***FIGURE 10.14*** A 2-3-4 tree and its red-black equivalent.

##### Operational Equivalence

> Not only does the structure of a red-black tree correspond to a 2-3-4
> tree, but the operations applied to these two kinds of trees are also
> equivalent. In a 2-3-4 tree the tree is kept balanced using node
> splits. In a red-black tree the two balancing methods are color flips
> and rotations.

####### 4-Node Splits and Color Flips

> As you descend a 2-3-4 tree searching for the insertion point for a
> new node, you split each 4-node into two 2-nodes. In a red-black tree
> you perform color flips. How are these operations equivalent?
>
> In Figure 10.15a we show a 4-node in a 2-3-4 tree before it is split;
> Figure 10.15b shows the situation after the split. The 2-node that was
> the parent of the 4-node becomes a 3-node.
>
> In Figure 10.15c we show the red-black equivalent to the 2-3-4 tree in
> 10.15a. The dotted line surrounds the equivalent of the 4-node. A
> color flip results in the red- black tree of Figure 10.15d. Now nodes
> 40 and 60 are black and 50 is red. Thus, 50 and its parent form the
> equivalent of a 3-node, as shown by the dotted line. This is the same
> 3-node formed by the node split in Figure 10.15b.
>
> 2-3-4 Trees and Red-Black Trees 489

![](media/image63.png)

> ![](media/image65.png)![](media/image73.png)***FIGURE 10.15*** 4-node
> split and color flip.
>
> Thus, we see that splitting a 4-node during the insertion process in a
> 2-3-4 tree is equivalent to performing color flips during the
> insertion process in a red-black tree.

####### 3-Node Splits and Rotations

> When a 3-node in a 2-3-4 tree is transformed into its red-black
> equivalent, two arrangements are possible, as we showed earlier in
> Figure 10.13b. Either of the two data items can become the parent.
> Depending on which one is chosen, the child will be either a left
> child or a right child, and the slant of the line connecting parent
> and child will be either left or right.
>
> Both arrangements are valid; however, they may not contribute equally
> to balancing the tree. Let's look at the situation in a slightly
> larger context.
>
> Figure 10.16a shows a 2-3-4 tree, and 10.16b and 10.16c show two
> equivalent red- black trees derived from the 2-3-4 tree by applying
> the transformation rules. The difference between them is the choice of
> which of the two data items in the 3-node to make the parent: in b) 80
> is the parent; in c) it's 70.
>
> 490 **CHAPTER 10** 2-3-4 Trees and External Storage

a)  ![](media/image80.png)2-3-4 tree

b)  Left slant

> 80 Color change
>
> Color change 70
>
> 85
>
> Rotation
>
> 50 75
>
> 40 60

c)  ![](media/image90.png)Right slant

> 70
>
> Black node [ ]{.underline} 50 80
>
> Red node [ ]{.underline}

40 60

> 75 85
>
> ***FIGURE 10.16*** 3-node and rotation.
>
> Although these arrangements are equally valid, you can see that the
> tree in b) is not balanced, while that in c) is. Given the red-black
> tree in b), we would want to rotate it to the right (and perform two
> color changes) to balance it. Amazingly, this rota- tion results in
> the exact same tree shown in c).
>
> Thus, we see an equivalence between rotations in red-black trees and
> the choice of which node to make the parent when transforming 2-3-4
> trees to red-black trees. Although we don't show it, a similar
> equivalence can be seen for the double rotation necessary for inside
> grandchildren.

Efficiency of 2-3-4 Trees 491

#### Efficiency of 2-3-4 Trees

> It's harder to analyze the efficiency of a 2-3-4 tree than a red-black
> tree, but the equivalence of red-black trees and 2-3-4 trees gives us
> a starting point.

##### Speed

> As we saw in Chapter 8, in a red-black tree one node on each level
> must be visited during a search, whether to find an existing node or
> insert a new one. The number of levels in a red-black tree (a balanced
> binary tree) is about log2(N+1), so search times are proportional to
> this.
>
> One node must be visited at each level in a 2-3-4 tree as well, but
> the 2-3-4 tree is shorter (has fewer levels) than a red-black tree
> with the same number of data items. Refer to Figure 10.14, where the
> 2-3-4 tree has three levels and the red-black tree has five.
>
> More specifically, in 2-3-4 trees there are up to four children per
> node. If every node were full, the height of the tree would be
> proportional to log4N. Logarithms to the base 2 and to the base 4
> differ by a constant factor of 2. Thus, the height of a 2-3-4 tree
> would be about half that of a red-black tree, provided that all the
> nodes were full. Since they aren't all full, the height of the 2-3-4
> tree is somewhere between log2(N+1) and log2(N+1)/2. The reduced
> height of the 2-3-4 tree decreases search times slightly compared with
> red-black trees.
>
> On the other hand, there are more items to examine in each node, which
> increases the search time. Because the data items in the node are
> examined using a linear search, this multiplies the search times by an
> amount proportional to M, the average number of items per node. The
> result is a search time proportional to M\*log4N.
>
> Some nodes contain one item, some two, and some three. If we estimate
> that the average is two, search times will be proportional to
> 2\*log4N. This is a small constant number that can be ignored in Big O
> notation.
>
> Thus, for 2-3-4 trees the increased number of items per node tends to
> cancel out the decreased height of the tree. The search times for a
> 2-3-4 tree and for a balanced binary tree such as a red-black tree are
> approximately equal, and are both O(logN).

##### Storage Requirements

> Each node in a 2-3-4 tree contains storage for three references to
> data items and four references to its children. This space may be in
> the form of arrays, as shown in tree234.java, or of individual
> variables. Not all this storage is used. A node with only one data
> item will waste 2/3 of the space for data and 1/2 the space for
> children. A node with two data items will waste 1/3 of the space for
> data and 1/4 of the space for children; or put another way, it will
> use 5/7 of the available space.
>
> 492 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> If we take two data items per node as the average utilization, about
> 2/7 of the available storage is wasted.
>
> You might imagine using linked lists instead of arrays to hold the
> child and data references, but the overhead of the linked list
> compared with an array, for only three or four items, would probably
> not make this a worthwhile approach.
>
> Because they're balanced, red-black trees contain few nodes that have
> only one child, so almost all the storage for child references is
> used. Also, every node contains the maximum number of data items,
> which is one. This makes red-black trees more effi- cient than 2-3-4
> trees in terms of memory usage.
>
> In Java, which stores references to objects instead of the objects
> themselves, this difference in storage between 2-3-4 trees and
> red-black trees may not be important, and the programming is certainly
> simpler for 2-3-4 trees. However, in languages that don't use
> references this way, the difference in storage efficiency between
> red-black trees and 2-3-4 trees may be significant.

#### 2-3 Trees

> We'll discuss 2-3 trees briefly here because they are historically
> important and because they are still used in many applications. Also,
> some of the techniques used with 2-3 trees are applicable to B-trees,
> which we'll examine in the next section.
>
> Finally, it's interesting to see how a small change in the number of
> children per node can cause a large change in the tree's algorithms.

1.  trees are similar to 2-3-4 trees except that, as you might have
    guessed from the name, they hold one less data item and have one
    less child. They were the first multiway tree, invented by J. E.
    Hopcroft in 1970. B-trees (of which the 2-3-4 tree is a special
    case) were not invented until 1972.

> In many respects the operation of 2-3 trees is similar to that of
> 2-3-4 trees. Nodes can hold one or two data items and can have zero,
> one, two, or three children.
>
> Otherwise, the arrangement of the key values of the parent and its
> children is the same. Inserting a data item into a node is potentially
> simplified because fewer comparisons and moves are potentially
> necessary. As in 2-3-4 trees, all insertions are made into leaf nodes,
> and all leaf nodes are on the bottom level.

##### Node Splits

> Searching for an existing data item is handled just as it is in a
> 2-3-4 tree except for the number of data items and children. You might
> guess that insertion is also similar to a 2-3-4 tree, but there is a
> surprising difference in the way splits are handled.
>
> Here's why the splits are so different. In either kind of tree a node
> split requires three data items: one to be kept in the node being
> split, one to move right into the new

2-3 Trees 493

> node, and one to move up to the parent node. A full node in a 2-3-4
> tree has three data items, which are moved to these three
> destinations. However, a full node in a 2- 3 tree has only two data
> items. Where can we get a third item? We must use the new item: the
> one being inserted in the tree.
>
> In a 2-3-4 tree the new item is inserted after all the splits have
> taken place. In the 2-3 tree it must participate in the split. It must
> be inserted in a leaf, so no splits are possible on the way down. If
> the leaf node where the new item should be inserted is not full, the
> new item can be inserted immediately, but if the leaf node is full, it
> must be split. Its two items and the new item are distributed among
> these three nodes: the existing node, the new node, and the parent
> node. If the parent is not full, the operation is complete (after
> connecting the new node). This situation is shown in Figure 10.17.

a.  ![](media/image101.png)![](media/image102.png)b)

75

> 75 85
>
> 70 80 90 70 80 90
>
> 85
>
> ***FIGURE 10.17*** Insertion with non-full parent.
>
> However, if the parent is full, it too must be split. Its two items
> and the item passed up from its recently split child must be
> distributed among the parent, a new sibling of the parent, and the
> parent's parent. This situation is shown in Figure 10.18.
>
> ![](media/image102.png)![](media/image102.png)a) b)

50

> 50 85
>
> 75 85 75 95

70 80

> 90 95
>
> 70 80
>
> 90 100
>
> 100
>
> ***FIGURE 10.18*** Insertion with full parent.
>
> If the parent's parent (the grandparent of the leaf node) is full, it
> too must be split. The splitting process ripples upward until either a
> non-full parent or the root is encountered. If the root is full, a new
> root is created that is the parent of the old root, as shown in Figure
> 10.19.
>
> 494 **CHAPTER 10** 2-3-4 Trees and External Storage

a)  ![](media/image102.png)b)

![](media/image111.png)

> ***FIGURE 10.19*** Splitting the root.
>
> Figure 10.20 shows a node split that ripples up through a tree until
> it reaches the root.

![](media/image114.png)

<table>
<thead>
<tr class="header">
<th></th>
<th><blockquote>
<p>b)</p>
</blockquote></th>
<th></th>
<th></th>
<th></th>
<th><blockquote>
<p>50</p>
</blockquote></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>23</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><blockquote>
<p>85</p>
</blockquote></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td><blockquote>
<p>21</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>25</p>
</blockquote></td>
<td></td>
<td></td>
<td></td>
<td><blockquote>
<p>75</p>
</blockquote></td>
<td></td>
<td></td>
<td></td>
<td><blockquote>
<p>95</p>
</blockquote></td>
<td></td>
</tr>
<tr class="odd">
<td><blockquote>
<p>20</p>
</blockquote></td>
<td><blockquote>
<p>22</p>
</blockquote></td>
<td><blockquote>
<p>24</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>30</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>70</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>80</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>90</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>100</p>
</blockquote></td>
</tr>
</tbody>
</table>

> ![](media/image115.png){width="3.9567104111986002in"
> height="1.2708333333333333in"}***FIGURE 10.20*** Splits rippling up a
> tree.

##### Implementation

> We'll leave a complete Java implementation of a 2-3 tree as an
> exercise. However, we'll finish with some hints on how to handle
> splits. This is only one approach (another involves allowing each node
> to hold a phantom fourth child).
>
> On the way down the insertion routine doesn't care if the nodes it
> encounters are full or not. It searches down through the tree until it
> finds the appropriate leaf. If the leaf is not full, it inserts the
> new value. However, if the leaf is full, it must rearrange the tree to
> make room. To do this, it calls a split() method. Arguments to this

2-3 Trees 495

> method can be the full leaf node and the new item. It will be the
> responsibility of
>
> split() to make the split and insert the new node in the new leaf.
>
> If split() finds that the leaf's parent is full, it calls itself
> recursively to split the parent. It keeps calling itself until a
> non-full leaf or the root is found. The return value of split() is the
> new right node, which can be used by the previous incarnation of
> split().
>
> Coding the splitting process is complicated by several factors. In a
> 2-3-4 tree the three items to be distributed are already sorted, but
> in the 2-3 tree the new item's key must be compared with the two items
> in the leaf; the three are then distributed according to the results
> of the comparison.
>
> Also, splitting a parent creates a second parent, so now we have a
> left (the original) parent and a new right parent. We need to change
> the connections from a single parent with three children to two
> parents with two children each. There are three cases, depending on
> which child (0, 1, or 2) is being split. This situation is shown in
> Figure 10.21.

a)  ![](media/image116.png)Splitting Child 0

> ![](media/image117.png)

Child 0

> Child 1
>
> Child 2
>
> Child 0
>
> New Child 1 Child 2

b)  ![](media/image122.png)Splitting Child 1

> ![](media/image123.png)

Child 0

> Child 1
>
> Child 2
>
> Child 0
>
> Child 1 New Child 2

c)  ![](media/image129.png)Splitting Child 2

> ![](media/image121.png)

Child 0

> Child 1
>
> Child 2
>
> Child 0
>
> Child 1 Child 2 New
>
> ***FIGURE 10.21*** Connecting the children.
>
> 496 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> In this figure the new nodes created as the result of a split are
> shaded, and new connections are shown as wiggly lines.

#### External Storage

1.  trees are examples of multiway trees, which have more than two
    children and more than one data item. Another kind of multiway tree,
    the B-tree, is useful when data resides in external storage.
    *External storage* typically refers to some kind of disk system,
    such as the hard disk found in most desktop computers or servers.

> In this section we'll begin by describing various aspects of external
> file handling. We'll talk about a simple approach to organizing
> external data: sequential ordering. Finally, we'll discuss B-trees and
> explain why they work so well with disk files. We'll finish with
> another approach to external storage, indexing, which can be used
> alone or with a B-tree.
>
> We'll also touch on other aspects of external storage, such as
> searching techniques. In the next chapter we'll mention a different
> approach to external storage: hashing.
>
> The details of external storage techniques are dependent on the
> operating system, language, and even the hardware used in a particular
> installation. As a consequence, our discussion in this section will be
> considerably more general than for most topics in this book.

##### Accessing External Data

> The data structures we've discussed so far are all based on the
> assumption that data is stored entirely in main memory (often called
> RAM, for Random Access Memory). However, in many situations the amount
> of data to be processed is too large to fit in main memory all at
> once. In this case a different kind of storage is necessary. Disk
> files generally have a much larger capacity than main memory; this is
> made possible by their lower cost per byte of storage.
>
> Of course, disk files have another advantage: their permanence. When
> you turn off your computer (or the power fails), the data in main
> memory is lost. Disk files can retain data indefinitely with the power
> off. However, it's mostly the size difference that we'll be involved
> with here.
>
> The disadvantage of external storage is that it's much slower than
> main memory. This speed difference means that different techniques
> must be used to handle it efficiently.
>
> As an example of external storage, imagine that you're writing a
> database program to handle the data found in the phone book for a
> medium-sized city---perhaps 500,000 entries. Each entry includes a
> name, address, phone number, and various other data

External Storage 497

> used internally by the phone company. Let's say an entry is stored as
> a record requir- ing 512 bytes. The result is a file size of 500,000 ×
> 512, which is 256,000,000 bytes or 256 megabytes. We'll assume that on
> the target machine this is too large to fit in main memory but small
> enough to fit on your disk drive.
>
> Thus, you have a large amount of data on your disk drive. How do you
> structure it to provide the usual desirable characteristics: quick
> search, insertion, and deletion?
>
> In investigating the answers, you must keep in mind two facts. First,
> accessing data on a disk drive is much slower than accessing it in
> main memory. Second, you must access many records at once. Let's
> explore these points.

####### Very Slow Access

> A computer's main memory works electronically. Any byte can be
> accessed just as fast as any other byte, in a fraction of a
> microsecond (a millionth of a second).
>
> Things are more complicated with disk drives. Data is arranged in
> circular tracks on a spinning disk, something like the tracks on a
> compact disc (CD) or the grooves in an old-style phonograph record.
>
> To access a particular piece of data on a disk drive, the read-write
> head must first be moved to the correct track. This is done with a
> stepping motor or similar device; it's a mechanical activity that
> requires several milliseconds (thousandths of a second).
>
> Once the correct track is found, the read-write head must wait for the
> data to rotate into position. On the average, this takes half a
> revolution. Even if the disk is spin- ning at 10,000 revolutions per
> minute, about 3 more milliseconds pass before the data can be read.
> Once the read-write head is positioned, the actual reading (or
> writing) process begins; this might take a few more milliseconds.
>
> Thus, disk access times of around 10 milliseconds are common. This is
> something like 10,000 times slower than main memory.
>
> Technological progress is reducing disk access times every year, but
> main memory access times are being reduced faster, so the disparity
> between disk access and main memory access times will grow even larger
> in the future.

####### One Block at a Time

> When the read-write head is correctly positioned and the reading (or
> writing) process begins, the drive can transfer a large amount of data
> to main memory fairly quickly. For this reason, and to simplify the
> drive control mechanism, data is stored on the disk in chunks called
> *blocks*, *pages*, *allocation units*, or some other name, depending
> on the system. We'll call them blocks.
>
> The disk drive always reads or writes a minimum of one block of data
> at a time. Block size varies, depending on the operating system, the
> size of the disk drive, and other factors, but it is usually a power
> of 2. For our phone book example, let's
>
> 498 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> assume a block size of 8,192 bytes (213). Thus, our phone book
> database will require 256,000,000 bytes divided by 8,192 bytes per
> block, which is 31,250 blocks.
>
> Your software is most efficient when it specifies a read or write
> operation that's a multiple of the block size. If you ask to read 100
> bytes, the system will read one block, 8,192 bytes, and throw away all
> but 100. Or if you ask to read 8,200 bytes, it will read two blocks,
> or 16,384 bytes, and throw away almost half of them. By orga- nizing
> your software so that it works with a block of data at a time, you can
> optimize its performance.
>
> Assuming our phone book record size of 512 bytes, you can store 16
> records in a block (8,192 divided by 512), as shown in Figure 10.22.
> Thus, for maximum effi- ciency it's important to read 16 records at a
> time (or multiples of this number).
>
> File = 256,000,000 bytes

+------------+--------------+--------------+--+--+
| Last name  | > Last name  | > Last name  |  |
+============+==============+==============+==+==+
| First name | > First name | > First name |  |
+------------+--------------+--------------+--+--+
| Address    | > Address    | > Address    |  |
+------------+--------------+--------------+--+--+
| Phone \#   | > Phone \#   | > Phone \#   |  |  |
+------------+--------------+--------------+--+--+
| > Etc.     | > Etc.       | > Etc.       |  |
+------------+--------------+--------------+--+--+

> 0 1 2 15
>
> 512 Bytes
>
> ***FIGURE 10.22*** Blocks and records.
>
> Notice that it's also useful to make your record size a multiple of 2.
> That way, an integral number of them will always fit in a block.
>
> Of course, the sizes shown in our phone book example for records,
> blocks, and so on are only illustrative; they will vary widely
> depending on the number and size of records and other software and
> hardware constraints. Blocks containing hundreds of records are
> common, and records may be much larger or smaller than 512 bytes.

External Storage 499

> Once the read-write head is positioned as described earlier, reading a
> block is fairly fast, requiring only a few milliseconds. Thus, a disk
> access to read or write a block is not very dependent on the size of
> the block. It follows that the larger the block, the more efficiently
> you can read or write a single record (assuming you use all the
> records in the block).

##### Sequential Ordering

> One way to arrange the phone book data in the disk file would be to
> order all the records according to some key, say alphabetically by
> last name. The record for Joseph Aardvark would come first, and so on.
> This is shown in Figure 10.23.
>
> Block 0 Block 1
>
> ***FIGURE 10.23*** Sequential ordering.

####### Searching

> To search a sequentially ordered file for a particular last name such
> as Smith, you could use a binary search. You would start by reading a
> block of records from the middle of the file. The 16 records in the
> block are all read at once into an 8,192-byte buffer in main memory.
>
> If the keys of these records are too early in the alphabet (Keller,
> for example), you would go to the 3/4 point in the file (Prince) and
> read a block there; if the keys were too late, you'd go to the 1/4
> point (DeLeon). By continually dividing the range in half, you would
> eventually find the record you were looking for.
>
> As we saw in Chapter 2, a binary search in main memory takes log2N
> comparisons, which for 500,000 items would be about 19. If every
> comparison took, say 10 microseconds, this would be 190 microseconds,
> or about 2/10,000 of a second, less than an eye blink.
>
> However, we're now dealing with data stored on a disk. Because each
> disk access is so time-consuming, it's more important to focus on how
> many disk accesses are neces- sary than on how many individual records
> there are. The time to read a block of records will be very much
> larger than the time to search the 16 records in the block once
> they're in memory.
>
> Disk accesses are much slower than memory accesses, but on the other
> hand we access a block at a time, and there are far fewer blocks than
> records. In our example there are 31,250 blocks. Log2 of this number
> is about 15, so in theory we'll need about 15 disk accesses to find
> the record we want.
>
> 500 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> In practice this number is reduced somewhat because we read 16 records
> at once. In the beginning stages of a binary search, it doesn't help
> to have multiple records in memory because the next access will be in
> a distant part of the file. However, when we get close to the desired
> record, the next record we want may already be in memory because it's
> part of the same block of 16. This may reduce the number of
> comparisons by two or so. Thus, we'll need about 13 disk accesses
> (15--2), which at 10 milliseconds per access requires about 130
> milliseconds, or 1⁄7 second. This is much slower than in-memory
> access, but still not too bad.

####### Insertion

> Unfortunately, the picture is much worse if we want to insert (or
> delete) an item from a sequentially ordered file. Because the data is
> ordered, both operations require moving half the records on the
> average, and therefore about half the blocks.
>
> Moving each block requires two disk accesses: one read and one write.
> When the insertion point is found, the block containing it is read
> into a memory buffer. The last record in the block is saved, and the
> appropriate number of records are shifted up to make room for the new
> one, which is inserted. Then the buffer contents are written back to
> the disk file.
>
> Next, the second block is read into the buffer. Its last record is
> saved, all the other records are shifted up, and the last record from
> the previous block is inserted at the beginning of the buffer. Then
> the buffer contents are again written back to disk. This process
> continues until all the blocks beyond the insertion point have been
> rewritten.
>
> Assuming there are 31,250 blocks, we must read and write (on the
> average) 15,625 of them, which at 10 milliseconds per read and write
> requires more than 5 minutes to insert a single entry. This won't be
> satisfactory if you have thousands of new names to add to the phone
> book.
>
> Another problem with the sequential ordering is that it works quickly
> for only one key. Our file is arranged by last names. But suppose you
> wanted to search for a particular phone number. You can't use a binary
> search because the data is ordered by name. You would need to go
> through the entire file, block by block, using sequential access. This
> search would require reading an average of half the blocks, which
> would require about 2.5 minutes, very poor performance for a simple
> search. It would be nice to have a more efficient way to store disk
> data.

##### B-Trees

> How can the records of a file be arranged to provide fast search,
> insertion, and dele- tion times? We've seen that trees are a good
> approach to organizing in-memory data. Will trees work with files?

External Storage 501

> They will, but a different kind of tree must be used for external data
> than for in- memory data. The appropriate tree is a multiway tree
> somewhat like a 2-3-4 tree, but with many more data items per node;
> it's called a *B-tree*. B-trees were first conceived as appropriate
> structures for external storage by R. Bayer and E. M. McCreight in
> 1972. (Strictly speaking, 2-3 trees and 2-3-4 trees are B-trees of
> order 3 and 4, respec- tively, but the term *B-tree* is often taken to
> mean many more children per node.)

####### One Block Per Node

> Why do we need so many items per node? We've seen that disk access is
> most effi- cient when data is read or written one block at a time. In
> a tree, the entity contain- ing data is a node. It makes sense then to
> store an entire block of data in each node of the tree. This way,
> reading a node accesses a maximum amount of data in the shortest time.
>
> How much data can be put in a node? When we simply stored the 512-byte
> data records for our phone book example, we could fit 16 into an
> 8,192-byte block.
>
> In a tree, however, we also need to store the links to other nodes
> (which means links to other blocks, because a node corresponds to a
> block). In an in-memory tree, such as those we've discussed in
> previous chapters, these links are references (or pointers, in
> languages like C++) to nodes in other parts of memory. For a tree
> stored in a disk file, the links are block numbers in a file (from 0
> to 31,249, in our phone book example). For block numbers we can use a
> field of type int, a 4-byte type, which can point to more than 2
> billion possible blocks, which is probably enough for most files.
>
> Now we can no longer squeeze 16 512-byte records into a block because
> we need room for the links to child nodes. We could reduce the number
> of records to 15 to make room for the links, but it's most efficient
> to have an even number of records per node, so (after appropriate
> negotiation with management) we reduce the record size to 507 bytes.
> There will be 17 child links (one more than the number of data items)
> so the links will require 68 bytes (17 × 4). This leaves room for 16
> 507-byte records with 12 bytes left over (507 × 16 + 68 = 8,180). A
> block in such a tree, and the corresponding node representation, is
> shown in Figure 10.24.
>
> Within each node the data is ordered sequentially by key, as in a
> 2-3-4 tree. In fact, the structure of a B-tree is similar to that of a
> 2-3-4 tree, except that there are more data items per node and more
> links to children. The order of a B-tree is the number of children
> each node can potentially have. In our example this is 17, so the tree
> is an order 17 B-tree.

####### Searching

> A search for a record with a specified key is carried out in much the
> same way it is in an in-memory 2-3-4 tree. First, the block containing
> the root is read into memory.
>
> The search algorithm then starts examining each of the 15 records (or,
> if it's not full,
>
> 502 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> as many as the node actually holds), starting at 0. When it finds a
> record with a greater key, it knows to go to the child whose link lies
> between this record and the preceding one.
>
> Block numbers
>
> 1 2 15

Smith

> Smyth
>
> Smoot
>
> Snell
>
> (other data)
>
> (other data)
>
> (other data)
>
> (other data)
>
> 15 0 1
>
> 0 1 2 3 15 16
>
> 0 1 2 15
>
> ***FIGURE 10.24*** A node in a B-tree of order 17.
>
> This process continues until the correct node is found. If a leaf is
> reached without finding the specified key, the search is unsuccessful.

####### Insertion

> The insertion process in a B-tree is more like an insertion in a 2-3
> tree than in a 2-3-4 tree. Recall that in a 2-3-4 tree many nodes are
> not full, and in fact contain only one data item. In particular, a
> node split always produces two nodes with one item in each. This is
> not an optimum approach in a B-tree.
>
> In a B-tree it's important to keep the nodes as full as possible so
> that each disk access, which reads an entire node, can acquire the
> maximum amount of data. To help achieve this end, the insertion
> process differs from that of 2-3-4 trees in three ways:

-   A node split divides the data items equally: Half go to the newly
    created node, and half remain in the old one.

-   Node splits are performed from the bottom up, as in a 2-3 tree,
    rather than from the top down.

External Storage 503

-   Again, as in a 2-3 tree, it's not the middle item in a node that's
    promoted upward, but the middle item in the sequence formed from the
    items in the node plus the new item.

> We'll demonstrate these features of the insertion process by building
> a small B-tree, as shown in Figure 10.25. There isn't room to show a
> realistic number of records per node, so we'll show only four; thus,
> the tree is an order 5 B-tree.
>
> Figure 10.25a shows a root node that's already full; items with keys
> 20, 40, 60, and 80 have already been inserted into the tree. A new
> data item with a key of 70 is inserted, resulting in a node split.
> Here's how the split is accomplished. Because it's the root that's
> being split, two new nodes are created (as in a 2-3-4 tree): a new
> root and a new node to the right of the one being split.
>
> To decide where the data items go, the insertion algorithm arranges
> their five keys in order, in an internal buffer. Four of these keys
> are from the node being split, and the fifth is from the new item
> being inserted. In Figure 10.25, these five-item sequences are shown
> to the side of the tree. In this first step the sequence 20, 40, 60,
> 70, 80 is shown.
>
> The center item in this sequence, 60 in this first step, is promoted
> to the new root node. (In the figure, an arrow indicates that the
> center item will go upward.) All the items to the left of center
> remain in the node being split, and all the items to the right go into
> the new right-hand node. The result is shown in Figure 10.25b. (In our
> phone book example, eight items would go into each child node, rather
> than the two shown in the figure.)
>
> In Figure 10.25b we insert two more items, 10 and 30. They fill up the
> left child, as shown in Figure 10.25c. The next item to be inserted,
> 15, splits this left child, with the result shown in Figure 10.25d.
> Here the 20 has been promoted upward into the root.
>
> Next, three items---75, 85, and 90---are inserted into the tree. The
> first two fill up the third child, and the third splits it, causing
> the creation of a new node and the promotion of the middle item, 80,
> to the root. The result is shown in Figure 10.25e.
>
> Again three items---25, 35, and 50---are added to the tree. The first
> two items fill up the second child, and the third one splits it,
> causing the creation of a new node and the promotion of the middle
> item, 35, to the root, as shown in Figure 10.25f.
>
> Now the root is full. However, subsequent insertions don't necessarily
> cause a node split, because nodes are split only when a new item is
> inserted into a full node, not when a full node is encountered in the
> search down the tree. Thus, 22 and 27 are inserted in the second child
> without causing any splits, as shown in Figure 10.25g.
>
> ![](media/image131.png)![](media/image132.png)504 **CHAPTER 10** 2-3-4
> Trees and External Storage
>
> 20 40 60 70 80
>
> 10 15 20 30 40
>
> 70 75 80 85 90

50

> ![](media/image133.png)***FIGURE 10.25*** Building a B-tree.

External Storage 505

> g)

![](media/image134.png)20 35 60 80

32

> 22 25 27 30 32
>
> 10 15 22 25 27 30 40 50 70 75 85 90
>
> h)
>
> ![](media/image135.png)
>
> i)
>
> However, the next item to be inserted, 32, does cause a split; in fact
> it causes two of them. The second node child is full, so it's split,
> as shown in Figure 10.25h.
>
> However, the 27, promoted from this split, has no place to go because
> the root is full. Therefore, the root must be split as well, resulting
> in the arrangement of Figure 10.25i.
>
> Notice that throughout the insertion process no node (except the root)
> is ever less than half full, and many are more than half full. As we
> noted, this promotes effi- ciency because a file access that reads a
> node always acquires a substantial amount of data.

####### Efficiency of B-Trees

> Because there are so many records per node, and so many nodes per
> level, operations on B-trees are very fast, considering that the data
> is stored on disk. In our phone book example there are 500,000
> records. All the nodes in the B-tree are at least half full, so they
> contain at least 8 records and 9 links to children. The height of the
> tree is thus somewhat less than log9N (logarithm to the base 9 of N),
> where N is 500,000.
>
> This is 5.972, so there will be about 6 levels in the tree.
>
> 506 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> Thus, using a B-tree, only six disk accesses are necessary to find any
> record in a file of 500,000 records. At 10 milliseconds per access,
> this takes about 60 milliseconds, or 6/100 of a second. This is
> dramatically faster than the binary search of a sequentially ordered
> file.
>
> The more records there are in a node, the fewer levels there are in
> the tree. We've seen that there are 6 levels in our B-tree, even
> though the nodes hold only 16 records. In contrast, a binary tree with
> 500,000 items would have about 19 levels, and a 2-3-4 tree would have
> 10. If we use blocks with hundreds of records, we can reduce the
> number of levels in the tree and further improve access times.
>
> Although searching is faster in B-trees than in sequentially ordered
> disk files, it's for insertion and deletion that B-trees show the
> greatest advantage.
>
> Let's first consider a B-tree insertion in which no nodes need to be
> split. This is the most likely scenario, because of the large number
> of records per node. In our phone book example, as we've seen, only 6
> accesses are required to find the insertion point. Then one more
> access is required to write the block containing the newly inserted
> record back to the disk, for a total of 7 accesses.
>
> Next let's see how things look if a node must be split. The node being
> split must be read, have half its records removed, and be written back
> to disk. The newly created node must be written to the disk, and the
> parent must be read and, following the insertion of the promoted
> record, written back to disk. This is 5 accesses in addition to the 6
> necessary to find the insertion point, for a total of 12. This is a
> major improvement over the 500,000 accesses required for insertion in
> a sequential file.
>
> In some versions of the B-tree, only leaf nodes contain records.
> Non-leaf nodes contain only keys and block numbers. This may result in
> faster operation because each block can hold many more block numbers.
> The resulting higher-order tree will have fewer levels, and access
> speed will be increased. However, programming may be complicated
> because there are two kinds of nodes: leaves and non-leaves.

##### Indexing

> A different approach to speeding up file access is to store records in
> sequential order but use a file *index* along with the data itself. A
> file index is a list of key/block pairs, arranged with the keys in
> order. Recall that in our original phone book example we had 500,000
> records of 512 bytes each, stored 16 records to a block, in 31,250
> blocks. Assuming our search key is the last name, every entry in the
> index contains two items:

-   The key, like Jones.

-   The number of the block where the Jones record is located within the
    file. These numbers run from 0 to 31,249.

External Storage 507

> Let's say we use a string 28 bytes long for the key (big enough for
> most last names) and 4 bytes for the block number (a type int in
> Java). Each entry in our index thus requires 32 bytes. This is only
> 1/16 the amount necessary for each record.
>
> The entries in the index are arranged sequentially by last name. The
> original records on the disk can be arranged in any convenient order.
> This usually means that new records are simply appended to the end of
> the file, so the records are ordered by time of insertion. This
> arrangement is shown in Figure 10.26.

Block \#2385 Block \#2386

> 0 1 15 0 1 15 0

+---------+-----------+
| > Key   | > Block\# |
+=========+===========+
| > Jones | > 2,385   |
+---------+-----------+
| Jordan  | > 5,471   |
+---------+-----------+
| Joslyn  | > 1,802   |
+---------+-----------+
| Joyce   | > 7,429   |
+---------+-----------+
| > Jung  | > 3.423   |
+---------+-----------+

> ***FIGURE 10.26*** A file index.

####### Index File in Memory

> The index is much smaller than the file containing actual records. It
> may even be small enough to fit entirely in main memory. In our
> example there are 500,000 records. Each one has a 32-byte entry in the
> index, so the index will be 32 × 500,000, or 1,600,000 bytes long (1.6
> megabytes). In modern computers there's no problem fitting this in
> memory. The index can be stored on the disk but read into memory
> whenever the database program is started up. From then on, operations
> on the index can take place in memory. At the end of each day (or
> perhaps more frequently), the index can be written back to disk for
> permanent storage.

####### Searching

> The index-in-memory approach allows much faster operations on the
> phone book file than are possible with a file in which the records
> themselves are arranged sequentially. For example, a binary search
> requires 19 index accesses. At 20 microsec- onds per access, that's
> only about 4/10,000 of a second. Then there's (inevitably) the
>
> 508 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> time to read the actual record from the file, once its block number
> has been found in the index. However, this is only one disk access of
> (say) 10 milliseconds.

####### Insertion

> To insert a new item in an indexed file, two steps are necessary. We
> first insert the item's full record into the main file; then we insert
> an entry, consisting of the key and the block number where the new
> record is stored, into the index.
>
> Because the index is in sequential order, to insert a new item, we
> need to move half the index entries, on the average. Figuring 2
> microseconds to move a byte in memory, we have 250,000 times 32 times
> 2, or about 16 seconds to insert a new entry. This compares with 5
> minutes for the unindexed sequential file. (Note that we don't need to
> move any records in the main file; we simply append the new record at
> the end of the file.)
>
> Of course, you can use a more sophisticated approach to storing the
> index in memory. You could store it as a binary tree, 2-3-4 tree, or
> red-black tree, for example. Any of these would significantly reduce
> insertion and deletion times. In any case the index-in-memory approach
> is much faster than the sequential-file approach. In some cases it
> will also be faster than a B-tree.
>
> The only actual disk accesses necessary for an insertion into an
> indexed file involve the new record itself. Usually, the last block in
> the file is read into memory, the new record is appended, and the
> block is written back out. This process involves only two file
> accesses.

####### Multiple Indexes

> An advantage of the indexed approach is that multiple indexes, each
> with a different key, can be created for the same file. In one index
> the keys can be last names; in another, telephone numbers; in another,
> addresses. Because the indexes are small compared with the file, this
> doesn't increase the total data storage very much. Of course, it does
> present more of a challenge when items are deleted from the file
> because entries must be deleted from all the indexes, but we won't get
> into that here.

####### Index Too Large for Memory

> If the index is too large to fit in memory, it must be broken into
> blocks and stored on the disk. For large files storing the index
> itself as a B-tree may then be profitable. In the main file the
> records are stored in any convenient order.
>
> This arrangement can be very efficient. Appending records to the end
> of the main file is a fast operation, and inserting the index entry
> for the new record is also quick because the index is a tree. The
> result is very fast searching and insertion for large files.

External Storage 509

> Note that when an index is arranged as a B-tree, each node contains n
> child pointers and n-1 data items. The child pointers are the block
> numbers of other nodes in the index. The data items consist of a key
> value and a pointer to a block in the main file. Don't confuse these
> two kinds of block pointers.

##### Complex Search Criteria

> In complex searches the only practical approach may be to read every
> block in a file sequentially. Suppose in our phone book example we
> wanted a list of all entries in the phone book with first name Frank,
> who lived in Springfield, and who had a phone number with three 7
> digits in it. (These were perhaps clues found scrawled on a scrap of
> paper clutched in the hand of a victim of foul play.)
>
> A file organized by last names would be no help at all. Even if there
> were index files ordered by first names and cities, there would be no
> convenient way to find which files contained both Frank and
> Springfield. In such cases (which are quite common in many kinds of
> databases), the fastest approach is probably to read the file sequen-
> tially, block by block, checking each record to see whether it meets
> the criteria.

##### Sorting External Files

> Mergesort is the preferred algorithm for sorting external data. This
> is because, more so than most sorting techniques, disk accesses tend
> to occur in adjacent records rather than random parts of the file.
>
> Recall from Chapter 6, "Recursion," that mergesort works recursively
> by calling itself to sort smaller and smaller sequences. Once two of
> the smallest sequences (one byte each in the internal-memory version)
> have been sorted, they are then merged into a sorted sequence twice as
> long. Larger and larger sequences are merged, until eventu- ally the
> entire file is sorted.
>
> The approach for external storage is similar. However, the smallest
> sequence that can be read from the disk is a block of records. Thus, a
> two-stage process is necessary.
>
> In the first phase, a block is read, its records are sorted
> internally, and the resulting sorted block is written back to disk.
> The next block is similarly sorted and written back to disk. This
> process continues until all the blocks are internally sorted.
>
> In the second phase, two sorted blocks are read, merged into a
> two-block sequence, and written back to disk. This process continues
> until all pairs of blocks have been merged. Next, each pair of
> two-block sequences is merged into a four-block sequence. Each time,
> the size of the sorted sequences doubles, until the entire file is
> sorted.
>
> Figure 10.27 shows the mergesort process on an external file. The file
> consists of four blocks of four records each, for a total of 16
> records. Only three blocks can fit in
>
> 510 **CHAPTER 10** 2-3-4 Trees and External Storage
>
> internal memory. (Of course, all these sizes would be much larger in a
> real situation.) Figure 10.27 shows the file before sorting; the
> number in each record is its key value.

a)  Block Block Block Block

###### ![](media/image136.png){width="0.2818000874890639in" height="0.2604166666666667in"} 

> ***FIGURE 10.27*** Mergesort on an external file.
>
> File 1
>
> ![](media/image137.png)![](media/image138.png)File 2
>
> File 3
>
> ![](media/image142.png)File 2

####### Internal Sort of Blocks

> In the first phase all the blocks in the file are sorted internally.
> This is done by reading the block into memory and sorting it with any
> appropriate internal sorting algorithm, such as quicksort (or for
> smaller numbers of records Shellsort or insertion sort). The result of
> sorting the blocks internally is shown in Figure 10.27b.
>
> A second file may be used to hold the sorted blocks, and we assume
> that availability of external storage is not a problem. It's often
> desirable to avoid modifying the origi- nal file.

####### Merging

> In the second phase we want to merge the sorted blocks. In the first
> pass we merge every pair of blocks into a sorted two-block sequence.
> Thus, the two blocks 2-9-11-14

External Storage 511

> and 4-12-13-16 are merged into 2-4-9-11-12-13-14-16. Also, 3-5-10-15
> and 1-6-7-8 are merged into 1-3-5-6-7-8-10-15. The result is shown in
> Figure 10.27c. A third file is necessary to hold the result of this
> merge step.
>
> In the second pass, the two 8-record sequences are merged into a
> 16-record sequence, which can be written back to File 2, as shown in
> Figure 10.27d. Now the sort is complete. Of course, more merge steps
> would be required to sort larger files; the number of such steps is
> proportional to log2N. The merge steps can alternate between two files
> (File 2 and File 3 in Figure 10.22).

####### Internal Arrays

> Because the computer's internal memory has room for only three blocks,
> the merging process must take place in stages. Let's say there are
> three arrays, called arr1, arr2, and arr3, each of which can hold a
> block.
>
> In the first merge, block 2-9-11-14 is read into arr1, and 4-12-13-16
> is read into arr2. These two arrays are then mergesorted into arr3.
> However, because arr3 holds only one block, it becomes full before the
> sort is completed. When it becomes full, its contents are written to
> disk. The sort then continues, filling up arr3 again. This completes
> the sort, and arr3 is again written to disk. The following lists show
> the details of each of the three mergesorts.
>
> Mergesort 1:
>
> **1.** Read 2-9-11-14 into arr1.
>
> **2.** Read 4-12-13-16 into arr2.

3.  Merge 2, 4, 9, 11 into arr3; write to disk.

4.  Merge 12, 13, 14, 16 into arr3; write to disk.

> Mergesort 2:

1.  Read 3-5-10-15 into arr1.

2.  Read 1-6-7-8 into arr2.

3.  Merge 1, 3, 5, 6 into arr3; write to disk.

4.  Merge 7, 8, 10, 15 into arr3, write to disk.

> Mergesort 3:

1.  Read 2-4-9-11 into arr1.

2.  Read 1-3-5-6 into arr2.

3.  Merge 1, 2, 3, 4 into arr3; write to disk.

> 512 **CHAPTER 10** 2-3-4 Trees and External Storage

4.  Merge 5, 6 into arr3 (arr2 is now empty).

5.  Read 7-8-10-15 into arr2.

6.  Merge 7, 8 into arr3; write to disk.

7.  Merge 9, 10, 11 into arr3 (arr1 is now empty).

> **8.** Read 12-13-14-16 into arr1.

9.  Merge 12 into arr3; write to disk.

10. Merge 13, 14, 15, 16 into arr3; write to disk.

> This last sequence of 10 steps is rather lengthy, so it may be helpful
> to examine the details of the array contents as the steps are
> completed. Figure 10.28 shows how these arrays look at various stages
> of mergesort 3.

a.  d)

> arr1 arr2
>
> arr1 arr2

arr3

> Steps 1, 2, and 3
>
> [ ]{.underline} to disk
>
> arr3
>
> Step 7

b.  e)

> arr1 arr2
>
> arr1 arr2

arr3

> arr3
>
> Step 4 Steps 8 and 9
>
> [ ]{.underline} to disk

c.  f)

> arr1 arr2
>
> arr1 arr2

arr3

[ ]{.underline} to disk

> arr3
>
> [ ]{.underline} to disk
>
> Steps 5 and 6 Step 10
>
> ***FIGURE 10.28*** Array contents during mergesort 3.

Summary 513

#### Summary

-   A multiway tree has more keys and children than a binary tree.

-   A 2-3-4 tree is a multiway tree with up to three keys and four
    children per node.

-   In a multiway tree, the keys in a node are arranged in ascending
    order.

-   In a 2-3-4 tree, all insertions are made in leaf nodes, and all leaf
    nodes are on the same level.

-   Three kinds of nodes are possible in a 2-3-4 tree: A 2-node has one
    key and two children, a 3-node has two keys and three children, and
    a 4-node has three keys and four children.

-   There is no 1-node in a 2-3-4 tree.

-   In a search in a 2-3-4 tree, at each node the keys are examined. If
    the search key is not found, the next node will be child 0 if the
    search key is less than key 0; child 1 if the search key is between
    key 0 and key 1; child 2 if the search key is between key 1 and key
    2; and child 3 if the search key is greater than key 2.

-   Insertion into a 2-3-4 tree requires that any full node be split on
    the way down the tree, during the search for the insertion point.

-   Splitting the root creates two new nodes; splitting any other node
    creates one new node.

-   The height of a 2-3-4 tree can increase only when the root is split.

-   There is a one-to-one correspondence between a 2-3-4 tree and a
    red-black tree.

-   To transform a 2-3-4 tree into a red-black tree, make each 2-node
    into a black node, make each 3-node into a black parent with a red
    child, and make each 4-node into a black parent with two red
    children.

-   When a 3-node is transformed into a parent and child, either node
    can become the parent.

-   Splitting a node in a 2-3-4 tree is the same as performing a color
    flip in a red-black tree.

-   A rotation in a red-black tree corresponds to changing between the
    two possible orientations (slants) when transforming a 3-node.

-   The height of a 2-3-4 tree is less than log2N.

-   Search times are proportional to the height.

-   The 2-3-4 tree wastes space because many nodes are not even half
    full.

> 514 **CHAPTER 10** 2-3-4 Trees and External Storage

-   A 2-3 tree is similar to a 2-3-4 tree, except that it can have only
    one or two data items and one, two, or three children.

-   Insertion in a 2-3 tree involves finding the appropriate leaf and
    then performing splits from the leaf upward, until a non-full node
    is found.

-   External storage means storing data outside of main memory, usually
    on a disk.

-   External storage is larger, cheaper (per byte), and slower than main
    memory.

-   Data in external storage is typically transferred to and from main
    memory a block at a time.

-   Data can be arranged in external storage in sequential key order.
    This gives fast search times but slow insertion (and deletion)
    times.

-   A B-tree is a multiway tree in which each node may have dozens or
    hundreds of keys and children.

-   There is always one more child than there are keys in a B-tree node.

-   For the best performance, a B-tree is typically organized so that a
    node holds one block of data.

-   If the search criteria involve many keys, a sequential search of all
    the records in a file may be the most practical approach.

#### Questions

> These questions are intended as a self-test for readers. Answers may
> be found in Appendix C.

1.  A 2-3-4 tree is so named because a node can have

    a.  three children and four data items.

    b.  two, three, or four children.

    c.  two parents, three children, and four items.

    d.  two parents, three items, and four children.

2.  A 2-3-4 tree is superior to a binary search tree in that it is .

3.  Imagine a parent node with data items 25, 50, and 75. If one of its
    child nodes

> had items with values 60 and 70, it would be the child numbered .

4.  True or False: Data items are located exclusively in leaf nodes.

Questions 515

5.  Which of the following is *not* true each time a node is split?

    e.  Exactly one new node is created.

    f.  Exactly one new data item is added to the tree.

    g.  One data item moves from the split node to its parent.

    h.  One data item moves from the split node to its new sibling.

6.  A 2-3-4 tree increases its number of levels when [ ]{.underline}
    **.**

7.  Searching a 2-3-4 tree does *not* involve

    i.  splitting nodes on the way down if necessary.

    j.  picking the appropriate child to go to, based on data items in a
        node.

    k.  ending up at a leaf node if the search key is not found.

    l.  examining at least one data item in any node visited.

8.  After a non-root node of a 2-3-4 tree is split, does its new right
    child contain the item previously numbered 0, 1, or 2?

9.  A 4-node split in a 2-3-4 tree is equivalent to a [ ]{.underline} in
    a red-black tree.

10. Which of the following statements about a node-splitting operation
    in a 2-3 tree (not a 2-3-4 tree) is *not* true?

    m.  The parent of a split node must also be split if it is full.

    n.  The smallest item in the node being split always stays in that
        node.

    o.  When the parent is split, child 2 must always be disconnected
        from its old parent and connected to the new parent.

    p.  The splitting process starts at a leaf and works upward.

11. What is the big O efficiency of a 2-3 tree?

12. In accessing data on a disk drive,

    q.  inserting data is slow but finding the place to write data is
        fast.

    r.  moving data to make room for more data is fast because so many
        items can be accessed at once.

    s.  deleting data is unusually fast.

    t.  finding the place to write data is comparatively slow but a lot
        of data can be written quickly.

13. In a B-tree each node contains [ ]{.underline} data items.

> 516 **CHAPTER 10** 2-3-4 Trees and External Storage

14. True or False: Node splits in a B-tree have similarities to node
    splits in a 2-3 tree.

15. In external storage, indexing means keeping a file of

    u.  keys and their corresponding blocks.

    v.  records and their corresponding blocks.

    w.  keys and their corresponding records.

    x.  last names and their corresponding keys.

#### Experiments

> Carrying out these experiments will help to provide insights into the
> topics covered in the chapter. No programming is involved.

1.  Draw by hand what a 2-3-4 tree looks like after each of the
    following inser- tions: 10, 20, 30, 40, 50, 60, 70, 80, and 90.
    Don't use the Tree234 Workshop applet.

2.  Draw by hand what a 2-3 tree looks like after inserting the same
    sequence of values as in Experiment 1.

3.  Think about how you would remove a node from a 2-3-4 tree.

#### Programming Projects

> Writing programs to solve the Programming Projects helps to solidify
> your under- standing of the material and demonstrates how the
> chapter's concepts are applied. (As noted in the Introduction,
> qualified instructors may obtain completed solutions to the
> Programming Projects on the publisher's Web site.)

1.  This project should be easy. Write a method that returns the minimum
    value in a 2-3-4 tree.

    Write a method that does an inorder traverse of a 2-3-4 tree. It
    should display all the items in order.

    A 2-3-4 tree can be used as a sorting machine. Write a sort() method
    that's passed an array of key values from main() and writes them
    back to the array in sorted order.

    Modify the tree234.java program (Listing 10.1) so that it creates
    and works with 2-3 trees instead. It should display the tree and
    allow searches. It should also allow items to be inserted, but only
    if the parent of the leaf node (which is

Programming Projects 517

> being split) does not also need to be split. This implies that the
> split() routine need not be recursive. In writing insert(), remember
> that no splits happen until the appropriate leaf has been located.
> Then the leaf will be split if it's full. You'll need to be able to
> split the root too, but only when it's a leaf. With this limited
> routine you can insert fewer than nine items before the program
> crashes.

5.  Extend the program in Programming Project 10.4 so that the split()
    routine is recursive and can handle situations with a full parent of
    a full child. This will allow insertion of an unlimited number of
    items. Note that in the revised split() routine you'll need to split
    the parent before you can decide where the items go and where to
    attach the children.
