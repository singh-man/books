14
==

Weighted Graphs
---------------

> In the preceding chapter we saw that a graph's edges can have
> direction. In this chapter we'll explore another edge feature: weight.
> For example, if vertices in a weighted
>
> graph represent cities, the weight of the edges might repre- sent
> distances between the cities, or costs to fly between them, or the
> number of automobile trips made annually between them (a figure of
> interest to highway engineers).
>
> When we include weight as a feature of a graph's edges, some
> interesting and complex questions arise. What is the minimum spanning
> tree for a weighted graph? What is the shortest (or cheapest) distance
> from one vertex to another? Such questions have important applications
> in the real world.
>
> We'll first examine a weighted but non-directed graph and its minimum
> spanning tree. In the second half of this chapter we'll examine graphs
> that are both directed and weighted, in connection with the famous
> Dijkstra's algo- rithm, used to find the shortest path from one vertex
> to another.

#### Minimum Spanning Tree with Weighted Graphs

> To introduce weighted graphs, we'll return to the question of the
> minimum spanning tree. Creating such a tree is a bit more complicated
> with a weighted graph than with an unweighted one. When all edges are
> the same weight, it's fairly straightforward---as we saw in Chapter
> 13, "Graphs"---for the algorithm to choose one to add to the minimum
> spanning tree. But when edges can have differ- ent weights, some
> arithmetic is needed to choose the right one.

##### IN THIS CHAPTER

-   Minimum Spanning Tree with Weighted Graphs

-   The Shortest-Path Problem

-   The All-Pairs Shortest-Path Problem

-   Efficiency

-   Intractable Problems

> 670 **CHAPTER 14** Weighted Graphs

##### An Example: Cable TV in the Jungle

> Suppose we want to install a cable television line that connects six
> towns in the mythical country of Magnaguena. Five links will connect
> the six cities, but which five links should they be? The cost of
> connecting each pair of cities varies, so we must pick the route
> carefully to minimize the overall cost.
>
> Figure 14.1 shows a weighted graph with six vertices, representing the
> towns Ajo, Bordo, Colina, Danza, Erizo, and Flor. Each edge has a
> weight, shown by a number alongside the edge. Imagine that these
> numbers represent the cost, in millions of Magnaguenian dollars, of
> installing a cable link between two cities. (Notice that some links
> are impractical because of distance or terrain; for example, we will
> assume that it's too far from Ajo to Colina or from Danza to Flor, so
> these links don't need to be considered and don't appear on the
> graph.)

Bordo Colina

> ***FIGURE 14.1*** A weighted graph.
>
> Danza Erizo
>
> How can we pick a route that minimizes the cost of installing the
> cable system? The answer is to calculate a minimum spanning tree. It
> will have five links (one fewer than the number of towns), it will
> connect all six towns, and it will minimize the total cost of building
> these links. Can you figure out this route by looking at the graph in
> Figure 14.1? If not, you can solve the problem with the GraphW
> Workshop applet.

##### The GraphW Workshop Applet

> The GraphW Workshop applet is similar to GraphN and GraphD, but it
> creates weighted, undirected graphs. Before you drag from vertex to
> vertex to create an edge, you must type the weight of the edge into
> the text box in the upper-right corner.
>
> This applet carries out only one algorithm: When you repeatedly click
> the Tree button, it finds the minimum spanning tree for whatever graph
> you have created. The New and View buttons work as in previous graph
> applets to erase an old graph and to view the adjacency matrix.
>
> Minimum Spanning Tree with Weighted Graphs 671
>
> Try out this applet by creating some small graphs and finding their
> minimum span- ning trees. (For some configurations you'll need to be
> careful positioning the vertices so that the weight numbers don't fall
> on top of each other.)
>
> As you step through the algorithm, you'll see that vertices acquire
> red borders and edges are made thicker when they're added to the
> minimum spanning tree. Vertices that are in the tree are also listed
> below the graph, on the left. On the right, the contents of a priority
> queue (PQ) are shown. The items in the priority queue are edges. For
> instance, the entry AB6 in the queue is the edge from A to B, which
> has a weight of 6. We'll explain what the priority queue does after
> we've shown an example of the algorithm.
>
> Use the GraphW Workshop applet to construct the graph of Figure 14.1.
> The result should resemble Figure 14.2.

![](media/image1.png){width="2.7984689413823274in"
height="2.2799989063867017in"}

> ***FIGURE 14.2*** The GraphW Workshop applet.
>
> Now find this graph's minimum spanning tree by stepping through the
> algorithm with the Tree button. The result should be the minimum
> spanning tree shown in Figure 14.3.
>
> The applet should discover that the minimum spanning tree consists of
> the edges AD, AB, BE, EC, and CF, for a total edge weight of 28. The
> order in which the edges are specified is unimportant. If you start at
> a different vertex, you will create a tree with the same edges, but in
> a different order.
>
> 672 **CHAPTER 14** Weighted Graphs

Bordo Colina

> Danza Erizo
>
> ***FIGURE 14.3*** The minimum spanning tree.

##### Send Out the Surveyors

> The algorithm for constructing the minimum spanning tree is a little
> involved, so we're going to introduce it using an analogy involving
> cable TV employees. You are one employee---a manager, of course---and
> there are also various surveyors.
>
> A computer algorithm (unless perhaps it's a neural network) doesn't
> "know" about all the data in a given problem at once; it can't deal
> with the big picture. It must acquire the data little by little,
> modifying its view of things as it goes along. With graphs, algorithms
> tend to start at some vertex and work outward, acquiring data about
> nearby vertices before finding out about vertices farther away. We saw
> exam- ples of this in the depth-first and breadth-first searches in
> the preceding chapter.
>
> In a similar way, we're going to assume that you don't start out
> knowing the costs of installing the cable TV line between all the
> pairs of towns in Magnaguena. Acquiring this information takes time.
> That's where the surveyors come in.

####### Starting in Ajo

> You start by setting up an office in Ajo. (You could start in any
> town, but Ajo has the best restaurants.) Only two towns are reachable
> from Ajo: Bordo and Danza (see Figure 14.1). You hire two tough,
> jungle-savvy surveyors and send them out along the dangerous
> wilderness trails, one to Bordo and one to Danza. Their job is to
> deter- mine the cost of installing cable along these routes.
>
> The first surveyor arrives in Bordo, having completed her survey, and
> calls you on her cell phone; she says it will cost 6 million dollars
> to install the cable link between Ajo and Bordo. The second surveyor,
> who has had some trouble with crocodiles, reports a little later from
> Danza that the Ajo--Danza link, which crosses more level country, will
> cost only 4 million dollars. You make a list:

-   Ajo--Danza, \$4 million

-   Ajo--Bordo, \$6 million

> Minimum Spanning Tree with Weighted Graphs 673
>
> You always list the links in order of increasing cost; we'll see why
> this is a good idea soon.

####### Building the Ajo--Danza Link

> At this point you figure you can send out the construction crew to
> actually install the cable from Ajo to Danza. How can you be sure the
> Ajo--Danza route will eventu- ally be part of the cheapest solution
> (the minimum spanning tree)? So far, you know the cost of only two
> links in the system. Don't you need more information?
>
> To get a feel for this situation, try to imagine some other route
> linking Ajo to Danza that would be cheaper than the direct link. If it
> doesn't go directly to Danza, this other route must go through Bordo
> and circle back to Danza, possibly via one or more other towns. But
> you already know the link to Bordo is more expensive, at 6 million
> dollars, than the link to Danza, at 4. So even if the remaining links
> in this hypothetical circle route are cheap, as shown in Figure 14.4,
> it will still be more expensive to get to Danza by going through
> Bordo. Also, it will be more expensive to get to towns on the circle
> route, like X, by going through Bordo than by going through Danza.
>
> Hypothetical Circle Route
>
> ***FIGURE 14.4*** Hypothetical circle route.
>
> We conclude that the Ajo--Danza route will be part of the minimum
> spanning tree. This isn't a formal proof (which is beyond the scope of
> this book), but it does suggest your best bet is to pick the cheapest
> link. So you build the Ajo--Danza link and install an office in Danza.
>
> Why do you need an office? Due to a Magnaguena government regulation,
> you must install an office in a town before you can send out surveyors
> from that town to adja- cent towns. In graph terms, you must add a
> vertex to the tree before you can learn the weight of the edges
> leading away from that vertex. All towns with offices are connected by
> cable with each other; towns with no offices are not yet connected.
>
> 674 **CHAPTER 14** Weighted Graphs

####### Building the Ajo--Bordo Link

> After you've completed the Ajo--Danza link and built your office in
> Danza, you can send out surveyors from Danza to all the towns
> reachable from there. These are Bordo, Colina, and Erizo. The
> surveyors reach their destinations and report back costs of 7, 8, and
> 12 million dollars, respectively. (Of course, you don't send a
> surveyor to Ajo because you've already surveyed the Ajo--Danza route
> and installed its cable.)
>
> Now you know the costs of four links from towns with offices to towns
> with no offices:

-   Ajo--Bordo, \$6 million

-   Danza--Bordo, \$7 million

-   Danza--Colina, \$8 million

-   Danza--Erizo, \$12 million

> Why isn't the Ajo--Danza link still on the list? Because you've
> already installed the cable there; there's no point giving any further
> consideration to this link. The route on which a cable has just been
> installed is always removed from the list.
>
> At this point it may not be obvious what to do next. There are many
> potential links to choose from. What do you imagine is the best
> strategy now? Here's the rule:
>
> **[RULE ]{.underline}**
>
> From the list, always pick the cheapest edge.
>
> Actually, you already followed this rule when you chose which route to
> follow from Ajo; the Ajo--Danza edge was the cheapest. Here the
> cheapest edge is Ajo--Bordo, so you install a cable link from Ajo to
> Bordo for a cost of 6 million dollars, and build an office in Bordo.
>
> Let's pause for a moment and make a general observation. At a given
> time in the cable system construction, there are three kinds of towns:

1.  Towns that have offices and are linked by cable. (In graph terms
    they're in the minimum spanning tree.)

2.  Towns that aren't linked yet and have no office, but for which you
    know the cost to link them to at least one town with an office. We
    can call these "fringe" towns.

3.  Towns you don't know anything about.

> Minimum Spanning Tree with Weighted Graphs 675
>
> At this stage, Ajo, Danza, and Bordo are in category 1, Colina and
> Erizo are in cate- gory 2, and Flor is in category 3, as shown in
> Figure 14.5. As we work our way through the algorithm, towns move from
> category 3 to 2, and from 2 to 1.

Flor

> Unknown Towns (not in the tree)
>
> ***FIGURE 14.5*** Partway through the minimum spanning tree algorithm.

####### Building the Bordo--Erizo Link

> At this point, Ajo, Danza, and Bordo are connected to the cable system
> and have offices. You already know the costs from Ajo and Danza to
> towns in category 2, but you don't know these costs from Bordo. So
> from Bordo you send out surveyors to Colina and Erizo. They report
> back costs of 10 million dollars to Colina and 7 to Erizo. Here's the
> new list:

-   Bordo--Erizo, \$7 million

-   Danza--Colina, \$8 million

-   Bordo--Colina, \$10 million

-   Danza--Erizo, \$12 million

> The Danza--Bordo link was on the previous list but is not on this one
> because, as we noted, there's no point in considering links to towns
> that are already connected, even by an indirect route.
>
> From this list we can see that the cheapest route is Bordo--Erizo, at
> 7 million dollars. You send out the crew to install this cable link,
> and you build an office in Erizo (see Figure 14.3).
>
> 676 **CHAPTER 14** Weighted Graphs

####### Building the Erizo--Colina Link

> From Erizo the surveyors report back costs of 5 million dollars to
> Colina and 7 to Flor. The Danza--Erizo link from the previous list
> must be removed because Erizo is now a connected town. Your new list
> is

-   Erizo--Colina, \$5 million

-   Erizo--Flor, \$7 million

-   Danza--Colina, \$8 million

-   Bordo--Colina, \$10 million

> The cheapest of these links is Erizo--Colina, so you build this link
> and install an office in Colina.

####### And, Finally, the Colina--Flor Link

> The choices are narrowing. After you remove already-linked towns, your
> list now shows only

-   Colina--Flor, \$6 million

-   Erizo--Flor, \$7 million

> You install the last link of cable from Colina to Flor, build an
> office in Flor, and you're done. You know you're done because there's
> now an office in every town. You've constructed the cable route
> Ajo--Danza, Ajo--Bordo, Bordo--Erizo, Erizo--Colina, and Colina--Flor,
> as shown earlier in Figure 14.3. This is the cheapest possible route
> linking the six towns of Magnaguena.

##### Creating the Algorithm

> Using the somewhat fanciful idea of installing a cable TV system,
> we've shown the main ideas behind the minimum spanning tree for
> weighted graphs. Now let's see how we'd go about creating the
> algorithm for this process.

####### The Priority Queue

> The key activity in carrying out the algorithm, as described in the
> cable TV example, was maintaining a list of the costs of links between
> pairs of cities. We decided where to build the next link by selecting
> the minimum of these costs.
>
> A list in which we repeatedly select the minimum value suggests a
> priority queue as an appropriate data structure, and in fact this
> turns out to be an efficient way to handle the minimum spanning tree
> problem. Instead of a list or array, we use a
>
> Minimum Spanning Tree with Weighted Graphs 677
>
> priority queue. In a serious program this priority queue might be
> based on a heap, as described in Chapter 12, "Heaps." This would speed
> up operations on large priority queues. However, in our demonstration
> program we'll use a priority queue based on a simple array.

####### Outline of the Algorithm

> Let's restate the algorithm in graph terms (as opposed to cable TV
> terms): Start with a vertex, and put it in the tree. Then repeatedly
> do the following:

1.  Find all the edges from the newest vertex to other vertices that
    aren't in the tree. Put these edges in the priority queue.

2.  Pick the edge with the lowest weight, and add this edge and its
    destination vertex to the tree.

> Repeat these steps until all the vertices are in the tree. At that
> point, you're done.
>
> In step 1, *newest* means most recently installed in the tree. The
> edges for this step can be found in the adjacency matrix. After step
> 1, the list will contain all the edges from vertices in the tree to
> vertices on the fringe.

####### Extraneous Edges

> In maintaining the list of links, we went to some trouble to remove
> links that led to a town that had recently become connected. If we
> didn't do this, we would have ended up installing unnecessary cable
> links.
>
> In a programming algorithm we must likewise make sure that we don't
> have any edges in the priority queue that lead to vertices that are
> already in the tree. We could go through the queue looking for and
> removing any such edges each time we added a new vertex to the tree.
> As it turns out, it is easier to keep only one edge from the tree to a
> given fringe vertex in the priority queue at any given time. That is,
> the queue should contain only one edge to each category 2 vertex.
>
> You'll see that this is what happens in the GraphW Workshop applet.
> There are fewer edges in the priority queue than you might
> expect---just one entry for each category 2 vertex. Step through the
> minimum spanning tree for Figure 14.1 and verify that this is what
> happens. Table 14.1 shows how edges with duplicate destinations have
> been removed from the priority queue.
>
> 678 **CHAPTER 14** Weighted Graphs

+-----------------+-----------------+-----------------+-----------------+
| ***TABLE        | > Edge Pruning  |                 |
| 14.1***         |                 |                 |
+=================+=================+=================+=================+
| **Step**        | > **Unpruned    | > **Pruned      | > **Duplicate   |
|                 | > Edge**        | > Edge**        | > Removed**     |
| **Number**      |                 | >               |                 |
|                 |                 | > **(in         |                 |
|                 |                 | > Priority**    |                 |
+-----------------+-----------------+-----------------+-----------------+
| **List**        | > **List**      | > **Queue)**    | > **from        |
|                 |                 |                 | > Priority      |
|                 |                 |                 | > Queue**       |
+-----------------+-----------------+-----------------+-----------------+
| 1               | > AB6, AD4      | > AB6, AD4      |                 |
+-----------------+-----------------+-----------------+-----------------+
| 2               | > DE12, DC8,    | > DE12, DC8,    | > DB7(AB6)      |
|                 | > DB7, AB6      | > AB6           |                 |
+-----------------+-----------------+-----------------+-----------------+
| 3               | > DE12, BC10,   | > DC8, BE7      | > DE12(BE7),    |
|                 | > DC8, BE7      |                 | > BC10(DC8)     |
+-----------------+-----------------+-----------------+-----------------+
| 4               | > BC10, DC8,    | > EF7, EC5      | > BC10(EC5),    |
|                 | > EF7, EC5      |                 | > DC8(EC5)      |
+-----------------+-----------------+-----------------+-----------------+
| 5               | > EF7, CF6      | > CF6           | > EF7           |
+-----------------+-----------------+-----------------+-----------------+

> Remember that an edge consists of a letter for the source (starting)
> vertex of the edge, a letter for the destination (ending vertex), and
> a number for the weight. The second column in this table corresponds
> to the lists you kept when constructing the cable TV system. It shows
> all edges from category 1 vertices (those in the tree) to category 2
> vertices (those with at least one known edge from a category 1
> vertex).
>
> The third column is what you see in the priority queue when you run
> the GraphW applet. Any edge with the same destination vertex as
> another edge, and which has a greater weight, has been removed.
>
> The fourth column shows the edges that have been removed and, in
> parentheses, the edge with the smaller weight that superseded it and
> remains in the queue.
>
> Remember that as you go from step to step the last entry on the list
> is always removed because this edge is added to the tree.

####### Looking for Duplicates in the Priority Queue

> How do we make sure there is only one edge per category 2 vertex? Each
> time we add an edge to the queue, we make sure there's no other edge
> going to the same destination. If there is, we keep only the one with
> the smallest weight.
>
> This necessitates looking through the priority queue item by item, to
> see if there's such a duplicate edge. Priority queues are not designed
> for random access, so this is not an efficient activity. However,
> violating the spirit of the priority queue is neces- sary in this
> situation.

##### Java Code

> The method that creates the minimum spanning tree for a weighted
> graph, mstw(), follows the algorithm outlined earlier. As in our other
> graph programs, it assumes there's a list of vertices in
> vertexList\[\], and that it will start with the vertex at index
>
> 0\. The currentVert variable represents the vertex most recently added to
> the tree. Here's the code for mstw():
>
> Minimum Spanning Tree with Weighted Graphs 679
>
> public void mstw() // minimum spanning tree
>
> {
>
> currentVert = 0; // start at 0
>
> while(nTree \< nVerts-1) // while not all verts in tree
>
> { // put currentVert in tree vertexList\[currentVert\].isInTree =
> true;
>
> nTree++;
>
> // insert edges adjacent to currentVert into PQ for(int j=0;
> j\<nVerts; j++) // for each vertex,
>
> {
>
> if(j==currentVert) // skip if it's us continue;
>
> if(vertexList\[j\].isInTree) // skip if in the tree continue;
>
> int distance = adjMat\[currentVert\]\[j\];
>
> if( distance == INFINITY) // skip if no edge continue;
>
> putInPQ(j, distance); // put it in PQ (maybe)
>
> }
>
> if(thePQ.size()==0) // no vertices in PQ?
>
> {
>
> System.out.println(" GRAPH NOT CONNECTED"); return;
>
> }
>
> // remove edge with minimum distance, from PQ Edge theEdge =
> thePQ.removeMin();
>
> int sourceVert = theEdge.srcVert; currentVert = theEdge.destVert;
>
> // display edge from source to current System.out.print(
> vertexList\[sourceVert\].label ); System.out.print(
> vertexList\[currentVert\].label ); System.out.print(" ");
>
> } // end while(not all verts in tree)
>
> // mst is complete
>
> for(int j=0; j\<nVerts; j++) // unmark vertices
> vertexList\[j\].isInTree = false;
>
> } // end mstw()
>
> 680 **CHAPTER 14** Weighted Graphs
>
> The algorithm is carried out in the while loop, which terminates when
> all vertices are in the tree. Within this loop the following
> activities take place:

1.  The current vertex is placed in the tree.

2.  The edges adjacent to this vertex are placed in the priority queue
    (if appropriate).

3.  The edge with the minimum weight is removed from the priority queue.
    The destination vertex of this edge becomes the current vertex.

> Let's look at these steps in more detail. In step 1, the currentVert
> is placed in the tree by marking its isInTree field.
>
> In step 2, the edges adjacent to this vertex are considered for
> insertion in the priority queue. The edges are examined by scanning
> across the row whose number is currentVert in the adjacency matrix. An
> edge is placed in the queue unless one of these conditions is true:

-   The source and destination vertices are the same.

-   The destination vertex is in the tree.

-   There is no edge to this destination.

> If none of these conditions are true, the putInPQ() method is called
> to put the edge in the priority queue. Actually, this routine doesn't
> always put the edge in the queue either, as we'll see in a moment.
>
> In step 3, the edge with the minimum weight is removed from the
> priority queue. This edge and its destination vertex are added to the
> tree, and the source vertex (currentVert) and destination vertex are
> displayed.
>
> At the end of mstw(), the vertices are removed from the tree by
> resetting their isInTree variables. That isn't strictly necessary in
> this program because only one tree is created from the data. However,
> it's good housekeeping to restore the data to its original form when
> you finish with it.
>
> As we noted, the priority queue should contain only one edge with a
> given destina- tion vertex. The putInPQ() method makes sure this is
> true. It calls the find() method of the PriorityQ class, which has
> been doctored to find the edge with a specified destination vertex. If
> there is no such vertex, and find() therefore returns --1, then
> putInPQ() simply inserts the edge into the priority queue. However, if
> such an edge does exist, putInPQ() checks to see whether the existing
> edge or the new proposed edge has the lower weight. If it's the old
> edge, no change is necessary. If the new one has a lower weight, the
> old edge is removed from the queue and the new one is installed.
> Here's the code for putInPQ():
>
> Minimum Spanning Tree with Weighted Graphs 681
>
> public void putInPQ(int newVert, int newDist)
>
> {
>
> // is there another edge with the same destination vertex? int
> queueIndex = thePQ.find(newVert); // got edge's index if(queueIndex !=
> -1) // if there is one,
>
> { // get edge
>
> Edge tempEdge = thePQ.peekN(queueIndex); int oldDist =
> tempEdge.distance;
>
> if(oldDist \> newDist) // if new edge shorter,
>
> {
>
> thePQ.removeN(queueIndex); // remove old edge
>
> Edge theEdge = new Edge(currentVert, newVert, newDist);
> thePQ.insert(theEdge); // insert new edge
>
> }
>
> // else no action; just leave the old vertex there
>
> } // end if
>
> else // no edge with same destination vertex
>
> { // so insert new one
>
> Edge theEdge = new Edge(currentVert, newVert, newDist);
> thePQ.insert(theEdge);
>
> }
>
> } // end putInPQ()
>
> **The** mstw.java **Program**
>
> The PriorityQ class uses an array to hold the members. As we noted, in
> a program dealing with large graphs, a heap would be more appropriate
> than the array shown here. The PriorityQ class has been augmented with
> various methods. It can, as we've seen, find an edge with a given
> destination vertex with find(). It can also peek at an arbitrary
> member with peekN(), and remove an arbitrary member with removeN().
>
> Most of the rest of this program you've seen before. Listing 14.1
> shows the complete
>
> mstw.java program.
>
> ***LISTING 14.1*** The mstw.java Program
>
> // mstw.java
>
> // demonstrates minimum spanning tree with weighted graphs
>
> // to run this program: C\>java MSTWApp
>
> //////////////////////////////////////////////////////////////// class
> Edge
>
> {
>
> public int srcVert; // index of a vertex starting edge public int
> destVert; // index of a vertex ending edge
>
> 682 **CHAPTER 14** Weighted Graphs
>
> ***LISTING 14.1*** Continued
>
> public int distance; // distance from src to dest
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Edge(int sv, int dv, int d) // constructor
>
> {
>
> srcVert = sv; destVert = dv; distance = d;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Edge
>
> //////////////////////////////////////////////////////////////// class
> PriorityQ
>
> {
>
> // array in sorted order, from max at 0 to min at size-1 private final
> int SIZE = 20;
>
> private Edge\[\] queArray; private int size;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public PriorityQ() // constructor
>
> {
>
> queArray = new Edge\[SIZE\]; size = 0;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insert(Edge item) // insert item in sorted order
>
> {
>
> int j;
>
> for(j=0; j\<size; j++) // find place to insert if( item.distance \>=
> queArray\[j\].distance )
>
> break;
>
> for(int k=size-1; k\>=j; k\--) // move items up queArray\[k+1\] =
> queArray\[k\];
>
> queArray\[j\] = item; // insert item size++;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Edge removeMin() // remove minimum item
>
> { return queArray\[\--size\]; }
>
> Minimum Spanning Tree with Weighted Graphs 683
>
> ***LISTING 14.1*** Continued
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void removeN(int n) // remove item at n
>
> {
>
> for(int j=n; j\<size-1; j++) // move items down queArray\[j\] =
> queArray\[j+1\];
>
> size\--;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Edge peekMin() // peek at minimum item
>
> { return queArray\[size-1\]; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int size() // return number of items
>
> { return size; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if queue is empty
>
> { return (size==0); }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Edge peekN(int n) // peek at item n
>
> { return queArray\[n\]; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int find(int findDex) // find item with specified
>
> { // destVert value
>
> for(int j=0; j\<size; j++) if(queArray\[j\].destVert == findDex)
>
> return j; return -1;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class PriorityQ
>
> //////////////////////////////////////////////////////////////// class
> Vertex
>
> {
>
> public char label; // label (e.g. 'A') public boolean isInTree;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Vertex(char lab) // constructor
>
> {
>
> label = lab; isInTree = false;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> 684 **CHAPTER 14** Weighted Graphs
>
> ***LISTING 14.1*** Continued
>
> } // end class Vertex
>
> //////////////////////////////////////////////////////////////// class
> Graph
>
> {
>
> private final int MAX\_VERTS = 20; private final int INFINITY =
> 1000000;
>
> private Vertex vertexList\[\]; // list of vertices private int
> adjMat\[\]\[\]; // adjacency matrix
>
> private int nVerts; // current number of vertices private int
> currentVert;
>
> private PriorityQ thePQ;
>
> private int nTree; // number of verts in tree
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Graph() // constructor
>
> {
>
> vertexList = new Vertex\[MAX\_VERTS\];
>
> // adjacency matrix adjMat = new int\[MAX\_VERTS\]\[MAX\_VERTS\];
>
> nVerts = 0;
>
> for(int j=0; j\<MAX\_VERTS; j++) // set adjacency for(int k=0;
> k\<MAX\_VERTS; k++) // matrix to 0
>
> adjMat\[j\]\[k\] = INFINITY; thePQ = new PriorityQ();
>
> } // end constructor
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void addVertex(char lab)
>
> {
>
> vertexList\[nVerts++\] = new Vertex(lab);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void addEdge(int start, int end, int weight)
>
> {
>
> adjMat\[start\]\[end\] = weight; adjMat\[end\]\[start\] = weight;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayVertex(int v)
>
> {
>
> System.out.print(vertexList\[v\].label);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> Minimum Spanning Tree with Weighted Graphs 685

***LISTING 14.1*** Continued

> public void mstw() // minimum spanning tree
>
> {
>
> currentVert = 0; // start at 0
>
> while(nTree \< nVerts-1) // while not all verts in tree
>
> { // put currentVert in tree vertexList\[currentVert\].isInTree =
> true;
>
> nTree++;
>
> // insert edges adjacent to currentVert into PQ for(int j=0;
> j\<nVerts; j++) // for each vertex,
>
> {
>
> if(j==currentVert) // skip if it's us continue;
>
> if(vertexList\[j\].isInTree) // skip if in the tree continue;
>
> int distance = adjMat\[currentVert\]\[j\];
>
> if( distance == INFINITY) // skip if no edge continue;
>
> putInPQ(j, distance); // put it in PQ (maybe)
>
> }
>
> if(thePQ.size()==0) // no vertices in PQ?
>
> {
>
> System.out.println(" GRAPH NOT CONNECTED"); return;
>
> }
>
> // remove edge with minimum distance, from PQ Edge theEdge =
> thePQ.removeMin();
>
> int sourceVert = theEdge.srcVert; currentVert = theEdge.destVert;
>
> // display edge from source to current System.out.print(
> vertexList\[sourceVert\].label ); System.out.print(
> vertexList\[currentVert\].label ); System.out.print(" ");
>
> } // end while(not all verts in tree)
>
> // mst is complete
>
> for(int j=0; j\<nVerts; j++) // unmark vertices
> vertexList\[j\].isInTree = false;
>
> } // end mstw
>
> 686 **CHAPTER 14** Weighted Graphs
>
> ***LISTING 14.1*** Continued
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void putInPQ(int newVert, int newDist)
>
> {
>
> // is there another edge with the same destination vertex? int
> queueIndex = thePQ.find(newVert);
>
> if(queueIndex != -1) // got edge's index
>
> {
>
> Edge tempEdge = thePQ.peekN(queueIndex); // get edge int oldDist =
> tempEdge.distance;
>
> if(oldDist \> newDist) // if new edge shorter,
>
> {
>
> thePQ.removeN(queueIndex); // remove old edge Edge theEdge =
>
> new Edge(currentVert, newVert, newDist); thePQ.insert(theEdge); //
> insert new edge
>
> }
>
> // else no action; just leave the old vertex there
>
> } // end if
>
> else // no edge with same destination vertex
>
> { // so insert new one
>
> Edge theEdge = new Edge(currentVert, newVert, newDist);
> thePQ.insert(theEdge);
>
> }
>
> } // end putInPQ()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Graph
>
> //////////////////////////////////////////////////////////////// class
> MSTWApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> Graph theGraph = new Graph(); theGraph.addVertex('A'); // 0 (start for
> mst) theGraph.addVertex('B'); // 1
>
> theGraph.addVertex('C'); // 2
>
> theGraph.addVertex('D'); // 3
>
> theGraph.addVertex('E'); // 4
>
> theGraph.addVertex('F'); // 5
>
> theGraph.addEdge(0, 1, 6); // AB 6
>
> theGraph.addEdge(0, 3, 4); // AD 4
>
> The Shortest-Path Problem 687
>
> ***LISTING 14.1*** Continued
>
> theGraph.addEdge(1, 2, 10); // BC 10
>
> theGraph.addEdge(1, 3, 7); // BD 7
>
> theGraph.addEdge(1, 4, 7); // BE 7
>
> theGraph.addEdge(2, 3, 8); // CD 8
>
> theGraph.addEdge(2, 4, 5); // CE 5
>
> theGraph.addEdge(2, 5, 6); // CF 6
>
> theGraph.addEdge(3, 4, 12); // DE 12
>
> theGraph.addEdge(4, 5, 7); // EF 7
>
> System.out.print("Minimum spanning tree: "); theGraph.mstw(); //
> minimum spanning tree System.out.println();
>
> } // end main()

} // end class MSTWApp

> ///////////////////////////////////////////////////////////////
>
> The main() routine in class MSTWApp creates the tree in Figure 14.1.
> Here's the output:
>
> Minimum spanning tree: AD AB BE EC CF

#### The Shortest-Path Problem

> Perhaps the most commonly encountered problem associated with weighted
> graphs is that of finding the shortest path between two given
> vertices. The solution to this problem is applicable to a wide variety
> of real-world situations, from the layout of printed circuit boards to
> project scheduling. It is a more complex problem than we've seen
> before, so let's start by looking at a (somewhat) real-world scenario
> in the same mythical country of Magnaguena introduced in the preceding
> section.

##### The Railroad Line

> This time we're concerned with railroads rather than cable TV.
> However, this project is not as ambitious as the last one. We're not
> going to build the railroad; it already exists. We just want to find
> the cheapest route from one city to another.
>
> The railroad charges passengers a fixed fare to travel between any two
> towns. These fares are shown in Figure 14.6. That is, the fare from
> Ajo to Bordo is \$50, from Bordo to Danza is \$90, and so on. These
> rates are the same whether the ride between two towns is part of a
> longer itinerary or not (unlike the situation with today's airline
> fares).
>
> 688 **CHAPTER 14** Weighted Graphs
>
> Bordo Colina

Ajo

A

> \$50
>
> \$90

B [ \$60 ]{.underline}

> \$50
>
> C
>
> \$40

\$80

\$20

D

> E

\$70

> Danza Erizo
>
> ***FIGURE 14.6*** Train fares in Magnaguena.
>
> The edges in Figure 14.6 are *directed*. They represent single-track
> railroad lines, on which (in the interest of safety) travel is
> permitted in only one direction. For example, you can go directly from
> Ajo to Bordo, but not from Bordo to Ajo.
>
> Although in this situation we're interested in the cheapest fares, the
> graph problem is nevertheless always referred to as the *shortest-path
> problem (SPP)*. Here *shortest* doesn't necessarily mean shortest in
> terms of distance; it can also mean cheapest, fastest, or best route
> by some other measure.

####### Cheapest Fares

> There are several possible routes between any two towns. For example,
> to take the train from Ajo to Erizo, you could go through Danza, or
> you could go through Bordo and Colina, or through Danza and Colina, or
> you could take several other routes. (It's not possible to reach the
> town of Flor by rail because it lies beyond the rugged Sierra Descaro
> range, so it doesn't appear on the graph. This is fortunate, because
> it reduces the size of certain lists we'll need to make.)
>
> The shortest-path problem is this: For a given starting point and
> destination, what's the cheapest route? In Figure 14.6, you can see
> (with a little mental effort) that the cheapest route from Ajo to
> Erizo passes through Danza and Colina; it will cost you
>
> \$140.

####### A Directed, Weighted Graph

> As we noted, our railroad has only single-track lines, so you can go
> in only one direc- tion between any two cities. This corresponds to a
> directed graph. We could have portrayed the more realistic situation
> in which you can go either way between two cities for the same price;
> this would correspond to a non-directed graph. However, the
> shortest-path problem is similar in these cases, so for variety we'll
> show how it looks in a directed graph.
>
> The Shortest-Path Problem 689

##### Dijkstra's Algorithm

> The solution we'll show for the shortest-path problem is called
> Dijkstra's algorithm, after Edsger Dijkstra, who first described it in
> 1959. This algorithm is based on the adjacency matrix representation
> of a graph. Somewhat surprisingly, it finds not only the shortest path
> from one specified vertex to another, but also the shortest paths from
> the specified vertex to all the other vertices.

##### Agents and Train Rides

> To see how Dijkstra's algorithm works, imagine that you want to find
> the cheapest way to travel from Ajo to all the other towns in
> Magnaguena. You (and various agents you will hire) are going to play
> the role of the computer program carrying out Dijkstra's algorithm. Of
> course, in real life you could probably obtain a schedule from the
> railroad with all the fares. The algorithm, however, must look at one
> piece of information at a time, so (as in the preceding section) we'll
> assume that you are similarly unable to see the big picture.
>
> At each town, the stationmaster can tell you how much it will cost to
> travel to the other towns that you can reach directly (that is, in a
> single ride, without passing through another town). Alas, he cannot
> tell you the fares to towns further than one ride away. You keep a
> notebook, with a column for each town. You hope to end up with each
> column showing the cheapest route from your starting point to that
> town.

####### The First Agent: In Ajo

> Eventually, you're going to place an agent in every town; this agent's
> job is to obtain information about ticket costs to other towns. You
> yourself are the agent in Ajo.
>
> All the stationmaster in Ajo can tell you is that it will cost \$50 to
> ride to Bordo and
>
> \$80 to ride to Danza. You write this information in your notebook, as
> shown in Table 14.2.
>
> ***TABLE 14.2*** Step 1: An Agent at Ajo

+------------------+----------------+--------------+----------------+-------------+
| **From Ajo to**→ | > **Bordo**    | > **Colina** | > **Danza**    | > **Erizo** |
+==================+================+==============+================+=============+
| Step 1           | > 50 (via Ajo) | > inf        | > 80 (via Ajo) | > inf       |
+------------------+----------------+--------------+----------------+-------------+

> The entry "inf" is short for "infinity," and means that you can't get
> from Ajo to the town shown in the column head, or at least that you
> don't yet know how to get there. (In the algorithm infinity will be
> represented by a very large number, which will help with calculations,
> as we'll see.) The table entries in parentheses show the last town
> visited before you arrive at the various destinations. We'll see later
> why this is good to know. What do you do now? Here's the rule you'll
> follow:
>
> **[RULE ]{.underline}**
>
> Always send an agent to the town whose overall fare from the starting
> point (Ajo) is the cheapest.
>
> 690 **CHAPTER 14** Weighted Graphs
>
> You don't consider towns that already have an agent. Notice that this
> is not the same rule as that used in the minimum spanning tree problem
> (the cable TV installa- tion). There, you picked the least expensive
> single *link* (edge) from the connected towns to an unconnected town.
> Here, you pick the least expensive *total route* from Ajo to a town
> with no agent. In this particular point in your investigation these
> two approaches amount to the same thing, because all known routes from
> Ajo consist of only one edge, but as you send agents to more towns,
> the routes from Ajo will become the sum of several direct edges.

####### The Second Agent: In Bordo

> The cheapest fare from Ajo is to Bordo, at \$50. So you hire a
> passerby and send him to Bordo, where he'll be your agent. When he's
> there, he calls you by telephone and tells you that the Bordo
> stationmaster says it costs \$60 to ride to Colina and \$90 to Danza.
>
> Doing some quick arithmetic, you figure it must be \$50 plus \$60, or
> \$110 to go from Ajo to Colina via Bordo, so you modify the entry for
> Colina. You also can see that, going via Bordo, it must be \$50 plus
> \$90, or \$140, from Ajo to Danza. However---and this is a key
> point---you already know it's only \$80 going directly from Ajo to
> Danza. You care only about the *cheapest* route from Ajo, so you
> ignore the more expensive route, leaving this entry as it was. The
> resulting notebook entries are shown as the last row in Table 14.3.
> Figure 14.7 shows the situation geographically.
>
> \$110
>
> B \$60 C

\$50

> Bordo
>
> Colina

![](media/image2.png){width="0.1111111111111111in"
height="0.27586067366579176in"}A

Ajo

> \$80
>
> \$90
>
> D Danza E Erizo
>
> Towns with Agents (Vertices in tree)
>
> Fringe towns (Not in tree)
>
> Unknown towns (Not in tree)
>
> ***FIGURE 14.7*** Following step 2 in the shortest-path algorithm.
>
> The Shortest-Path Problem 691
>
> ***TABLE 14.3*** Step 2: Agents at Ajo and Bordo

+-------------+-------------+-------------+-------------+-------------+
| **From Ajo  | > **Bordo** | > **Colina* | > **Danza** | > **Erizo** |
| to**→       |             | *           |             |             |
+=============+=============+=============+=============+=============+
| Step 1      | > 50 (via   | > inf       | > 80 (via   | > inf       |
|             | > Ajo)      |             | > Ajo)      |             |
+-------------+-------------+-------------+-------------+-------------+
| Step 2      | > 50 (via   | > 110 (via  | > 80 (via   | > inf       |
|             | > Ajo)\*    | > Bordo)    | > Ajo)      |             |
+-------------+-------------+-------------+-------------+-------------+

> After we've installed an agent in a town, we can be sure that the
> route taken by the agent to get to that town is the cheapest route.
> Why? Consider the present case. If there were a cheaper route than the
> direct one from Ajo to Bordo, it would need to go through some other
> town. But the only other way out of Ajo is to Danza, and that ride is
> already more expensive than the direct route to Bordo. Adding
> additional fares to get from Danza to Bordo would make the Danza route
> still more expensive.
>
> From this we decide that from now on we won't need to update the entry
> for the cheapest fare from Ajo to Bordo. This fare will not change, no
> matter what we find out about other towns. We'll put a \* next to it
> to show that there's an agent in the town and that the cheapest fare
> to it is fixed.

####### Three Kinds of Towns

> As in the minimum spanning tree algorithm, we're dividing the towns
> into three categories:

1.  Towns in which we've installed an agent; they're in the tree.

2.  Towns with known fares from towns with an agent; they're on the
    fringe.

3.  Unknown towns.

> At this point Ajo and Bordo are category 1 towns because they have
> agents there. Category 1 towns form a tree consisting of paths that
> all begin at the starting vertex and that each end on a different
> destination vertex. (This is not the same tree, of course, as a
> minimum spanning tree.)
>
> Some other towns have no agents, but you know the fares to them
> because you have agents in adjacent category 1 towns. You know the
> fare from Ajo to Danza is \$80 and from Bordo to Colina is \$60.
> Because the fares to them are known, Danza and Colina are category 2
> (fringe) towns.
>
> You don't know anything yet about Erizo, it's an "unknown" town.
> Figure 14.7 shows these categories at the current point in the
> algorithm.
>
> As in the minimum spanning tree algorithm, this algorithm moves towns
> from the unknown category to the fringe category, and from the fringe
> category to the tree, as it goes along.
>
> 692 **CHAPTER 14** Weighted Graphs

####### The Third Agent: In Danza

> At this point, the cheapest route you know that goes from Ajo to any
> town without an agent is \$80, the direct route from Ajo to Danza.
> Both the Ajo--Bordo--Colina route at \$110 and the Ajo--Bordo--Danza
> route at \$140 are more expensive.
>
> You hire another passerby and send her to Danza, with an \$80 ticket.
> She reports that from Danza it's \$20 to Colina and \$70 to Erizo. Now
> you can modify your entry for Colina. Before, it was \$110 from Ajo,
> going via Bordo. Now you see you can reach Colina for only \$100,
> going via Danza. Also, you now know a fare from Ajo to the previously
> unknown Erizo: it's \$150, via Danza. You note these changes, as shown
> in Table 14.4 and Figure 14.8.

![](media/image3.png){width="0.10587598425196851in"
height="0.2760411198600175in"}

> ***FIGURE 14.8*** Following step 3 in the shortest-path algorithm.
>
> ***TABLE 14.4*** Step 3: Agents at Ajo, Bordo, and Danza

+-------------+-------------+-------------+-------------+-------------+
| **From Ajo  | > **Bordo** | > **Colina* | > **Danza** | > **Erizo** |
| to**→       |             | *           |             |             |
+=============+=============+=============+=============+=============+
| Step 1      | > 50 (via   | > inf       | > 80 (via   | > inf       |
|             | > Ajo)      |             | > Ajo)      |             |
+-------------+-------------+-------------+-------------+-------------+
| Step 2      | > 50 (via   | > 110 (via  | > 80 (via   | > inf       |
|             | > Ajo)\*    | > Bordo)    | > Ajo)      |             |
+-------------+-------------+-------------+-------------+-------------+
| Step 3      | > 50 (via   | > 100 (via  | > 80 (via   | > 150 (via  |
|             | > Ajo)\*    | > Danza)    | > Ajo)\*    | > Danza)    |
+-------------+-------------+-------------+-------------+-------------+

####### The Fourth Agent: In Colina

> Now the cheapest path to any town without an agent is the \$100 trip
> from Ajo to Colina, going via Danza. Accordingly, you dispatch an
> agent over this route to Colina. He reports that it's \$40 from there
> to Erizo. Now you can calculate that, since Colina is \$100 from Ajo
> (via Danza), and Erizo is \$40 from Colina, you can reduce the minimum
> Ajo-to-Erizo fare from \$150 (the Ajo--Danza--Erizo route) to \$140
> (the
>
> The Shortest-Path Problem 693
>
> Ajo--Danza--Colina--Erizo route). You update your notebook
> accordingly, as shown in Table 14.5 and Figure 14.9.

![](media/image4.png){width="0.10587051618547681in"
height="0.2760411198600175in"}

> ***FIGURE 14.9*** Following step 4 in the shortest-path algorithm.
>
> ***TABLE 14.5*** Step 4: Agents in Ajo, Bordo, Danza, and Colina

+-------------+-------------+-------------+-------------+-------------+
| **From Ajo  | > **Bordo** | > **Colina* | > **Danza** | > **Erizo** |
| to**→       |             | *           |             |             |
+=============+=============+=============+=============+=============+
| Step 1      | > 50 (via   | > inf       | > 80 (via   | > inf       |
|             | > Ajo)      |             | > Ajo)      |             |
+-------------+-------------+-------------+-------------+-------------+
| Step 2      | > 50 (via   | > 110 (via  | > 80 (via   | > inf       |
|             | > Ajo)\*    | > Bordo)    | > Ajo)      |             |
+-------------+-------------+-------------+-------------+-------------+
| Step 3      | > 50 (via   | > 100 (via  | > 80 (via   | > 150 (via  |
|             | > Ajo)\*    | > Danza)    | > Ajo)\*    | > Danza)    |
+-------------+-------------+-------------+-------------+-------------+
| Step 4      | > 50 (via   | > 100 (via  | > 80 (via   | > 140 (via  |
|             | > Ajo)\*    | > Danza)\*  | > Ajo)\*    | > Colina)   |
+-------------+-------------+-------------+-------------+-------------+

####### The Last Agent: In Erizo

> The cheapest path from Ajo to any town you know about that doesn't
> have an agent is now \$140 to Erizo, via Danza and Colina. You
> dispatch an agent to Erizo, but she reports that there are no routes
> from Erizo to towns without agents. (There's a route to Bordo, but
> Bordo has an agent.) Table 14.6 shows the final line in your notebook;
> all you've done is add a star to the Erizo entry to show that an agent
> is there.
>
> ***TABLE 14.6*** Step 5: Agents in Ajo, Bordo, Danza, Colina, and
> Erizo

+-------------+-------------+-------------+-------------+-------------+
| **From Ajo  | > **Bordo** | > **Colina* | > **Danza** | > **Erizo** |
| to**→       |             | *           |             |             |
+=============+=============+=============+=============+=============+
| Step 1      | > 50 (via   | > inf       | > 80 (via   | > inf       |
|             | > Ajo)      |             | > Ajo)      |             |
+-------------+-------------+-------------+-------------+-------------+
| Step 2      | > 50 (via   | > 110 (via  | > 80 (via   | > inf       |
|             | > Ajo)\*    | > Bordo)    | > Ajo)      |             |
+-------------+-------------+-------------+-------------+-------------+
| Step 3      | > 50 (via   | > 100 (via  | > 80 (via   | > 150 (via  |
|             | > Ajo)\*    | > Danza)    | > Ajo)\*    | > Danza)    |
+-------------+-------------+-------------+-------------+-------------+
| Step 4      | > 50 (via   | > 100 (via  | > 80 (via   | > 140 (via  |
|             | > Ajo)\*    | > Danza)\*  | > Ajo)\*    | > Colina)   |
+-------------+-------------+-------------+-------------+-------------+
| Step 5      | > 50 (via   | > 100 (via  | > 80 (via   | > 140 (via  |
|             | > Ajo)\*    | > Danza)\*  | > Ajo)\*    | > Colina)\* |
+-------------+-------------+-------------+-------------+-------------+

> 694 **CHAPTER 14** Weighted Graphs
>
> When there's an agent in every town, you know the fares from Ajo to
> every other town. So you're done. With no further calculations, the
> last line in your notebook shows the cheapest routes from Ajo to all
> other towns.
>
> This narrative has demonstrated the essentials of Dijkstra's
> algorithm. The key points are

-   Each time you send an agent to a new town, you use the new
    information provided by that agent to revise your list of fares.
    Only the cheapest fare (that you know about) from the starting point
    to a given town is retained.

-   You always send the new agent to the town that has the cheapest path
    from the starting point (not the cheapest edge from any town with an
    agent, as in the minimum spanning tree).

##### Using the GraphDW Workshop Applet

> Let's see how Dijkstra's algorithm looks using the GraphDW (for
> Directed and Weighted) Workshop applet. Use the applet to create the
> graph from Figure 14.6. The result should look something like Figure
> 14.10. (We'll see how to make the table appear below the graph in a
> moment.) This is a weighted, directed graph, so to make an edge, you
> must type a number before dragging, and you must drag in the correct
> direction, from the start to the destination.

![](media/image5.png){width="2.7894641294838145in" height="2.44in"}

> ***FIGURE 14.10*** The railroad scenario in GraphDW.
>
> When the graph is complete, click the Path button, and when prompted,
> click the A vertex. A few more clicks on Path will place A in the
> tree, shown with a red circle around A.
>
> The Shortest-Path Problem 695

####### The Shortest-Path Array

> An additional click of the Path button will install a table under the
> graph, as you can see in Figure 14.10. The corresponding message is
> Copied row A from adjacency matrix to shortest-path array. Dijkstra's
> algorithm starts by copying the appropriate row of the adjacency
> matrix (that is, the row for the starting vertex) to an array.
> (Remember that you can examine the adjacency matrix at any time by
> pressing the View button.)
>
> This array is called the "shortest-path" array. It corresponds to the
> most recent row of notebook entries you made while determining the
> cheapest train fares in Magnaguena. This array will hold the current
> versions of the shortest paths to the other vertices, which we can
> call the *destination* vertices. These destination vertices are
> represented by the column heads in Table 14.7.
>
> ***TABLE 14.7*** Step 1: The Shortest-Path Array

+--------+---------+----------+---------+----------+
| **A**  | > **B** | > **C**  | > **D** | > **E**  |
+========+=========+==========+=========+==========+
| inf(A) | > 50(A) | > inf(A) | > 80(A) | > inf(A) |
+--------+---------+----------+---------+----------+

> In the applet, the shortest-path figures in the array are followed by
> the *parent vertex* enclosed in parentheses. The parent is the vertex
> you reached just before you reached the destination vertex. In this
> case the parents are all A because we've moved only one edge away from
> A.
>
> If a fare is unknown (or meaningless, as from A to A), it's shown as
> infinity, repre- sented by "inf," as in the rail-fare notebook
> entries. Notice that the column heads of those vertices that have
> already been added to the tree are shown in red. The entries for these
> columns won't change.

####### Minimum Distance

> Initially, the algorithm knows the distances from A to other vertices
> that are exactly one edge from A. Only B and D are adjacent to A, so
> they're the only ones whose distances are shown. The algorithm picks
> the minimum distance. Another click on Path will show you the message
>
> Minimum distance from A is 50, to vertex B
>
> The algorithm adds this vertex to the tree, so the next click will
> show you
>
> Added vertex B to tree
>
> Now B is circled in the graph, and the B column head is in red. The
> edge from A to B is made darker to show it's also part of the tree.
>
> 696 **CHAPTER 14** Weighted Graphs

####### Column by Column in the Shortest-Path Array

> Now the algorithm knows not only all the edges from A, but the edges
> from B as well. So it goes through the shortest-path array, column by
> column, checking whether a shorter path than that shown can be
> calculated using this new informa- tion. Vertices that are already in
> the tree, here A and B, are skipped. First, column C is examined.
> You'll see the message
>
> To C: A to B (50) plus edge BC (60) less than A to C (inf)
>
> The algorithm has found a shorter path to C than that shown in the
> array. The array shows infinity in the C column. But from A to B is 50
> (which the algorithm finds in the B column in the shortest-path array)
> and from B to C is 60 (which it finds in row B column C in the
> adjacency matrix). The sum is 110. The 110 distance is less than
> infinity, so the algorithm updates the shortest-path array for column
> C, inserting
>
> 110\. This is followed by a B in parentheses, because that's the last
> vertex before reaching C; B is the parent of C.
>
> Next, the D column is examined. You'll see the message
>
> To D: A to B (50) plus edge BD (90) greater than or equal to A to D
> (80)
>
> The algorithm is comparing the previously shown distance from A to D,
> which is 80 (the direct route), with a possible route via B (that is,
> A--B--D). But path A--B is 50 and edge BD is 90, so the sum is 140.
> This is bigger than 80, so 80 is not changed.
>
> For column E, the message is
>
> To E: A to B (50) plus edge BE (inf) greater than or equal to A to E
> (inf)
>
> The newly calculated route from A to E via B (50 plus infinity) is
> still greater than or equal to the current one in the array
> (infinity), so the E column is not changed. The shortest-path array
> now looks like Table 14.8.
>
> ***TABLE 14.8*** Step 2: The Shortest-Path Array

+--------+---------+----------+---------+----------+
| **A**  | > **B** | > **C**  | > **D** | > **E**  |
+========+=========+==========+=========+==========+
| inf(A) | > 50(A) | > 110(B) | > 80(A) | > inf(A) |
+--------+---------+----------+---------+----------+

> Now we can see more clearly the role played by the parent vertex shown
> in paren- theses after each distance. Each column shows the distance
> from A to an ending vertex. The parent is the immediate predecessor of
> the ending vertex along the path from A. In column C, the parent
> vertex is B, meaning that the shortest path from A to C passes through
> B just before it gets to C. This information is used by the algo-
> rithm to place the appropriate edge in the tree. (When the distance is
> infinity, the parent vertex is meaningless and is shown as A.)
>
> The Shortest-Path Problem 697

####### New Minimum Distance

> Now that the shortest-path array has been updated, the algorithm finds
> the shortest distance in the array, as you will see with another Path
> keypress. The message is
>
> Minimum distance from A is 80, to vertex D
>
> Accordingly, the message
>
> Added vertex D to tree
>
> appears and the new vertex and edge AC are added to the tree.

####### Do It Again and Again

> Now the algorithm goes through the shortest-path array again, checking
> and updat- ing the distances for destination vertices not in the tree;
> only C and E are still in this category. Column C and E are both
> updated. The result is shown in Table 14.9.
>
> ***TABLE 14.9*** Step 3: The Shortest-Path Array

+--------+---------+----------+---------+----------+
| **A**  | > **B** | > **C**  | > **D** | > **E**  |
+========+=========+==========+=========+==========+
| inf(A) | > 50(A) | > 100(D) | > 80(A) | > 150(D) |
+--------+---------+----------+---------+----------+

> The shortest path from A to a non-tree vertex is 100, to vertex C, so
> C is added to the tree.
>
> Next time through the shortest-path array, only the distance to E is
> considered. It can be shortened by going via C, so we have the entries
> shown in Table 14.10.
>
> ***TABLE 14.10*** Step 4: The Shortest-Path Array

+--------+---------+----------+---------+----------+
| **A**  | > **B** | > **C**  | > **D** | > **E**  |
+========+=========+==========+=========+==========+
| inf(A) | > 50(A) | > 100(D) | > 80(A) | > 140(C) |
+--------+---------+----------+---------+----------+

> Now the last vertex, E, is added to the tree, and you're done. The
> shortest-path array shows the shortest distances from A to all the
> other vertices. The tree consists of all the vertices and the edges
> AB, AD, DC, and CE, shown with thick lines.
>
> You can work backward to reconstruct the sequence of vertices along
> the shortest path to any vertex. For the shortest path to E, for
> example, the parent of E, shown in the array in parentheses, is C. The
> predecessor of C, again from the array, is D, and the predecessor of D
> is A. So the shortest path from A to E follows the route A--D--C--E.
>
> Experiment with other graphs using GraphDW, starting with small ones.
> You'll find that after a while you can predict what the algorithm is
> going to do, and you'll be on your way to understanding Dijkstra's
> algorithm.
>
> 698 **CHAPTER 14** Weighted Graphs

##### Java Code

> The code for the shortest-path algorithm is among the most complex in
> this book, but even so it's not beyond mere mortals. We'll look first
> at a helper class and then at the chief method that executes the
> algorithm, path(), and finally at two methods called by path() to
> carry out specialized tasks.
>
> **The** sPath **Array and the** DistPar **Class**
>
> As we've seen, the key data structure in the shortest-path algorithm
> is an array that keeps track of the minimum distances from the
> starting vertex to the other vertices (destination vertices). During
> the execution of the algorithm, these distances are changed, until at
> the end they hold the actual shortest distances from the start. In the
> example code, this array is called sPath\[\] (for shortest paths).
>
> As we've seen, it's important to record not only the minimum distance
> from the starting vertex to each destination vertex, but also the path
> taken. Fortunately, the entire path need not be explicitly stored.
> It's only necessary to store the parent of the destination vertex. The
> parent is the vertex reached just before the destination.
>
> We've seen this in the Workshop applet, where, if 100(D) appears in
> the C column, it means that the cheapest path from A to C is 100, and
> D is the last vertex before C on this path.
>
> There are several ways to keep track of the parent vertex, but we
> choose to combine the parent with the distance and put the resulting
> object into the sPath\[\] array. We call this class of objects DistPar
> (for distance-parent).
>
> class DistPar // distance and parent
>
> { // items stored in sPath array
>
> public int distance; // distance from start to this vertex public int
> parentVert; // current parent of this vertex
>
> public DistPar(int pv, int d) // constructor
>
> {
>
> distance = d; parentVert = pv;
>
> }
>
> }
>
> **The** path() **method**
>
> The path() method carries out the actual shortest-path algorithm. It
> uses the DistPar class and the Vertex class, which we saw in the
> mstw.java program (Listing 14.1). The path() method is a member of the
> Graph class, which we also saw in mstw.java in a somewhat different
> version.
>
> The Shortest-Path Problem 699
>
> public void path() // find all shortest paths
>
> {
>
> int startTree = 0; // start at vertex 0
> vertexList\[startTree\].isInTree = true;
>
> nTree = 1; // put it in tree
>
> // transfer row of distances from adjMat to sPath for(int j=0;
> j\<nVerts; j++)
>
> {
>
> int tempDist = adjMat\[startTree\]\[j\]; sPath\[j\] = new
> DistPar(startTree, tempDist);
>
> }
>
> // until all vertices are in the tree while(nTree \< nVerts)
>
> {
>
> int indexMin = getMin(); // get minimum from sPath int minDist =
> sPath\[indexMin\].distance;
>
> if(minDist == INFINITY) // if all infinite
>
> { // or in tree,
>
> System.out.println("There are unreachable vertices"); break; // sPath
> is complete
>
> }
>
> else
>
> { // reset currentVert
>
> currentVert = indexMin; // to closest vert startToCurrent =
> sPath\[indexMin\].distance;
>
> // minimum distance from startTree is
>
> // to currentVert, and is startToCurrent
>
> }
>
> // put current vertex in tree vertexList\[currentVert\].isInTree =
> true; nTree++;
>
> adjust\_sPath(); // update sPath\[\] array
>
> } // end while(nTree\<nVerts)
>
> displayPaths(); // display sPath\[\] contents
>
> nTree = 0; // clear tree for(int j=0; j\<nVerts; j++)
>
> vertexList\[j\].isInTree = false;
>
> } // end path()
>
> 700 **CHAPTER 14** Weighted Graphs
>
> The starting vertex is always at index 0 of the vertexList\[\] array.
> The first task in path() is to put this vertex into the tree. As the
> algorithm proceeds, we'll be moving other vertices into the tree as
> well. The Vertex class contains a flag that indicates whether a vertex
> object is in the tree. Putting a vertex in the tree consists of
> setting this flag and incrementing nTree, which counts how many
> vertices are in the tree.
>
> Second, path() copies the distances from the appropriate row of the
> adjacency matrix to sPath\[\]. This is always row 0, because for
> simplicity we assume 0 is the index of the starting vertex. Initially,
> the parent field of all the sPath\[\] entries is A, the start- ing
> vertex.
>
> We now enter the main while loop of the algorithm. This loop
> terminates after all the vertices have been placed in the tree. There
> are basically three actions in this loop:

1.  Choose the sPath\[\] entry with the minimum distance.

2.  Put the corresponding vertex (the column head for this entry) in the
    tree. This becomes the "current vertex," currentVert.

3.  Update all the sPath\[\] entries to reflect distances from
    currentVert.

> If path() finds that the minimum distance is infinity, it knows that
> some vertices are unreachable from the starting point. Why? Because
> not all the vertices are in the tree (the while loop hasn't
> terminated), and yet there's no way to get to these extra vertices; if
> there were, there would be a non-infinite distance.
>
> Before returning, path() displays the final contents of sPath\[\] by
> calling the displayPaths() method. This is the only output from the
> program. Also, path() sets nTree to 0 and removes the isInTree flags
> from all the vertices, in case they might be used again by another
> algorithm (although they aren't in this program).

####### Finding the Minimum Distance with getMin()

> To find the sPath\[\] entry with the minimum distance, path() calls
> the getMin() method. This routine is straightforward; it steps across
> the sPath\[\] entries and returns with the column number (the array
> index) of the entry with the minimum distance.
>
> public int getMin() // get entry from sPath
>
> { // with minimum distance
>
> int minDist = INFINITY; // assume large minimum int indexMin = 0;
>
> for(int j=1; j\<nVerts; j++) // for each vertex,
>
> { // if it's in tree and
>
> if( !vertexList\[j\].isInTree && // smaller than old one
>
> sPath\[j\].distance \< minDist )
>
> The Shortest-Path Problem 701
>
> {
>
> minDist = sPath\[j\].distance;
>
> indexMin = j; // update minimum
>
> }
>
> } // end for
>
> return indexMin; // return index of minimum
>
> } // end getMin()
>
> We could have used a priority queue as the basis for the shortest-path
> algorithm, as we did in the previous section to find the minimum
> spanning tree. If we had, the getMin() method would not have been
> necessary; the minimum-weight edge would have appeared automatically
> at the front of the queue. However, the array approach shown makes it
> easier to see what's going on.
>
> **Updating** sPath\[\] **with** adjust\_sPath()
>
> The adjust\_sPath() method is used to update the sPath\[\] entries to
> reflect new infor- mation obtained from the vertex just inserted in
> the tree. When this routine is called, currentVert has just been
> placed in the tree, and startToCurrent is the current entry in
> sPath\[\] for this vertex. The adjust\_sPath() method now examines
> each vertex entry in sPath\[\], using the loop counter column to point
> to each vertex in turn. For each sPath\[\] entry, provided the vertex
> is not in the tree, it does three things:

1.  It adds the distance to the current vertex (already calculated and
    now in startToCurrent) to the edge distance from currentVert to the
    column vertex. We call the result startToFringe.

2.  It compares startToFringe with the current entry in sPath\[\].

3.  If startToFringe is less, it replaces the entry in sPath\[\].

> This is the heart of Dijkstra's algorithm. It keeps sPath\[\] updated
> with the shortest distances to all the vertices that are currently
> known. Here's the code for adjust\_sPath():
>
> public void adjust\_sPath()
>
> {
>
> // adjust values in shortest-path array sPath
>
> int column = 1; // skip starting vertex while(column \< nVerts) // go
> across columns
>
> {
>
> // if this column's vertex already in tree, skip it if(
> vertexList\[column\].isInTree )
>
> {
>
> column++; continue;
>
> 702 **CHAPTER 14** Weighted Graphs
>
> }
>
> // calculate distance for one sPath entry
>
> // get edge from currentVert to column int currentToFringe =
> adjMat\[currentVert\]\[column\];
>
> // add distance from start
>
> int startToFringe = startToCurrent + currentToFringe;
>
> // get distance of current sPath entry int sPathDist =
> sPath\[column\].distance;
>
> // compare distance from start with sPath entry if(startToFringe \<
> sPathDist) // if shorter,
>
> { // update sPath
>
> sPath\[column\].parentVert = currentVert; sPath\[column\].distance =
> startToFringe;
>
> }
>
> column++;
>
> } // end while(column \< nVerts)
>
> } // end adjust\_sPath()
>
> The main() routine in the path.java program creates the tree of Figure
> 14.6 and displays its shortest-path array. Here's the code:
>
> public static void main(String\[\] args)
>
> {
>
> Graph theGraph = new Graph();

+-------------------------------+----+------+-----------+
| > theGraph.addVertex('A');    | // | 0    | > (start) |
+===============================+====+======+===========+
| > theGraph.addVertex('B');    | // | 1    |           |
+-------------------------------+----+------+-----------+
| > theGraph.addVertex('C');    | // | 2    |           |
+-------------------------------+----+------+-----------+
| > theGraph.addVertex('D');    | // | 3    |           |
+-------------------------------+----+------+-----------+
| > theGraph.addVertex('E');    | // | 4    |           |
+-------------------------------+----+------+-----------+
| > theGraph.addEdge(0, 1, 50); | // | > AB | > 50      |
+-------------------------------+----+------+-----------+
| > theGraph.addEdge(0, 3, 80); | // | > AD | > 80      |
+-------------------------------+----+------+-----------+
| > theGraph.addEdge(1, 2, 60); | // | > BC | > 60      |
+-------------------------------+----+------+-----------+
| > theGraph.addEdge(1, 3, 90); | // | > BD | > 90      |
+-------------------------------+----+------+-----------+
| > theGraph.addEdge(2, 4, 40); | // | > CE | > 40      |
+-------------------------------+----+------+-----------+
| > theGraph.addEdge(3, 2, 20); | // | > DC | > 20      |
+-------------------------------+----+------+-----------+
| > theGraph.addEdge(3, 4, 70); | // | > DE | > 70      |
+-------------------------------+----+------+-----------+
| > theGraph.addEdge(4, 1, 50); | // | > EB | > 50      |
+-------------------------------+----+------+-----------+

> System.out.println("Shortest paths"); theGraph.path(); // shortest
> paths System.out.println();
>
> } // end main()
>
> The Shortest-Path Problem 703
>
> The output of this program is
>
> A=inf(A) B=50(A) C=100(D) D=80(A) E=140(C)
>
> **The** path.java **Program**
>
> Listing 14.2 shows the complete code for the path.java program. Its
> various components were all discussed earlier.
>
> ***LISTING 14.2*** The path.java Program
>
> // path.java
>
> // demonstrates shortest path with weighted, directed graphs
>
> // to run this program: C\>java PathApp
>
> //////////////////////////////////////////////////////////////// class
> DistPar // distance and parent
>
> { // items stored in sPath array
>
> public int distance; // distance from start to this vertex public int
> parentVert; // current parent of this vertex
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public DistPar(int pv, int d) // constructor
>
> {
>
> distance = d; parentVert = pv;
>
> }
>
> } // end class DistPar
>
> /////////////////////////////////////////////////////////////// class
> Vertex
>
> {
>
> public char label; // label (e.g. 'A') public boolean isInTree;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Vertex(char lab) // constructor
>
> {
>
> label = lab; isInTree = false;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Vertex
>
> //////////////////////////////////////////////////////////////// class
> Graph
>
> {
>
> private final int MAX\_VERTS = 20;
>
> 704 **CHAPTER 14** Weighted Graphs
>
> ***LISTING 14.2*** Continued
>
> private final int INFINITY = 1000000;
>
> private Vertex vertexList\[\]; // list of vertices private int
> adjMat\[\]\[\]; // adjacency matrix
>
> private int nVerts; // current number of vertices private int nTree;
> // number of verts in tree private DistPar sPath\[\]; // array for
> shortest-path data private int currentVert; // current vertex
>
> private int startToCurrent; // distance to currentVert

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public Graph() // constructor
>
> {
>
> vertexList = new Vertex\[MAX\_VERTS\];
>
> // adjacency matrix adjMat = new int\[MAX\_VERTS\]\[MAX\_VERTS\];
>
> nVerts = 0;
>
> nTree = 0;
>
> for(int j=0; j\<MAX\_VERTS; j++) // set adjacency for(int k=0;
> k\<MAX\_VERTS; k++) // matrix
>
> adjMat\[j\]\[k\] = INFINITY; // to infinity sPath = new
> DistPar\[MAX\_VERTS\]; // shortest paths
>
> } // end constructor

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void addVertex(char lab)
>
> {
>
> vertexList\[nVerts++\] = new Vertex(lab);
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void addEdge(int start, int end, int weight)
>
> {
>
> adjMat\[start\]\[end\] = weight; // (directed)
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void path() // find all shortest paths
>
> {
>
> int startTree = 0; // start at vertex 0
> vertexList\[startTree\].isInTree = true;
>
> nTree = 1; // put it in tree
>
> // transfer row of distances from adjMat to sPath for(int j=0;
> j\<nVerts; j++)
>
> {
>
> The Shortest-Path Problem 705
>
> ***LISTING 14.2*** Continued
>
> int tempDist = adjMat\[startTree\]\[j\]; sPath\[j\] = new
> DistPar(startTree, tempDist);
>
> }
>
> // until all vertices are in the tree while(nTree \< nVerts)
>
> {
>
> int indexMin = getMin(); // get minimum from sPath int minDist =
> sPath\[indexMin\].distance;
>
> if(minDist == INFINITY) // if all infinite
>
> { // or in tree,
>
> System.out.println("There are unreachable vertices"); break; // sPath
> is complete
>
> }
>
> else
>
> { // reset currentVert
>
> currentVert = indexMin; // to closest vert startToCurrent =
> sPath\[indexMin\].distance;
>
> // minimum distance from startTree is
>
> // to currentVert, and is startToCurrent
>
> }
>
> // put current vertex in tree vertexList\[currentVert\].isInTree =
> true; nTree++;
>
> adjust\_sPath(); // update sPath\[\] array
>
> } // end while(nTree\<nVerts)
>
> displayPaths(); // display sPath\[\] contents
>
> nTree = 0; // clear tree for(int j=0; j\<nVerts; j++)
>
> vertexList\[j\].isInTree = false;
>
> } // end path()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public int getMin() // get entry from sPath

> { // with minimum distance
>
> int minDist = INFINITY; // assume minimum int indexMin = 0;
>
> for(int j=1; j\<nVerts; j++) // for each vertex,
>
> { // if it's in tree and
>
> 706 **CHAPTER 14** Weighted Graphs
>
> ***LISTING 14.2*** Continued
>
> if( !vertexList\[j\].isInTree && // smaller than old one
>
> sPath\[j\].distance \< minDist )
>
> {
>
> minDist = sPath\[j\].distance;
>
> indexMin = j; // update minimum
>
> }
>
> } // end for
>
> return indexMin; // return index of minimum
>
> } // end getMin()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void adjust\_sPath()

> {
>
> // adjust values in shortest-path array sPath
>
> int column = 1; // skip starting vertex while(column \< nVerts) // go
> across columns
>
> {
>
> // if this column's vertex already in tree, skip it if(
> vertexList\[column\].isInTree )
>
> {
>
> column++; continue;
>
> }
>
> // calculate distance for one sPath entry
>
> // get edge from currentVert to column int currentToFringe =
> adjMat\[currentVert\]\[column\];
>
> // add distance from start
>
> int startToFringe = startToCurrent + currentToFringe;
>
> // get distance of current sPath entry int sPathDist =
> sPath\[column\].distance;
>
> // compare distance from start with sPath entry if(startToFringe \<
> sPathDist) // if shorter,
>
> { // update sPath
>
> sPath\[column\].parentVert = currentVert; sPath\[column\].distance =
> startToFringe;
>
> }
>
> column++;
>
> } // end while(column \< nVerts)

} // end adjust\_sPath()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void displayPaths()

> The Shortest-Path Problem 707
>
> ***LISTING 14.2*** Continued
>
> {
>
> for(int j=0; j\<nVerts; j++) // display contents of sPath\[\]
>
> {
>
> System.out.print(vertexList\[j\].label + "="); // B=
> if(sPath\[j\].distance == INFINITY)
>
> System.out.print("inf"); // inf else
>
> System.out.print(sPath\[j\].distance); // 50 char parent =
> vertexList\[ sPath\[j\].parentVert \].label; System.out.print("(" +
> parent + ") "); // (A)
>
> }
>
> System.out.println("");
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Graph
>
> //////////////////////////////////////////////////////////////// class
> PathApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> Graph theGraph = new Graph();

+-------------------------------+------+------+-----------+
| > theGraph.addVertex('A');    | > // | > 0  | > (start) |
+===============================+======+======+===========+
| > theGraph.addVertex('C');    | > // | > 2  |           |
+-------------------------------+------+------+-----------+
| > theGraph.addVertex('B');    | > // | > 1  |           |
+-------------------------------+------+------+-----------+
| > theGraph.addVertex('D');    | > // | > 3  |           |
+-------------------------------+------+------+-----------+
| > theGraph.addVertex('E');    | > // | > 4  |           |
+-------------------------------+------+------+-----------+
| > theGraph.addEdge(0, 1, 50); | > // | > AB | > 50      |
+-------------------------------+------+------+-----------+
| > theGraph.addEdge(0, 3, 80); | > // | > AD | > 80      |
+-------------------------------+------+------+-----------+
| > theGraph.addEdge(1, 2, 60); | > // | > BC | > 60      |
+-------------------------------+------+------+-----------+
| > theGraph.addEdge(1, 3, 90); | > // | > BD | > 90      |
+-------------------------------+------+------+-----------+
| > theGraph.addEdge(2, 4, 40); | > // | > CE | > 40      |
+-------------------------------+------+------+-----------+
| > theGraph.addEdge(3, 2, 20); | > // | > DC | > 20      |
+-------------------------------+------+------+-----------+
| > theGraph.addEdge(3, 4, 70); | > // | > DE | > 70      |
+-------------------------------+------+------+-----------+
| > theGraph.addEdge(4, 1, 50); | > // | > EB | > 50      |
+-------------------------------+------+------+-----------+

> System.out.println("Shortest paths"); theGraph.path(); // shortest
> paths System.out.println();
>
> } // end main()
>
> } // end class PathApp
>
> ////////////////////////////////////////////////////////////////
>
> 708 **CHAPTER 14** Weighted Graphs

#### The All-Pairs Shortest-Path Problem

> In discussing connectivity in Chapter 13, we wanted to know whether it
> was possible to fly from Athens to Murmansk if we didn't care how many
> stops we made. With weighted graphs we can answer the second question
> that might occur to you as you wait at the Hubris Airlines ticket
> counter: How much will the journey cost?
>
> To find whether a trip was possible, we created a connectivity table.
> With weighted graphs we want a table that gives the minimum cost from
> any vertex to any other vertex using multiple edges. This is called
> the *all-pairs shortest-path* problem.
>
> You can create such a table by running the path.java program using
> each vertex in turn as the starting vertex. This will yield something
> like Table 14.11.
>
> ***TABLE 14.11*** All-Pairs Shortest-Path Table

+---+---------+---------+--------+--------+---------+
|   | > **A** | > **B** | **C**  | **D**  | > **E** |
+===+=========+=========+========+========+=========+
| A | > ----  | > 50    | > 100  | > 80   | > 140   |
+---+---------+---------+--------+--------+---------+
| B | > ----  | > ----  | > 60   | > 90   | > 100   |
+---+---------+---------+--------+--------+---------+
| C | > ----  | > 90    | > ---- | > 180  | > 40    |
+---+---------+---------+--------+--------+---------+
| D | > ----  | > 110   | > 20   | > ---- | > 60    |
+---+---------+---------+--------+--------+---------+
| E | > ----  | > 50    | > 110  | > 140  | > ----  |
+---+---------+---------+--------+--------+---------+

> In the preceding chapter we found that Warshall's algorithm was a
> quicker way to create a table showing which vertices could be reached
> from a given vertex using one or many steps. An analogous approach for
> weighted graphs uses Floyd's algorithm, discovered by Robert Floyd in
> 1962. This is another way to create the kind of table shown in Table
> 14.11.
>
> Let's discuss Floyd's algorithm with a simpler graph. Figure 14.11
> shows a weighted directed graph and its adjacency matrix.
>
> A B C D
>
> A B C D
>
> ***FIGURE 14.11*** A weighted graph and its adjacency matrix.
>
> The adjacency matrix shows the cost of all the one-edge paths. We want
> to extend this matrix to show the cost of all paths regardless of
> length. For example, it's clear
>
> The All-Pairs Shortest-Path Problem 709
>
> from Figure 14.11 that we can go from B to C at a cost of 30 (10 from
> B to D plus 20 from D to C).
>
> As in Warshall's algorithm we systematically modify the adjacency
> matrix. We examine every cell in every row. If there's a non-zero
> weight (say a 30 at row C column A), we then look in column C (because
> C is the row where the 30 is). If we find an entry in column C (say a
> 40 at row D), we know there is a path from C to A with a weight of 30
> and a path from D to C with a weight of 40. From this, we can deduce
> that there's a two-edge path from D to A with a weight of 70. Figure
> 14.12 shows the steps when Floyd's algorithm is applied to the graph
> in Figure 14.11.

a)

y = 2, x = 0, z = 3

A B C D

> A B C D
>
> b)
>
> y = 3, x = 0, z = 1
>
> A B C D
>
> A B C D
>
> c)
>
> y = 3, x = 2, z = 1
>
> A B C D
>
> A B C D
>
> C A & D C 30 20
>
> D A & B D 50 10
>
> D C & B D 20 10
>
> so D A 50
>
> ***FIGURE 14.12*** Floyd's algorithm.
>
> so B A 60
>
> so B C 30
>
> Row A is empty, so there's nothing to do there. In row B there's a 70
> in column A and a 10 in column D, but there's nothing in column B, so
> the entries in row B can't be combined with any edges ending on B.
>
> In row C, however, we find a 30 at column A. Looking in column C, we
> find a 20 at row D. Now we have C to A with a weight of 30 and D to C
> with a weight of 20, so we have D to A with a weight of 50.
>
> Row D shows an interesting situation: We will lower an existing cost.
> There's a 50 in column A. There's also 10 in row B of column D, so we
> know there's a path from B to A with a cost of 60. However, there's
> already a cost of 70 in this cell. What do we do? Because 60 is less
> than 70, we replace the 70 with 60. In the case of multiple paths from
> one vertex to another, we want the table to reflect the path with the
> lowest cost.
>
> The implementation of Floyd's algorithm is similar to that for
> Warshall's algorithm. However, instead of simply inserting a 1 into
> the table when a two-edge path is found, we add the costs of the two
> one-edge paths and insert the sum. We'll leave the details as an
> exercise.
>
> 710 **CHAPTER 14** Weighted Graphs

#### Efficiency

> So far we haven't discussed the efficiency of the various graph
> algorithms. The issue is complicated by the two ways of representing
> graphs: the adjacency matrix and adjacency lists.
>
> If an adjacency matrix is used, the algorithms we've discussed mostly
> require O(V2) time, where V is the number of vertices. Why? If you
> analyze the algorithms, you'll see that they involve examining each
> vertex once, and for that vertex going across its row in the adjacency
> matrix, looking at each edge in turn. In other words, each cell of the
> adjacency matrix, which has V2 cells, is examined.
>
> For large matrices O(V2) isn't very good performance. If the graph is
> dense, there isn't much we can do about improving this performance.
> (As we noted earlier, by *dense* we mean a graph that has many
> edges---one in which many or most of the cells in the adjacency matrix
> are filled.)
>
> However, many graphs are *sparse*, the opposite of dense. There's no
> clear-cut defini- tion of how many edges a graph must have to be
> described as sparse or dense, but if each vertex in a large graph is
> connected by only a few edges, the graph would normally be described
> as sparse.
>
> In a sparse graph, running times can be improved by using the
> adjacency-list repre- sentation rather than the adjacency matrix. This
> is easy to understand: You don't waste time examining adjacency-matrix
> cells that don't hold edges.
>
> For unweighted graphs the depth-first search with adjacency lists
> requires O(V+E) time, where V is the number of vertices and E is the
> number of edges. For weighted graphs, both the minimum spanning tree
> and the shortest-path algorithm require O((E+V)logV) time. In large,
> sparse graphs these times can represent dramatic improvements over the
> adjacency matrix approach. However, the algorithms are somewhat more
> complicated, which is why we've used the adjacency-matrix approach
> throughout this chapter. You can consult Sedgewick (see Appendix B,
> "Further Reading") and other writers for examples of graph algorithms
> using the adjacency-list approach.
>
> Warshall's and Floyd's algorithms are slower than the other algorithms
> we've discussed so far in this book. They both operate in O(V3) time.
> This is the result of the three nested loops used in their
> implementation.

#### Intractable Problems

> In this book we've seen big O values ranging from O(1), through O(N),
> O(N\*logN), O(N2), up to (for Warshall's and Floyd's algorithms)
> O(N3). Even O(N3) can be solved in a reasonable length of time for
> values N in the thousands. Algorithms with these big O values can be
> used to find solutions to most practical problems.

Intractable Problems 711

> However, some algorithms have big O values that are so large that they
> can be used only for relatively small values of N. Many real-world
> problems that require such algorithms simply cannot be solved in a
> reasonable length of time. Such problems are said to be *intractable*.
> (Another term used for such problems is *NP complete*, where NP means
> non-deterministic polynomial. An explanation of what this means is
> beyond the scope of this book.)

##### The Knight's Tour

> The Knight's Tour (Programming Project 13.5 in Chapter 13) is an
> example of an intractable problem because the number of possible moves
> is so large. The total number of possible move sequences is difficult
> to calculate, but we can approximate it. Each move can end on a
> maximum of eight squares. This number is reduced by moves that would
> be off the edge of the board and moves that would end on a square that
> was already visited. In the early stages of a tour, there will be
> closer to eight moves, but this number will gradually decrease as the
> board fills up. Let's assume (conservatively) an average of only two
> possible moves from each position. After the initial square, the
> knight can visit 63 more squares. Thus, there is a total of 263
> possible moves. This is about 1019. Assume a computer can make a
> million moves a second (106). There are roughly 107 seconds in a year,
> so the computer can make 1013 moves in a year. Solving the puzzle by
> brute force can therefore be expected to take 106 or around a million
> years.
>
> This particular problem can be made more tractable if strategies are
> used to "prune" the game tree. One is Warnsdorff's heuristic (H.C. von
> Warnsdorff, 1823), which specifies that you always move to the square
> that has the fewest possible exit moves.

##### The Traveling Salesman Problem

> Here's another famous intractable problem. Suppose you're a
> salesperson and you need to drive to all the cities where you have
> clients. You would like to minimize the number of miles you travel.
> You know the distance from each city to every other city. You want to
> start in your home city, visit each client city once and only once,
> and return to your home city. In what sequence should you visit these
> cities to mini- mize the total miles traveled? In graph theory this is
> called the *traveling salesman problem*, often abbreviated TSP.
>
> Figure 14.13 shows an arrangement of cities and distances. What's the
> shortest way to travel from A through each of the other cities and
> back to A? Notice that it's not necessary that every pair of cities be
> connected by an edge. Because of geography it may be impossible to
> drive from Washington, D.C., to New York without going through
> Philadelphia, for example.
>
> 712 **CHAPTER 14** Weighted Graphs
>
> ***FIGURE 14.13*** Cities and distances.
>
> To find the shortest route, you list all the possible permutations of
> cities (Boston- Seattle-Miami, Boston-Miami-Seattle,
> Miami-Boston-Seattle, and so on) and calculate the total distance for
> each permutation. The route ABCEDA has a total length of 318. The
> route ABCDEA is impossible because there is no edge from E back to A.
>
> Unfortunately, the number of permutations can be very large: It's the
> factorial of the number of cities (not counting your home city). If
> there are 6 cities to visit, there are 6 choices for the first city, 5
> for the second, 4 for the third, and so on; a total of
> 6\*5\*4\*3\*2\*1 or 720 possible routes. The problem is impractical to
> solve for even 50 cities. Again, there are strategies to reduce the
> number of sequences that must be checked, but this helps only a
> little. A weighted graph is used to implement the problem, with
> weights representing miles and vertices representing the cities. The
> graph can be non-directed if the distance is the same going from A to
> B as from B to A, as it usually is when driving. If the weights
> represent airfares, they may be differ- ent in different directions,
> in which case a directed graph is used.

##### Hamiltonian Cycles

> A problem that's similar to the TSP but more abstract is that of
> finding the Hamiltonian cycle of a graph. As we noted earlier, a cycle
> is a path that starts and ends on the same vertex. A Hamiltonian cycle
> is one that visits every other vertex in the graph exactly once.
> Unlike we did with the TSP, we don't care about distances; all we want
> to know is whether such a cycle exists. In Figure 14.13 the route
> ABCEDA is a Hamiltonian cycle, while ABCDEA is not. The Knight's Tour
> problem is an example of a Hamiltonian cycle (if you assume the knight
> returns to its starting square).
>
> Finding a Hamiltonian cycle takes the same O(N!) time as the TSP.
> You'll see the term *exponential time* used for big O values such as
> 2N and N! (which grows even more rapidly than the exponential 2N).

Questions 713

#### Summary

-   In a weighted graph, edges have an associated number called the
    weight, which might represent distances, costs, times, or other
    quantities.

-   The minimum spanning tree in a weighted graph minimizes the weights
    of the edges necessary to connect all the vertices.

-   An algorithm using a priority queue can be used to find the minimum
    spanning tree of a weighted graph.

-   The minimum spanning tree of a weighted graph models real-world
    situations such as installing utility cables between cities.

-   The shortest-path problem in a non-weighted graph involves finding
    the minimum number of edges between two vertices.

-   Solving the shortest-path problem for weighted graphs yields the
    path with the minimum total edge weight.

-   The shortest-path problem for weighted graphs can be solved with
    Dijkstra's algorithm.

-   The algorithms for large, sparse graphs generally run much faster if
    the adja- cency-list representation of the graph is used rather than
    the adjacency matrix.

-   The all-pairs shortest-path problem is to find the total weight of
    the edges between every pair of vertices in a graph. Floyd's
    algorithm can be used to solve this problem.

-   Some graph algorithms take exponential time and are therefore not
    practical for graphs with more than a few vertices.

#### Questions

> These questions are intended as a self-test for readers. Answers may
> be found in Appendix C.

1.  The weight in a weighted graph is a property of the graph's [
    ]{.underline} .

2.  In a weighted graph, the minimum spanning tree (MST) tries to
    minimize

    a.  the number of edges from the starting vertex to a specified
        vertex.

    b.  the number of edges connecting all the vertices.

    c.  the total weight of the edges from the starting vertex to a
        specified vertex.

    d.  the total weight of edges connecting all the vertices.

> 714 **CHAPTER 14** Weighted Graphs

3.  True or False: The weight of the MST depends on the starting vertex.

4.  In the MST algorithm, what is removed from the priority queue?

5.  In the cable TV example, each edge added to the MST connects

    e.  the starting vertex to an adjacent vertex.

    f.  an already-connected city to an unconnected city.

    g.  the current vertex to an adjacent vertex.

    h.  two cities with offices.

6.  The MST algorithm "prunes" an edge from the list when the edge leads
    to a vertex that [ ]{.underline} .

7.  True or False: The shortest-path problem (SPP) must be carried out
    on a directed graph.

8.  Dijkstra's algorithm finds the shortest path

    i.  from one specified vertex to all other vertices.

    j.  from one specified vertex to another specified vertex.

    k.  from all vertices to all other vertices that can be reached
        along one edge.

    l.  from all vertices to all other vertices that can be reached
        along multiple edges.

9.  True or False: The rule in Dijkstra's algorithm is to always put in
    the tree the vertex that is closest to the starting vertex.

10. In the railroad fares example, a fringe town is one

    m.  to which the distance is known, but from which no distances are
        known.

    n.  which is in the tree.

    o.  to which the distance is known and which is in the tree.

    p.  which is completely unknown.

11. The all-pairs shortest-path problem involves finding the shortest
    path

    q.  from the starting vertex to every other vertex.

    r.  from every vertex to every other vertex.

    s.  from the starting vertex to every vertex that is one edge away.

    t.  from every vertex to every other vertex that is one or more
        edges away.

Programming Projects 715

12. Floyd's algorithm is to weighted graphs what [ ]{.underline} is to
    unweighted graphs.

13. Floyd's algorithm uses the [ ]{.underline} representation of a
    graph.

14. What is an approximate big O time for an attempt to solve the
    knight's tour?

15. In Figure 14.13, is the route ABCEDA the minimum solution for the
    traveling salesman problem?

#### Experiments

> Carrying out these experiments will help to provide insights into the
> topics covered in the chapter. No programming is involved.

1.  Use the GraphW Workshop applet to find the minimum spanning tree of
    the graph shown in Figure 14.6, "Train fares in Magnaguena."
    Consider the graph to be undirected; that is, ignore the arrows.

2.  Use the GraphDW Workshop applet to solve the shortest-path problem
    for the graph in Figure 14.6, "Train fares in Magnaguena," but
    derive new weights for all the edges by subtracting those shown in
    the figure from 100.

3.  Draw a graph with five vertices and five edges. Then use pencil and
    paper to implement Djikstra's algorithm for this graph. Show the
    tree and the shortest- path array at each step.

#### Programming Projects

> Writing programs to solve the Programming Projects helps to solidify
> your under- standing of the material and demonstrates how the
> chapter's concepts are applied. (As noted in the Introduction,
> qualified instructors may obtain completed solutions to the
> Programming Projects on the publisher's Web site.)

1.  Modify the path.java program (Listing 14.2) to print a table of the
    minimum costs to get from any vertex to any other vertex. This
    exercise will require some fiddling with routines that assume the
    starting vertex is always A.

    So far we've implemented graphs as adjacency matrices or adjacency
    lists. Another approach is to use Java references to represent
    edges, so that a Vertex object contains a list of references to
    other vertices that it's connected to. In a directed graph a
    reference used this way is especially intuitive because it "points"
    from one vertex to another. Write a program that implements this
    scheme. The main() method should be similar to main() in the
    path.java program (Listing 14.2) so that it creates the graph shown
    in Figure 14.6 using the same addVertex() and addEdge() calls. It
    should then display a connectivity

> 716 **CHAPTER 14** Weighted Graphs
>
> table of the graph to prove that the graph is constructed properly.
> You'll need to store the weight of each edge somewhere. One approach
> is to use an Edge class, which stores its weight and the vertex on
> which it ends. Each vertex then keeps a list of Edge objects---that
> is, edges that start on that vertex.

3.  Implement Floyd's algorithm. You can start with the path.java
    program (Listing 14.2) and modify it as appropriate. For instance,
    you can delete all the shortest- path code. Keep the infinity
    representation for unreachable vertices. By doing this, you will
    avoid the need to check for 0 when comparing an existing cost with a
    newly derived cost. The costs on all possible routes will be less
    than infinity. You should be able to enter graphs of arbitrary
    complexity into main().

    Implement the traveling salesman problem described in the
    "Intractable Problems" section in this chapter. In spite of its
    intractability, it will have no trouble solving the problem for
    small N, say 10 cities or fewer. Try a non- directed graph. Use the
    brute-force approach of testing every possible sequence of cities.
    For a way to permute the sequence of cities, see the anagram.java
    program (Listing 6.2) in Chapter 6, "Recursion." Use infinity to
    represent non- existent edges. That way, you won't need to abort the
    calculation of a sequence when it turns out that an edge from one
    city to the next does not exist; any total greater than infinity is
    an impossible route. Also, don't worry about elimi- nating
    symmetrical routes. Display both ABCDEA and AEDCBA, for example.

    Write a program that discovers and displays all the Hamiltonian
    cycles of a weighted, non-directed graph.
