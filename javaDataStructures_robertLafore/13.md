13
==

Graphs
------

> Graphs are one of the most versatile structures used in computer
> programming. The sorts of problems that graphs can help to solve are
> generally quite different from those
>
> we've dealt with thus far in this book. If you're dealing with general
> kinds of data storage problems, you probably won't need a graph, but
> for some problems---and they tend to be interesting ones---a graph is
> indispensable.
>
> Our discussion of graphs is divided into two chapters. In this chapter
> we'll cover the algorithms associated with unweighted graphs, show
> some algorithms that these graphs can represent, and present two
> Workshop applets to model them. In the next chapter we'll look at the
> more complicated algorithms associated with weighted graphs.

#### Introduction to Graphs

> Graphs are data structures rather like trees. In fact, in a
> mathematical sense, a tree is a kind of graph. In computer
> programming, however, graphs are used in different ways than trees.
>
> The data structures examined previously in this book have an
> architecture dictated by the algorithms used on them. For example, a
> binary tree is shaped the way it is because that shape makes it easy
> to search for data and insert new data. The edges in a tree represent
> quick ways to get from node to node.
>
> Graphs, on the other hand, often have a shape dictated by a physical
> or abstract problem. For example, nodes in a graph may represent
> cities, while edges may represent airline flight routes between the
> cities. Another more abstract example is a graph representing the
> individual

##### IN THIS CHAPTER

-   Introduction to Graphs

-   Searches

-   Minimum Spanning Trees

-   Topological Sorting with Directed Graphs

-   Connectivity in Directed Graphs

> 616 **CHAPTER 13** Graphs
>
> tasks necessary to complete a project. In the graph, nodes may
> represent tasks, while directed edges (with an arrow at one end)
> indicate which task must be completed before another. In both cases,
> the shape of the graph arises from the specific real- world situation.
>
> Before going further, we must mention that, when discussing graphs,
> nodes are tradi- tionally called *vertices* (the singular is
> *vertex*). This is probably because the nomencla- ture for graphs is
> older than that for trees, having arisen in mathematics centuries ago.
> Trees are more closely associated with computer science. However, both
> terms are used more or less interchangeably.

##### Definitions

> Figure 13.1a shows a simplified map of the freeways in the vicinity of
> San Jose, California. Figure 13.1b shows a graph that models these
> freeways.
>
> In the graph, circles represent freeway interchanges, and straight
> lines connecting the circles represent freeway segments. The circles
> are *vertices*, and the lines are *edges*. The vertices are usually
> labeled in some way---often, as shown here, with letters of the
> alphabet. Each edge is bounded by the two vertices at its ends.
>
> The graph doesn't attempt to reflect the geographical positions shown
> on the map; it shows only the relationships of the vertices and the
> edges---that is, which edges are connected to which vertex. It doesn't
> concern itself with physical distances or direc- tions. Also, one edge
> may represent several different route numbers, as in the case of the
> edge from I to H, which involves routes 101, 84, and 280. It's the
> *connectedness* (or lack of it) of one intersection to another that's
> important, not the actual routes.

####### Adjacency

> Two vertices are said to be *adjacent* to one another if they are
> connected by a single edge. Thus, in Figure 13.1, vertices I and G are
> adjacent, but vertices I and F are not. The vertices adjacent to a
> given vertex are sometimes said to be its *neighbors*. For example,
> the neighbors of G are I, H, and F.

####### Paths

> A *path* is a sequence of edges. Figure 13.1 shows a path from vertex
> B to vertex J that passes through vertices A and E. We can call this
> path BAEJ. There can be more than one path between two vertices;
> another path from B to J is BCDJ.

####### Connected Graphs

> A graph is said to be *connected* if there is at least one path from
> every vertex to every other vertex, as in the graph in Figure 13.2a.
> However, if "You can't get there from here" (as Vermont farmers
> traditionally tell city slickers who stop to ask for direc- tions),
> the graph is not connected, as in Figure 13.2b.

Introduction to Graphs 617

> b\) Graph
>
> ***FIGURE 13.1*** Roadmap and graph.
>
> A non-connected graph consists of several *connected components*. In
> Figure 13.2b, A and B are one connected component, and C and D are
> another.
>
> For simplicity, the algorithms we'll be discussing in this chapter are
> written to apply to connected graphs, or to one connected component of
> a non-connected graph. If appropriate, small modifications will
> usually enable them to work with non- connected graphs as well.
>
> 618 **CHAPTER 13** Graphs

a)  Connected Graph b) Non-connected Graph

> ***FIGURE 13.2*** Connected and non-connected graphs.

####### Directed and Weighted Graphs

> The graphs in Figures 13.1 and 13.2 are *non-directed* graphs. That
> means that the edges don't have a *direction*; you can go either way
> on them. Thus, you can go from vertex A to vertex B, or from vertex B
> to vertex A, with equal ease. (Non-directed graphs model freeways
> appropriately, because you can usually go either way on a freeway.)
>
> However, graphs are often used to model situations in which you can go
> in only one direction along an edge---from A to B but not from B to A,
> as on a one-way street.
>
> Such a graph is said to be *directed*. The allowed direction is
> typically shown with an arrowhead at the end of the edge.
>
> In some graphs, edges are given a *weight*, a number that can
> represent the physical distance between two vertices, or the time it
> takes to get from one vertex to another, or how much it costs to
> travel from vertex to vertex (on airline routes, for example). Such
> graphs are called *weighted* graphs. We'll explore them in the next
> chapter.
>
> We're going to begin this chapter by discussing simple undirected,
> unweighted graphs; later we'll explore directed unweighted graphs.
>
> We have by no means covered all the definitions that apply to graphs;
> we'll introduce more as we go along.

##### Historical Note

> One of the first mathematicians to work with graphs was Leonhard Euler
> in the early eighteenth century. He solved a famous problem dealing
> with the bridges in the town of Königsberg, Poland. This town included
> an island and seven bridges, as shown in Figure 13.3a.
>
> The problem, much discussed by the townsfolk, was to find a way to
> walk across all seven bridges without recrossing any of them. We won't
> recount Euler's solution to the problem; it turns out that there is no
> such path. However, the key to his solution was to represent the
> problem as a graph, with land areas as vertices and bridges as

Introduction to Graphs 619

> edges, as shown in Figure 13.3b. This is perhaps the first example of
> a graph being used to represent a problem in the real world.
>
> c C d g

a)  Map a

B b f

Vertex

> Edge

b)  Graph

> ***FIGURE 13.3*** The bridges of Königsberg.

##### Representing a Graph in a Program

> It's all very well to think about graphs in the abstract, as Euler and
> other mathemati- cians did until the invention of the computer, but we
> want to represent graphs by using a computer. What sort of software
> structures are appropriate to model a graph? We'll look at vertices
> first and then at edges.

####### Vertices

> In a very abstract graph program you could simply number the vertices
> 0 to N-1 (where N is the number of vertices). You wouldn't need any
> sort of variable to hold the vertices because their usefulness would
> result from their relationships with other vertices.
>
> In most situations, however, a vertex represents some real-world
> object, and the object must be described using data items. If a vertex
> represents a city in an airline route simulation, for example, it may
> need to store the name of the city, its altitude, its location, and
> other such information. Thus, it's usually convenient to represent a
> vertex by an object of a vertex class. Our example programs store only
> a letter (like *A*), used as a label for identifying the vertex, and a
> flag for use in search algorithms, as we'll see later. Here's how the
> Vertex class looks:
>
> 620 **CHAPTER 13** Graphs
>
> class Vertex
>
> {
>
> public char label; // label (e.g. 'A') public boolean wasVisited;
>
> public Vertex(char lab) // constructor
>
> {
>
> label = lab; wasVisited = false;
>
> }
>
> } // end class Vertex
>
> Vertex objects can be placed in an array and referred to using their
> index number. In our examples we'll store them in an array called
> vertexList. The vertices might also be placed in a list or some other
> data structure. Whatever structure is used, this storage is for
> convenience only. It has no relevance to how the vertices are
> connected by edges. For this, we need another mechanism.

####### Edges

> In Chapter 9, "Red-Black Trees," we saw that a computer program can
> represent trees in several ways. Mostly we examined trees in which
> each node contained references to its children, but we also mentioned
> that an array could be used, with a node's position in the array
> indicating its relationship to other nodes. Chapter 12, "Heaps,"
> described arrays used to represent a kind of tree called a *heap*.
>
> A graph, however, doesn't usually have the same kind of fixed
> organization as a tree. In a binary tree, each node has a maximum of
> two children, but in a graph each vertex may be connected to an
> arbitrary number of other vertices. For example, in Figure 13.2a,
> vertex A is connected to three other vertices, whereas C is connected
> to only one.
>
> To model this sort of free-form organization, a different approach to
> representing edges is preferable to that used for trees. Two methods
> are commonly used for graphs: the *adjacency matrix* and the
> *adjacency list*. (Remember that one vertex is said to be *adjacent*
> to another if they're connected by a single edge.)

####### The Adjacency Matrix

> An adjacency matrix is a two-dimensional array in which the elements
> indicate whether an edge is present between two vertices. If a graph
> has N vertices, the adja- cency matrix is an NxN array. Table 13.1
> shows the adjacency matrix for the graph in Figure 13.2a.

Introduction to Graphs 621

> ***TABLE 13.1*** Adjacency Matrix

+---+---------+-------+---------+---------+
|   | > **A** | **B** | > **C** | > **D** |
+===+=========+=======+=========+=========+
| A | > 0     | 1     | 1       | > 1     |
+---+---------+-------+---------+---------+
| B | > 1     | 0     | 0       | > 1     |
+---+---------+-------+---------+---------+
| C | > 1     | 0     | 0       | > 0     |
+---+---------+-------+---------+---------+
| D | > 1     | 1     | 0       | > 0     |
+---+---------+-------+---------+---------+

> The vertices are used as headings for both rows and columns. An edge
> between two vertices is indicated by a 1; the absence of an edge is a
> 0. (You could also use Boolean true/false values.) As you can see,
> vertex A is adjacent to all three other vertices, B is adjacent to A
> and D, C is adjacent only to A, and D is adjacent to A and B. In this
> example, the "connection" of a vertex to itself is indicated by 0, so
> the diagonal from upper left to lower right, A-A to D-D, which is
> called the *identity diagonal*, is all 0s. The entries on the identity
> diagonal don't convey any real information, so you can equally well
> put 1s along it, if that's more convenient in your program.
>
> Note that the triangular-shaped part of the matrix above the identity
> diagonal is a mirror image of the part below; both triangles contain
> the same information. This redundancy may seem inefficient, but
> there's no convenient way to create a triangu- lar array in most
> computer languages, so it's simpler to accept the redundancy.
>
> Consequently, when you add an edge to the graph, you must make two
> entries in the adjacency matrix rather than one.

####### The Adjacency List

> The other way to represent edges is with an adjacency list. The *list*
> in *adjacency list* refers to a linked list of the kind we examined in
> Chapter 5, "Linked Lists." Actually, an adjacency list is an array of
> lists (or sometimes a list of lists). Each individual list shows what
> vertices a given vertex is adjacent to. Table 13.2 shows the adjacency
> lists for the graph of Figure 13.2a.
>
> ***TABLE 13.2*** Adjacency Lists
>
> **Vertex List Containing Adjacent Vertices**

A.  B---\>C---\>D

B.  A---\>D

C.  A

D.  A---\>B

> In this table, the ---\> symbol indicates a link in a linked list.
> Each link in the list is a vertex. Here the vertices are arranged in
> alphabetical order in each list, although that's not really necessary.
> Don't confuse the contents of adjacency lists with paths. The
> adjacency list shows which vertices are adjacent to---that is, one
> edge away from---a given vertex, not paths from vertex to vertex.
>
> 622 **CHAPTER 13** Graphs
>
> Later we'll discuss when to use an adjacency matrix as opposed to an
> adjacency list. The Workshop applets shown in this chapter all use the
> adjacency matrix approach, but sometimes the list approach is more
> efficient.

##### Adding Vertices and Edges to a Graph

> To add a vertex to a graph, you make a new vertex object with new and
> insert it into your vertex array, vertexList. In a real-world program
> a vertex might contain many data items, but for simplicity we'll
> assume that it contains only a single character. Thus, the creation of
> a vertex looks something like this:
>
> vertexList\[nVerts++\] = new Vertex('F');
>
> This inserts a vertex F, where nVerts is the number of vertices
> currently in the graph.
>
> How you add an edge to a graph depends on whether you're using an
> adjacency matrix or adjacency lists to represent the graph. Let's say
> that you're using an adja- cency matrix and want to add an edge
> between vertices 1 and 3. These numbers correspond to the array
> indices in vertexList where the vertices are stored. When you first
> created the adjacency matrix adjMat, you filled it with 0s. To insert
> the edge, you say
>
> adjMat\[1\]\[3\] = 1;
>
> adjMat\[3\]\[1\] = 1;
>
> If you were using an adjacency list, you would add a 1 to the list for
> 3, and a 3 to the list for 1.
>
> **The** Graph **Class**
>
> Let's look at a class Graph that contains methods for creating a
> vertex list and an adjacency matrix, and for adding vertices and edges
> to a Graph object:
>
> class Graph
>
> {
>
> private final int MAX\_VERTS = 20;
>
> private Vertex vertexList\[\]; // array of vertices private int
> adjMat\[\]\[\]; // adjacency matrix
>
> private int nVerts; // current number of vertices
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Graph() // constructor
>
> {

vertexList = new Vertex\[MAX\_VERTS\];

> // adjacency matrix adjMat = new int\[MAX\_VERTS\]\[MAX\_VERTS\];

Searches 623

> nVerts = 0;
>
> for(int j=0; j\<MAX\_VERTS; j++) // set adjacency for(int k=0;
> k\<MAX\_VERTS; k++) // matrix to 0
>
> adjMat\[j\]\[k\] = 0;
>
> } // end constructor
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void addVertex(char lab) // argument is label
>
> {
>
> vertexList\[nVerts++\] = new Vertex(lab);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void addEdge(int start, int end)
>
> {
>
> adjMat\[start\]\[end\] = 1;
>
> adjMat\[end\]\[start\] = 1;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayVertex(int v)
>
> {
>
> System.out.print(vertexList\[v\].label);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Graph
>
> Within the Graph class, vertices are identified by their index number
> in vertexList.
>
> We've already discussed most of the methods shown here. To display a
> vertex, we simply print out its one-character label.
>
> The adjacency matrix (or the adjacency list) provides information that
> is local to a given vertex. Specifically, it tells you which vertices
> are connected by a single edge to a given vertex. To answer more
> global questions about the arrangement of the vertices, we must resort
> to various algorithms. We'll begin with searches.

#### Searches

> One of the most fundamental operations to perform on a graph is
> finding which vertices can be reached from a specified vertex. For
> example, imagine trying to find out how many towns in the United
> States can be reached by passenger train from Kansas City (assuming
> that you don't mind changing trains). Some towns could be reached.
> Others couldn't be reached because they didn't have passenger rail
> service. Possibly others couldn't be reached, even though they had
> rail service, because their rail system (the narrow-gauge
> Hayfork-Hicksville RR, for example) didn't connect
>
> 624 **CHAPTER 13** Graphs
>
> with the standard-gauge line you started on or any of the lines that
> could be reached from your line.
>
> Here's another situation in which you might need to find all the
> vertices reachable from a specified vertex. Imagine that you're
> designing a printed circuit board, like the ones inside your computer.
> (Open it up and take a look!) Various components--- mostly integrated
> circuits (ICs)---are placed on the board, with pins from the ICs
> protruding through holes in the board. The ICs are soldered in place,
> and their pins are electrically connected to other pins by
> *traces*---thin metal lines applied to the surface of the circuit
> board, as shown in Figure 13.4. (No, you don't need to worry about the
> details of this figure.)
>
> ***FIGURE 13.4*** Pins and traces on a circuit board.
>
> In a graph, each pin might be represented by a vertex, and each trace
> by an edge. On a circuit board there are many electrical circuits that
> aren't connected to each other, so the graph is by no means a
> connected one. During the design process, therefore, it may be
> genuinely useful to create a graph and use it to find which pins are
> connected to the same electrical circuit.
>
> Assume that you've created such a graph. Now you need an algorithm
> that provides a systematic way to start at a specified vertex and then
> move along edges to other vertices in such a way that, when it's done,
> you are guaranteed that it has *visited* every vertex that's connected
> to the starting vertex. Here, as it did in Chapter 8, "Binary Trees,"
> where we discussed binary trees, *visit* means to perform some opera-
> tion on the vertex, such as displaying it.
>
> There are two common approaches to searching a graph: *depth-first
> search (DFS)* and *breadth-first search (BFS)*. Both will eventually
> reach all connected vertices. The depth-first search is implemented
> with a stack, whereas the breadth-first search is

Searches 625

> implemented with a queue. These mechanisms result, as we'll see, in
> the graph being searched in different ways.

##### Depth-First Search

> The depth-first search uses a stack to remember where it should go
> when it reaches a dead end. We'll show an example, encourage you to
> try similar examples with the GraphN Workshop applet, and then finally
> show some code that carries out the search.

####### An Example

> We'll discuss the idea behind the depth-first search in relation to
> Figure 13.5. The numbers in this figure show the order in which the
> vertices are visited.
>
> 3 4
>
> 2 B ~~F H~~

5

C

1

> A 6 7 8
>
> [D G I]{.underline}

E

9

> ***FIGURE 13.5*** Depth-first search.
>
> To carry out the depth-first search, you pick a starting point---in
> this case, vertex A. You then do three things: visit this vertex, push
> it onto a stack so you can remember it, and mark it so you won't visit
> it again.
>
> Next, you go to any vertex adjacent to A that hasn't yet been visited.
> We'll assume the vertices are selected in alphabetical order, so that
> brings up B. You visit B, mark it, and push it on the stack.
>
> Now what? You're at B, and you do the same thing as before: go to an
> adjacent vertex that hasn't been visited. This leads you to F. We can
> call this process Rule 1.
>
> **[RULE 1 ]{.underline}**
>
> If possible, visit an adjacent unvisited vertex, mark it, and push it
> on the stack.
>
> Applying Rule 1 again leads you to H. At this point, however, you need
> to do some- thing else because there are no unvisited vertices
> adjacent to H. Here's where Rule 2 comes in.
>
> 626 **CHAPTER 13** Graphs
>
> **[RULE 2 ]{.underline}**
>
> If you can't follow Rule 1, then, if possible, pop a vertex off the
> stack.
>
> Following this rule, you pop H off the stack, which brings you back to
> F. F has no unvisited adjacent vertices, so you pop it. Ditto B. Now
> only A is left on the stack.
>
> A, however, does have unvisited adjacent vertices, so you visit the
> next one, C. But C is the end of the line again, so you pop it and
> you're back to A. You visit D, G, and I, and then pop them all when
> you reach the dead end at I. Now you're back to A. You visit E, and
> again you're back to A.
>
> This time, however, A has no unvisited neighbors, so we pop it off the
> stack. But now there's nothing left to pop, which brings up Rule 3.
>
> **[RULE 3 ]{.underline}**
>
> If you can't follow Rule 1 or Rule 2, you're done.
>
> Table 13.3 shows how the stack looks in the various stages of this
> process, as applied to Figure 13.5.
>
> ***TABLE 13.3*** Stack Contents During Depth-First Search
>
> **Event Stack**
>
> Visit A A
>
> Visit B AB
>
> Visit F ABF
>
> Visit H ABFH
>
> Pop H ABF
>
> Pop F AB
>
> Pop B A
>
> Visit C AC
>
> Pop C A
>
> Visit D AD
>
> Visit G ADG
>
> Visit I ADGI
>
> Pop I ADG
>
> Pop G AD
>
> Pop D A
>
> Visit E AE
>
> Pop E A
>
> Pop A Done

Searches 627

> The contents of the stack is the route you took from the starting
> vertex to get where you are. As you move away from the starting
> vertex, you push vertices as you go. As you move back toward the
> starting vertex, you pop them. The order in which you visit the
> vertices is ABFHCDGIE.
>
> You might say that the depth-first search algorithm likes to get as
> far away from the starting point as quickly as possible and returns
> only when it reaches a dead end. If you use the term *depth* to mean
> the distance from the starting point, you can see where the name
> *depth-first search* comes from.

####### An Analogy

> An analogy you might think about in relation to depth-first search is
> a maze. The maze---perhaps one of the people-size ones made of hedges,
> popular in England--- consists of narrow passages (think of edges) and
> intersections where passages meet (vertices).
>
> Suppose that someone is lost in the maze. She knows there's an exit
> and plans to traverse the maze systematically to find it. Fortunately,
> she has a ball of string and a marker pen. She starts at some
> intersection and goes down a randomly chosen passage, unreeling the
> string. At the next intersection, she goes down another randomly
> chosen passage, and so on, until finally she reaches a dead end.
>
> At the dead end she retraces her path, reeling in the string, until
> she reaches the previous intersection. Here she marks the path she's
> been down so she won't take it again, and tries another path. When
> she's marked all the paths leading from that intersection, she returns
> to the previous intersection and repeats the process.
>
> The string represents the stack: It "remembers" the path taken to
> reach a certain point.

####### The GraphN Workshop Applet and DFS

> You can try out the depth-first search with the DFS button in the
> GraphN workshop applet. (The N is for *not directed, not weighted*.)
>
> Start the applet. At the beginning, there are no vertices or edges,
> just an empty rectangle. You create vertices by double-clicking the
> desired location. The first vertex is automatically labeled A, the
> second one is B, and so on. They're colored randomly.
>
> To make an edge, drag from one vertex to another. Figure 13.6 shows
> the graph of Figure 13.5 as it looks when created using the applet.
>
> There's no way to delete individual edges or vertices, so if you make
> a mistake, you'll need to start over by clicking the New button, which
> erases all existing vertices and edges. (It warns you before it does
> this.) Clicking the View button switches you to the adjacency matrix
> for the graph you've made, as shown in Figure 13.7. Clicking View
> again switches you back to the graph.
>
> 628 **CHAPTER 13** Graphs

![](media/image1.png){width="2.7864873140857394in"
height="2.2866655730533685in"}

> ***FIGURE 13.6*** The GraphN workshop applet.

![](media/image2.png){width="2.7989818460192475in"
height="2.2866655730533685in"}

> ***FIGURE 13.7*** Adjacency matrix view in GraphN.
>
> To run the depth-first search algorithm, click the DFS button
> repeatedly. You'll be prompted to click (*not* double-click) the
> starting vertex at the beginning of the process.
>
> You can re-create the graph of Figure 13.6, or you can create simpler
> or more complex ones of your own. After you play with it a while, you
> can predict what the algorithm will do next (unless the graph is too
> weird).
>
> If you use the algorithm on an unconnected graph, it will find only
> those vertices that are connected to the starting vertex.

Searches 629

####### Java Code

> A key to the DFS algorithm is being able to find the vertices that are
> unvisited and adjacent to a specified vertex. How do you do this? The
> adjacency matrix is the key. By going to the row for the specified
> vertex and stepping across the columns, you can pick out the columns
> with a 1; the column number is the number of an adjacent vertex. You
> can then check whether this vertex is unvisited. If so, you've found
> what you want---the next vertex to visit. If no vertices on the row
> are simultaneously 1 (adjacent) and also unvisited, there are no
> unvisited vertices adjacent to the specified vertex. We put the code
> for this process in the getAdjUnvisitedVertex() method:
>
> // returns an unvisited vertex adjacent to v public int
> getAdjUnvisitedVertex(int v)
>
> {
>
> for(int j=0; j\<nVerts; j++)
>
> if(adjMat\[v\]\[j\]==1 && vertexList\[j\].wasVisited==false) return j;
> // return first such vertex
>
> return -1; // no such vertices
>
> } // end getAdjUnvisitedVertex()
>
> Now we're ready for the dfs() method of the Graph class, which
> actually carries out the depth-first search. You can see how this code
> embodies the three rules listed earlier. It loops until the stack is
> empty. Within the loop, it does four things:

1.  It examines the vertex at the top of the stack, using peek().

2.  It tries to find an unvisited neighbor of this vertex.

3.  If it doesn't find one, it pops the stack.

4.  If it finds such a vertex, it visits that vertex and pushes it onto
    the stack.

> Here's the code for the dfs() method:
>
> public void dfs() // depth-first search
>
> { // begin at vertex 0
>
> vertexList\[0\].wasVisited = true; // mark it displayVertex(0); //
> display it
>
> theStack.push(0); // push it
>
> while( !theStack.isEmpty() ) // until stack empty,
>
> {
>
> // get an unvisited vertex adjacent to stack top int v =
> getAdjUnvisitedVertex( theStack.peek() );
>
> if(v == -1) // if no such vertex, theStack.pop(); // pop a new one
>
> 630 **CHAPTER 13** Graphs
>
> else // if it exists,
>
> {
>
> vertexList\[v\].wasVisited = true; // mark it displayVertex(v); //
> display it
>
> theStack.push(v); // push it
>
> }
>
> } // end while
>
> // stack is empty, so we're done
>
> for(int j=0; j\<nVerts; j++) // reset flags vertexList\[j\].wasVisited
> = false;
>
> } // end dfs
>
> At the end of dfs(), we reset all the wasVisited flags so we'll be
> ready to run dfs()
>
> again later. The stack should already be empty, so it doesn't need to
> be reset.
>
> Now we have all the pieces of the Graph class we need. Here's some
> code that creates a graph object, adds some vertices and edges to it,
> and then performs a depth-first search:
>
> Graph theGraph = new Graph(); theGraph.addVertex('A'); // 0 (start for
> dfs) theGraph.addVertex('B'); // 1
>
> theGraph.addVertex('C'); // 2
>
> theGraph.addVertex('D'); // 3
>
> theGraph.addVertex('E'); // 4
>
> theGraph.addEdge(0, 1); // AB theGraph.addEdge(1, 2); // BC
> theGraph.addEdge(0, 3); // AD theGraph.addEdge(3, 4); // DE
>
> System.out.print("Visits: ");
>
> theGraph.dfs(); // depth-first search System.out.println();
>
> Figure 13.8 shows the graph created by this code. Here's the output:
>
> Visits: ABCDE
>
> You can modify this code to create the graph of your choice, and then
> run it to see it carry out the depth-first search.

Searches 631

> ***FIGURE 13.8*** Graph used by dfs.java and bfs.java.
>
> **The** dfs.java **Program**
>
> Listing 13.1 shows the dfs.java program, which includes the dfs()
> method. It includes a version of the StackX class from Chapter 4,
> "Stacks and Queues."
>
> ***LISTING 13.1*** The dfs.java Program
>
> // dfs.java
>
> // demonstrates depth-first search
>
> // to run this program: C\>java DFSApp
>
> //////////////////////////////////////////////////////////////// class
> StackX
>
> {
>
> private final int SIZE = 20; private int\[\] st;
>
> private int top;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public StackX() // constructor
>
> {
>
> st = new int\[SIZE\]; // make array top = -1;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void push(int j) // put item on stack
>
> { st\[++top\] = j; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int pop() // take item off stack
>
> { return st\[top\--\]; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int peek() // peek at top of stack
>
> 632 **CHAPTER 13** Graphs
>
> ***LISTING 13.1*** Continued
>
> { return st\[top\]; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if nothing on stack-
>
> { return (top == -1); }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class StackX
>
> //////////////////////////////////////////////////////////////// class
> Vertex
>
> {
>
> public char label; // label (e.g. 'A') public boolean wasVisited;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Vertex(char lab) // constructor
>
> {
>
> label = lab; wasVisited = false;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Vertex
>
> //////////////////////////////////////////////////////////////// class
> Graph
>
> {
>
> private final int MAX\_VERTS = 20;
>
> private Vertex vertexList\[\]; // list of vertices private int
> adjMat\[\]\[\]; // adjacency matrix
>
> private int nVerts; // current number of vertices private StackX
> theStack;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Graph() // constructor
>
> {
>
> vertexList = new Vertex\[MAX\_VERTS\];
>
> // adjacency matrix adjMat = new int\[MAX\_VERTS\]\[MAX\_VERTS\];
>
> nVerts = 0;
>
> for(int j=0; j\<MAX\_VERTS; j++) // set adjacency for(int k=0;
> k\<MAX\_VERTS; k++) // matrix to 0
>
> adjMat\[j\]\[k\] = 0; theStack = new StackX();
>
> } // end constructor
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void addVertex(char lab)

Searches 633

> ***LISTING 13.1*** Continued
>
> {
>
> vertexList\[nVerts++\] = new Vertex(lab);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void addEdge(int start, int end)
>
> {
>
> adjMat\[start\]\[end\] = 1;
>
> adjMat\[end\]\[start\] = 1;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void displayVertex(int v)
>
> {
>
> System.out.print(vertexList\[v\].label);
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void dfs() // depth-first search
>
> { // begin at vertex 0
>
> vertexList\[0\].wasVisited = true; // mark it displayVertex(0); //
> display it
>
> theStack.push(0); // push it
>
> while( !theStack.isEmpty() ) // until stack empty,
>
> {
>
> // get an unvisited vertex adjacent to stack top int v =
> getAdjUnvisitedVertex( theStack.peek() );
>
> if(v == -1) // if no such vertex, theStack.pop();
>
> else // if it exists,
>
> {
>
> vertexList\[v\].wasVisited = true; // mark it displayVertex(v); //
> display it
>
> theStack.push(v); // push it
>
> }
>
> } // end while
>
> // stack is empty, so we're done
>
> for(int j=0; j\<nVerts; j++) // reset flags vertexList\[j\].wasVisited
> = false;
>
> } // end dfs
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // returns an unvisited vertex adj to v
>
> 634 **CHAPTER 13** Graphs
>
> ***LISTING 13.1*** Continued
>
> public int getAdjUnvisitedVertex(int v)
>
> {
>
> for(int j=0; j\<nVerts; j++)
>
> if(adjMat\[v\]\[j\]==1 && vertexList\[j\].wasVisited==false) return j;
>
> return -1;
>
> } // end getAdjUnvisitedVertex()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Graph
>
> //////////////////////////////////////////////////////////////// class
> DFSApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> Graph theGraph = new Graph(); theGraph.addVertex('A'); // 0 (start for
> dfs) theGraph.addVertex('B'); // 1
>
> theGraph.addVertex('C'); // 2
>
> theGraph.addVertex('D'); // 3
>
> theGraph.addVertex('E'); // 4
>
> theGraph.addEdge(0, 1); // AB theGraph.addEdge(1, 2); // BC
> theGraph.addEdge(0, 3); // AD theGraph.addEdge(3, 4); // DE
>
> System.out.print("Visits: ");
>
> theGraph.dfs(); // depth-first search System.out.println();
>
> } // end main()
>
> } // end class DFSApp
>
> ////////////////////////////////////////////////////////////////

####### Depth-First Search and Game Simulations

> Depth-first searches are often used in simulations of games (and
> game-like situations in the real world). In a typical game you can
> choose one of several possible actions. Each choice leads to further
> choices, each of which leads to further choices, and so on into an
> ever-expanding tree-shaped graph of possibilities. A choice point
> corre- sponds to a vertex, and the specific choice taken corresponds
> to an edge, which leads to another choice-point vertex.

Searches 635

> Imagine a game of tic-tac-toe. If you go first, you can make one of
> nine possible moves. Your opponent can counter with one of eight
> possible moves, and so on. Each move leads to another group of choices
> by your opponent, which leads to another series of choices for you,
> until the last square is filled.
>
> When you are deciding what move to make, one approach is to mentally
> imagine a move, then your opponent's possible responses, then your
> responses, and so on. You can decide what to do by seeing which move
> leads to the best outcome. In simple games like tic-tac-toe the number
> of possible moves is sufficiently limited that it's possible to follow
> each path to the end of the game. After you've analyzed the paths
> completely, you know which move to make first. This can be represented
> by a graph with one node representing your first move, which is
> connected to eight nodes representing your opponent's possible
> responses, each of which is connected to seven nodes representing your
> responses, and so on. All these paths from the begin- ning node to an
> end node include nine nodes. For a complete analysis you'll need to
> draw nine graphs, one for each starting move.
>
> Even in this simple game the number of paths is surprisingly large. If
> we ignore simplifications from symmetry, there are
> 9\*8\*7\*6\*5\*4\*3\*2\*1 paths in the nine graphs. This is 9
> factorial (9!) or 362,880. In a game like chess where the number of
> possible moves is much greater, even the most powerful computers (like
> IBM's "Deep Blue") cannot "see" to the end of the game. They can only
> follow a path to a certain depth and then evaluate the board to see if
> it appears more favorable than other choices.
>
> The natural way to examine such situations in a computer program is to
> use a depth- first search. At each node you decide what move to make
> next, as is done in the getAdjUnvisitedVertex() method in the dfs.java
> program (Listing 13.1). If there are still unvisited nodes (choice
> points), you push the current one on the stack and go on to the next.
> If you find you can't make a move (getAdjUnvisitedVertex() returns
>
> --1) in a certain situation, you backtrack by popping a node off the
> stack (which corresponds to taking back a move) and see if the
> resulting position has any unex- plored choices.
>
> You can think of the sequences of moves in a game as a tree, with
> nodes represent- ing moves. The first move is the root. In
> tic-tac-toe, after the first move there are eight possible second
> moves, each represented by a node connected to the root. After each of
> these eight second moves, there are seven possible third moves
> represented by nodes connected to the second-move nodes. You end up
> with a tree with 9! possi- ble paths from the root to the leaves. This
> is called the *game tree*.
>
> Actually, the number of branches in the game tree is reduced because
> the game is often won before all the squares are filled. However, the
> tic-tac-toe game tree is still very large and complex, and this is a
> simple game compared with many others, such as chess.
>
> 636 **CHAPTER 13** Graphs
>
> Only some paths in a game tree lead to a successful conclusion. For
> example, some lead to a win by your opponent. When you reach such an
> ending, you must back up, or *backtrack*, to a previous node and try a
> different path. In this way you explore the tree until you find a path
> with a successful conclusion. Then you make the first move along this
> path.

##### Breadth-First Search

> As we saw in the depth-first search, the algorithm acts as though it
> wants to get as far away from the starting point as quickly as
> possible. In the breadth-first search, on the other hand, the
> algorithm likes to stay as close as possible to the starting point. It
> visits all the vertices adjacent to the starting vertex, and only then
> goes further afield. This kind of search is implemented using a queue
> instead of a stack.

####### An Example

> Figure 13.9 shows the same graph as Figure 13.5, but here the
> breadth-first search is used. Again, the numbers indicate the order in
> which the vertices are visited.
>
> 2 B 6 F 8 H

3

C

1

A

> D 4 7 G 9 I

5

E

> ***FIGURE 13.9*** Breadth-first search.
>
> A is the starting vertex, so you visit it and make it the current
> vertex. Then you follow these rules:
>
> **[RULE 1 ]{.underline}**
>
> Visit the next unvisited vertex (if there is one) that's adjacent to
> the current vertex, mark it, and insert it into the queue.
>
> **[RULE 2 ]{.underline}**
>
> If you can't carry out Rule 1 because there are no more unvisited
> vertices, remove a vertex from the queue (if possible) and make it the
> current vertex.

Searches 637

> **[RULE 3 ]{.underline}**
>
> If you can't carry out Rule 2 because the queue is empty, you're done.
>
> Thus, you first visit all the vertices adjacent to A, inserting each
> one into the queue as you visit it. Now you've visited A, B, C, D, and
> E. At this point the queue (from front to rear) contains BCDE.
>
> There are no more unvisited vertices adjacent to A, so you remove B
> from the queue and look for vertices adjacent to it. You find F, so
> you insert it in the queue. There are no more unvisited vertices
> adjacent to B, so you remove C from the queue. It has no adjacent
> unvisited vertices, so you remove D and visit G. D has no more
> adjacent unvisited vertices, so you remove E. Now the queue is FG. You
> remove F and visit H, and then you remove G and visit I.
>
> Now the queue is HI, but when you've removed each of these and found
> no adjacent unvisited vertices, the queue is empty, so you're done.
> Table 13.4 shows this sequence.
>
> ***TABLE 13.4*** Queue Contents During Breadth-First Search
>
> **Event Queue (Front to Rear)**
>
> Visit A
>
> Visit B B
>
> Visit C BC
>
> Visit D BCD
>
> Visit E BCDE
>
> Remove B CDE
>
> Visit F CDEF
>
> Remove C DEF
>
> Remove D EF
>
> Visit G EFG
>
> Remove E FG
>
> Remove F G
>
> Visit H GH
>
> Remove G H
>
> Visit I HI
>
> Remove H I
>
> Remove I Done
>
> At each moment, the queue contains the vertices that have been visited
> but whose neighbors have not yet been fully explored. (Contrast this
> breadth-first search with the depth-first search, where the contents
> of the stack is the route you took from the starting point to the
> current vertex.) The nodes are visited in the order ABCDEFGHI.
>
> 638 **CHAPTER 13** Graphs

####### The GraphN Workshop Applet and BFS

> Use the GraphN workshop applet to try out a breadth-first search using
> the BFS button. Again, you can experiment with the graph of Figure
> 13.9, or you can make up your own.
>
> Notice the similarities and the differences of the breadth-first
> search compared with the depth-first search.
>
> You can think of the breadth-first search as proceeding like ripples
> widening when you drop a stone in water---or, for those of you who
> enjoy epidemiology, as the influenza virus carried by air travelers
> from city to city. First, all the vertices one edge (plane flight)
> away from the starting point are visited, then all the vertices two
> edges away are visited, and so on.

####### Java Code

> The bfs() method of the Graph class is similar to the dfs() method,
> except that it uses a queue instead of a stack and features nested
> loops instead of a single loop. The outer loop waits for the queue to
> be empty, whereas the inner one looks in turn at each unvisited
> neighbor of the current vertex. Here's the code:
>
> public void bfs() // breadth-first search
>
> { // begin at vertex 0
>
> vertexList\[0\].wasVisited = true; // mark it displayVertex(0); //
> display it
>
> theQueue.insert(0); // insert at tail int v2;
>
> while( !theQueue.isEmpty() ) // until queue empty,
>
> {
>
> int v1 = theQueue.remove(); // remove vertex at head
>
> // until it has no unvisited neighbors
>
> while( (v2=getAdjUnvisitedVertex(v1)) != -1 )
>
> { // get one,
>
> vertexList\[v2\].wasVisited = true; // mark it displayVertex(v2); //
> display it
>
> theQueue.insert(v2); // insert it
>
> } // end while(unvisited neighbors)
>
> } // end while(queue not empty)
>
> // queue is empty, so we're done
>
> for(int j=0; j\<nVerts; j++) // reset flags vertexList\[j\].wasVisited
> = false;
>
> } // end bfs()

Searches 639

> Given the same graph as in dfs.java (shown earlier in Figure 13.8),
> the output from
>
> bfs.java is now
>
> Visits: ABDCE
>
> **The** bfs.java **Program**
>
> The bfs.java program, shown in Listing 13.2, is similar to dfs.java
> except for the inclusion of a Queue class (modified from the version
> in Chapter 4) instead of a StackX class, and a bfs() method instead of
> a dfs() method.
>
> ***LISTING 13.2*** The bfs.java Program
>
> // bfs.java
>
> // demonstrates breadth-first search
>
> // to run this program: C\>java BFSApp
>
> //////////////////////////////////////////////////////////////// class
> Queue
>
> {
>
> private final int SIZE = 20; private int\[\] queArray; private int
> front;
>
> private int rear;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Queue() // constructor
>
> {
>
> queArray = new int\[SIZE\]; front = 0;
>
> rear = -1;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void insert(int j) // put item at rear of queue
>
> {
>
> if(rear == SIZE-1) rear = -1;
>
> queArray\[++rear\] = j;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int remove() // take item from front of queue
>
> {
>
> int temp = queArray\[front++\]; if(front == SIZE)
>
> front = 0; return temp;
>
> 640 **CHAPTER 13** Graphs
>
> ***LISTING 13.2*** Continued
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if queue is empty
>
> {
>
> return ( rear+1==front \|\| (front+SIZE-1==rear) );
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Queue
>
> //////////////////////////////////////////////////////////////// class
> Vertex
>
> {
>
> public char label; // label (e.g. 'A') public boolean wasVisited;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Vertex(char lab) // constructor
>
> {
>
> label = lab; wasVisited = false;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Vertex
>
> //////////////////////////////////////////////////////////////// class
> Graph
>
> {
>
> private final int MAX\_VERTS = 20;
>
> private Vertex vertexList\[\]; // list of vertices private int
> adjMat\[\]\[\]; // adjacency matrix
>
> private int nVerts; // current number of vertices private Queue
> theQueue;
>
> // \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Graph() // constructor
>
> {
>
> vertexList = new Vertex\[MAX\_VERTS\];
>
> // adjacency matrix adjMat = new int\[MAX\_VERTS\]\[MAX\_VERTS\];
>
> nVerts = 0;
>
> for(int j=0; j\<MAX\_VERTS; j++) // set adjacency for(int k=0;
> k\<MAX\_VERTS; k++) // matrix to 0
>
> adjMat\[j\]\[k\] = 0; theQueue = new Queue();
>
> } // end constructor

Searches 641

> ***LISTING 13.2*** Continued

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void addVertex(char lab)
>
> {
>
> vertexList\[nVerts++\] = new Vertex(lab);
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void addEdge(int start, int end)
>
> {
>
> adjMat\[start\]\[end\] = 1;
>
> adjMat\[end\]\[start\] = 1;
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayVertex(int v)
>
> {
>
> System.out.print(vertexList\[v\].label);
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void bfs() // breadth-first search

> { // begin at vertex 0
>
> vertexList\[0\].wasVisited = true; // mark it displayVertex(0); //
> display it
>
> theQueue.insert(0); // insert at tail int v2;
>
> while( !theQueue.isEmpty() ) // until queue empty,
>
> {
>
> int v1 = theQueue.remove(); // remove vertex at head
>
> // until it has no unvisited neighbors

while( (v2=getAdjUnvisitedVertex(v1)) != -1 )

> { // get one,
>
> vertexList\[v2\].wasVisited = true; // mark it displayVertex(v2); //
> display it
>
> theQueue.insert(v2); // insert it
>
> } // end while
>
> } // end while(queue not empty)
>
> // queue is empty, so we're done
>
> for(int j=0; j\<nVerts; j++) // reset flags vertexList\[j\].wasVisited
> = false;
>
> } // end bfs()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> 642 **CHAPTER 13** Graphs
>
> ***LISTING 13.2*** Continued
>
> // returns an unvisited vertex adj to v public int
> getAdjUnvisitedVertex(int v)
>
> {
>
> for(int j=0; j\<nVerts; j++)
>
> if(adjMat\[v\]\[j\]==1 && vertexList\[j\].wasVisited==false) return j;
>
> return -1;
>
> } // end getAdjUnvisitedVertex()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Graph
>
> //////////////////////////////////////////////////////////////// class
> BFSApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> Graph theGraph = new Graph(); theGraph.addVertex('A'); // 0 (start for
> dfs) theGraph.addVertex('B'); // 1
>
> theGraph.addVertex('C'); // 2
>
> theGraph.addVertex('D'); // 3
>
> theGraph.addVertex('E'); // 4
>
> theGraph.addEdge(0, 1); // AB theGraph.addEdge(1, 2); // BC
> theGraph.addEdge(0, 3); // AD theGraph.addEdge(3, 4); // DE
>
> System.out.print("Visits: ");
>
> theGraph.bfs(); // breadth-first search System.out.println();
>
> } // end main()
>
> } // end class BFSApp
>
> ////////////////////////////////////////////////////////////////
>
> The breadth-first search has an interesting property: It first finds
> all the vertices that are one edge away from the starting point, then
> all the vertices that are two edges away, and so on. This is useful if
> you're trying to find the shortest path from the starting vertex to a
> given vertex. You start a BFS, and when you find the specified vertex,
> you know the path you've traced so far is the shortest path to the
> node. If there were a shorter path, the BFS would have found it
> already.
>
> Minimum Spanning Trees 643

#### Minimum Spanning Trees

> Suppose that you've designed a printed circuit board like the one
> shown in Figure 13.4, and you want to be sure you've used the minimum
> number of traces. That is, you don't want any extra connections
> between pins; such extra connections would take up extra room and make
> other circuits more difficult to lay out.
>
> It would be nice to have an algorithm that, for any connected set of
> pins and traces (vertices and edges, in graph terminology), would
> remove any extra traces. The result would be a graph with the minimum
> number of edges necessary to connect the vertices. For example, Figure
> 13.10a shows five vertices with an excessive number of edges, while
> Figure 13.10b shows the same vertices with the minimum number of edges
> necessary to connect them. This constitutes a *minimum spanning tree
> (MST)*.

a)  Extra Edges b) Minimum Number of Edges

> ***FIGURE 13.10*** Minimum spanning tree.
>
> There are many possible minimum spanning trees for a given set of
> vertices. Figure 13.10b shows edges AB, BC, CD, and DE, but edges AC,
> CE, ED, and DB would do just as well. The arithmetically inclined will
> note that the number of edges E in a minimum spanning tree is always
> one less than the number of vertices V:
>
> E = V -- 1
>
> Remember that we're not worried here about the length of the edges.
> We're not trying to find a minimum physical length, just the minimum
> number of edges. (This will change when we talk about weighted graphs
> in the next chapter.)
>
> The algorithm for creating the minimum spanning tree is almost
> identical to that used for searching. It can be based on either the
> depth-first search or the breadth- first search. In our example we'll
> use the depth-first search.
>
> Perhaps surprisingly, by executing the depth-first search and
> recording the edges you've traveled to make the search, you
> automatically create a minimum spanning tree. The only difference
> between the minimum spanning tree method mst(), which we'll see in a
> moment, and the depth-first search method dfs(), which we saw earlier,
> is that mst() must somehow record the edges traveled.
>
> 644 **CHAPTER 13** Graphs

##### GraphN Workshop Applet

> Repeatedly clicking the Tree button in the GraphN workshop algorithm
> will create a minimum spanning tree for any graph you create. Try it
> out with various graphs.
>
> You'll see that the algorithm follows the same steps as when using the
> DFS button to do a search. When you use Tree, however, the appropriate
> edge is darkened when the algorithm assigns it to the minimum spanning
> tree. When the algorithm is finished, the applet removes all the
> non-darkened lines, leaving only the minimum spanning tree. A final
> button press restores the original graph, in case you want to use it
> again.

##### Java Code for the Minimum Spanning Tree

> Here's the code for the mst() method:
>
> while( !theStack.isEmpty() ) // until stack empty
>
> { // get stack top
>
> int currentVertex = theStack.peek();
>
> // get next unvisited neighbor
>
> int v = getAdjUnvisitedVertex(currentVertex);
>
> if(v == -1) // if no more neighbors theStack.pop(); // pop it away
>
> else // got a neighbor
>
> {
>
> vertexList\[v\].wasVisited = true; // mark it theStack.push(v); //
> push it
>
> // display edge displayVertex(currentVertex); // from currentV
> displayVertex(v); // to v System.out.print(" ");
>
> }
>
> } // end while(stack not empty)
>
> // stack is empty, so we're done
>
> for(int j=0; j\<nVerts; j++) // reset flags vertexList\[j\].wasVisited
> = false;
>
> } // end mst()
>
> As you can see, this code is very similar to dfs(). In the else
> statement, however, the current vertex and its next unvisited neighbor
> are displayed. These two vertices define the edge that the algorithm
> is currently traveling to get to a new vertex, and it's these edges
> that make up the minimum spanning tree.
>
> In the main() part of the mst.java program, we create a graph by using
> these statements:
>
> Minimum Spanning Trees 645
>
> Graph theGraph = new Graph();

+----------------------------+----+---------------------+
| > theGraph.addVertex('A'); | // | > 0 (start for mst) |
+============================+====+=====================+
| > theGraph.addVertex('B'); | // | > 1                 |
+----------------------------+----+---------------------+
| > theGraph.addVertex('C'); | // | > 2                 |
+----------------------------+----+---------------------+
| > theGraph.addVertex('D'); | // | > 3                 |
+----------------------------+----+---------------------+
| > theGraph.addVertex('E'); | // | > 4                 |
+----------------------------+----+---------------------+

> theGraph.addEdge(0, 1); // AB theGraph.addEdge(0, 2); // AC
> theGraph.addEdge(0, 3); // AD theGraph.addEdge(0, 4); // AE
> theGraph.addEdge(1, 2); // BC theGraph.addEdge(1, 3); // BD
> theGraph.addEdge(1, 4); // BE theGraph.addEdge(2, 3); // CD
> theGraph.addEdge(2, 4); // CE theGraph.addEdge(3, 4); // DE
>
> The graph that results is the one shown in Figure 13.10a. When the
> mst() method has done its work, only four edges are left, as shown in
> Figure 13.10b. Here's the output from the mst.java program:
>
> Minimum spanning tree: AB BC CD DE
>
> As we noted, this is only one of many possible minimum scanning trees
> that can be created from this graph. Using a different starting
> vertex, for example, would result in a different tree. So would small
> variations in the code, such as starting at the end of the
> vertexList\[\] instead of the beginning in the getAdjUnvisitedVertex()
> method.
>
> The minimum spanning tree is easily derived from the depth-first
> search because the DFS visits all the nodes, but only once. It never
> goes to a node that has already been visited. When it looks down an
> edge that has a visited node at the end, it doesn't follow that edge.
> It never travels any edges that aren't necessary. Thus, the path of
> the DFS algorithm through the graph must be a minimum spanning tree.
>
> **The** mst.java **Program**
>
> Listing 13.3 shows the mst.java program. It's similar to dfs.java,
> except for the mst()
>
> method and the graph created in main().
>
> ***LISTING 13.3*** The mst.java Program
>
> // mst.java
>
> // demonstrates minimum spanning tree
>
> // to run this program: C\>java MSTApp
>
> ////////////////////////////////////////////////////////////////
>
> 646 **CHAPTER 13** Graphs
>
> ***LISTING 13.3*** Continued
>
> class StackX
>
> {
>
> private final int SIZE = 20; private int\[\] st;
>
> private int top;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public StackX() // constructor
>
> {
>
> st = new int\[SIZE\]; // make array top = -1;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public void push(int j) // put item on stack
>
> { st\[++top\] = j; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int pop() // take item off stack
>
> { return st\[top\--\]; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int peek() // peek at top of stack
>
> { return st\[top\]; }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public boolean isEmpty() // true if nothing on stack
>
> { return (top == -1); }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class StackX
>
> //////////////////////////////////////////////////////////////// class
> Vertex
>
> {
>
> public char label; // label (e.g. 'A') public boolean wasVisited;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Vertex(char lab) // constructor
>
> {
>
> label = lab; wasVisited = false;
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Vertex
>
> //////////////////////////////////////////////////////////////// class
> Graph
>
> {
>
> Minimum Spanning Trees 647
>
> ***LISTING 13.3*** Continued
>
> private final int MAX\_VERTS = 20;
>
> private Vertex vertexList\[\]; // list of vertices private int
> adjMat\[\]\[\]; // adjacency matrix
>
> private int nVerts; // current number of vertices private StackX
> theStack;
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Graph() // constructor
>
> {
>
> vertexList = new Vertex\[MAX\_VERTS\];
>
> // adjacency matrix adjMat = new int\[MAX\_VERTS\]\[MAX\_VERTS\];
>
> nVerts = 0;
>
> for(int j=0; j\<MAX\_VERTS; j++) // set adjacency for(int k=0;
> k\<MAX\_VERTS; k++) // matrix to 0
>
> adjMat\[j\]\[k\] = 0; theStack = new StackX();
>
> } // end constructor

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void addVertex(char lab)
>
> {
>
> vertexList\[nVerts++\] = new Vertex(lab);
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void addEdge(int start, int end)
>
> {
>
> adjMat\[start\]\[end\] = 1;
>
> adjMat\[end\]\[start\] = 1;
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayVertex(int v)
>
> {
>
> System.out.print(vertexList\[v\].label);
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

public void mst() // minimum spanning tree (depth first)

> { // start at 0
>
> vertexList\[0\].wasVisited = true; // mark it theStack.push(0); //
> push it
>
> while( !theStack.isEmpty() ) // until stack empty

{ // get stack top

> 648 **CHAPTER 13** Graphs
>
> ***LISTING 13.3*** Continued
>
> int currentVertex = theStack.peek();
>
> // get next unvisited neighbor
>
> int v = getAdjUnvisitedVertex(currentVertex);
>
> if(v == -1) // if no more neighbors theStack.pop(); // pop it away
>
> else // got a neighbor
>
> {
>
> vertexList\[v\].wasVisited = true; // mark it theStack.push(v); //
> push it
>
> // display edge displayVertex(currentVertex); // from currentV
> displayVertex(v); // to v System.out.print(" ");
>
> }
>
> } // end while(stack not empty)
>
> // stack is empty, so we're done
>
> for(int j=0; j\<nVerts; j++) // reset flags vertexList\[j\].wasVisited
> = false;
>
> } // end tree
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> // returns an unvisited vertex adj to v public int
> getAdjUnvisitedVertex(int v)
>
> {
>
> for(int j=0; j\<nVerts; j++)
>
> if(adjMat\[v\]\[j\]==1 && vertexList\[j\].wasVisited==false) return j;
>
> return -1;
>
> } // end getAdjUnvisitedVertex()
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

} // end class Graph

> //////////////////////////////////////////////////////////////// class
> MSTApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> Graph theGraph = new Graph();

+----------------------------+------------------------+
| > theGraph.addVertex('A'); | > // 0 (start for mst) |
+============================+========================+
| > theGraph.addVertex('B'); | > // 1                 |
+----------------------------+------------------------+
| > theGraph.addVertex('C'); | > // 2                 |
+----------------------------+------------------------+
| > theGraph.addVertex('D'); | > // 3                 |
+----------------------------+------------------------+

> Topological Sorting with Directed Graphs 649
>
> ***LISTING 13.3*** Continued
>
> theGraph.addVertex('E'); // 4
>
> theGraph.addEdge(0, 1); // AB theGraph.addEdge(0, 2); // AC
> theGraph.addEdge(0, 3); // AD theGraph.addEdge(0, 4); // AE
> theGraph.addEdge(1, 2); // BC theGraph.addEdge(1, 3); // BD
> theGraph.addEdge(1, 4); // BE theGraph.addEdge(2, 3); // CD
> theGraph.addEdge(2, 4); // CE theGraph.addEdge(3, 4); // DE
>
> System.out.print("Minimum spanning tree: "); theGraph.mst(); //
> minimum spanning tree System.out.println();
>
> } // end main()
>
> } // end class MSTApp
>
> ////////////////////////////////////////////////////////////////
>
> The statements in main() form a graph that can be visualized as a
> five-pointed star with every node connected to every other node. The
> output is
>
> Minimum spanning tree: AB BC CD DE

#### Topological Sorting with Directed Graphs

> Topological sorting is another operation that can be modeled with
> graphs. It's useful in situations in which items or events must be
> arranged in a specific order. Let's look at an example.

##### An Example: Course Prerequisites

> In high school and college, students find (sometimes to their dismay)
> that they can't take just any course they want. Some courses have
> prerequisites---other courses that must be taken first. Indeed, taking
> certain courses may be a prerequisite to obtaining a degree in a
> certain field. Figure 13.11 shows a somewhat fanciful arrangement of
> courses necessary for graduating with a degree in mathematics.
>
> 650 **CHAPTER 13** Graphs
>
> A D
>
> ***FIGURE 13.11*** Course prerequisites.
>
> To obtain your degree, you must complete the Senior Seminar and
> (because of pres- sure from the English Department) Comparative
> Literature. But you can't take Senior Seminar without having already
> taken Advanced Algebra and Analytic Geometry, and you can't take
> Comparative Literature without taking English Composition.
>
> Also, you need Geometry for Analytic Geometry, and Algebra for both
> Advanced Algebra and Analytic Geometry.

##### Directed Graphs

> As Figure 13.11 shows, a graph can represent this sort of arrangement.
> However, the graph needs a feature we haven't seen before: The edges
> need to have a *direction*.
>
> When this is the case, the graph is called a *directed* graph. In a
> directed graph you can proceed only one way along an edge. The arrows
> in the figure show the direc- tion of the edges.
>
> In a program, the difference between a non-directed graph and a
> directed graph is that an edge in a directed graph has only one entry
> in the adjacency matrix. Figure
>
> 13.12 shows a small directed graph; Table 13.5 shows its adjacency
> matrix.
>
> ***FIGURE 13.12*** A small directed graph.
>
> Topological Sorting with Directed Graphs 651
>
> ***TABLE 13.5*** Adjacency Matrix for a Small Directed Graph

+---+---------+---------+---------+
|   | > **A** | > **B** | > **C** |
+===+=========+=========+=========+
| A | > 0     | > 1     | > 0     |
+---+---------+---------+---------+
| B | > 0     | > 0     | > 1     |
+---+---------+---------+---------+
| C | > 0     | > 0     | > 0     |
+---+---------+---------+---------+

> Each edge is represented by a single 1. The row labels show where the
> edge starts, and the column labels show where it ends. Thus, the edge
> from A to B is represented by a single 1 at row A column B. If the
> directed edge were reversed so that it went from B to A, there would
> be a 1 at row B column A instead.
>
> For a non-directed graph, as we noted earlier, half of the adjacency
> matrix mirrors the other half, so half the cells are redundant.
> However, for a weighted graph, every cell in the adjacency matrix
> conveys unique information. The halves are not mirror images.
>
> For a directed graph, the method that adds an edge thus needs only a
> single statement,
>
> public void addEdge(int start, int end) // directed graph

{

> adjMat\[start\]\[end\] = 1;

}

> instead of the two statements required in a non-directed graph.
>
> If you use the adjacency-list approach to represent your graph, then A
> has B in its list but---unlike a non-directed graph---B does not have
> A in its list.

##### Topological Sorting

> Imagine that you make a list of all the courses necessary for your
> degree, using Figure 13.11 as your input data. You then arrange the
> courses in the order you need to take them. Obtaining your degree is
> the last item on the list, which might look like this:
>
> BAEDGCFH
>
> Arranged this way, the graph is said to be *topologically sorted*. Any
> course you must take before some other course occurs before it in the
> list.
>
> Actually, many possible orderings would satisfy the course
> prerequisites. You could take the English courses C and F first, for
> example:
>
> CFBAEDGH
>
> 652 **CHAPTER 13** Graphs
>
> This also satisfies all the prerequisites. There are many other
> possible orderings as well. When you use an algorithm to generate a
> topological sort, the approach you take and the details of the code
> determine which of various valid sortings are generated.
>
> Topological sorting can model other situations besides course
> prerequisites. Job scheduling is an important example. If you're
> building a car, you want to arrange things so that brakes are
> installed before the wheels, and the engine is assembled before it's
> bolted onto the chassis. Car manufacturers use graphs to model the
> thou- sands of operations in the manufacturing process, to ensure that
> everything is done in the proper order.
>
> Modeling job schedules with graphs is called *critical path analysis*.
> Although we don't show it here, a weighted graph (discussed in the
> next chapter) can be used, which allows the graph to include the time
> necessary to complete different tasks in a project. The graph can then
> tell you such things as the minimum time necessary to complete the
> entire project.

##### The GraphD Workshop Applet

> The GraphD workshop applet models directed graphs. This applet
> operates in much the same way as GraphN but provides a dot near one
> end of each edge to show which direction the edge is pointing. Be
> careful: The direction you drag the mouse to create the edge
> determines the direction of the edge. Figure 13.13 shows the GraphD
> workshop applet used to model the course-prerequisite situation of
> Figure 13.11.

![](media/image3.png){width="2.7927351268591427in"
height="2.2866655730533685in"}

> ***FIGURE 13.13*** The GraphD workshop applet.
>
> Topological Sorting with Directed Graphs 653
>
> The idea behind the topological sorting algorithm is unusual but
> simple. Two steps are necessary:
>
> **[STEP 1 ]{.underline}**
>
> Find a vertex that has no successors.
>
> The successors to a vertex are those vertices that are directly
> "downstream" from it--- that is, connected to it by an edge that
> points in their direction. If there is an edge pointing from A to B,
> then B is a successor to A. In Figure 13.11, the only vertex with no
> successors is H.
>
> **[STEP 2 ]{.underline}**
>
> Delete this vertex from the graph, and insert its label at the
> beginning of a list.
>
> Steps 1 and 2 are repeated until all the vertices are gone. At this
> point, the list shows the vertices arranged in topological order.
>
> You can see the process at work by using the GraphD applet. Construct
> the graph of Figure 13.11 (or any other graph, if you prefer) by
> double-clicking to make vertices and dragging to make edges. Then
> repeatedly click the Topo button. As each vertex is removed, its label
> is placed at the beginning of the list below the graph.
>
> Deleting a vertex may seem like a drastic step, but it's the heart of
> the algorithm. The algorithm can't figure out the second vertex to
> remove until the first vertex is gone. If you need to, you can save
> the graph's data (the vertex list and the adjacency matrix) elsewhere
> and restore it when the sort is completed, as we do in the GraphD
> applet.
>
> The algorithm works because if a vertex has no successors, it must be
> the last one in the topological ordering. As soon as it's removed, one
> of the remaining vertices must have no successors, so it will be the
> next-to-last one in the ordering, and so on.
>
> The topological sorting algorithm works on unconnected graphs as well
> as connected graphs. This models the situation in which you have two
> unrelated goals, such as getting a degree in mathematics and at the
> same time obtaining a certificate in first aid.

##### Cycles and Trees

> One kind of graph the topological-sort algorithm cannot handle is a
> graph with *cycles*. What's a cycle? It's a path that ends up where it
> started. In Figure 13.14 the path B-C-D-B forms a cycle. (Notice that
> A-B-C-A is not a cycle because you can't go from C to A.)
>
> 654 **CHAPTER 13** Graphs
>
> ***FIGURE 13.14*** Graph with a cycle.
>
> A cycle models the Catch-22 situation (which some students claim to
> have actually encountered at certain institutions), in which course B
> is a prerequisite for course C, C is a prerequisite for D, and D is a
> prerequisite for B.
>
> A graph with no cycles is called a *tree*. The binary and multiway
> trees we saw earlier in this book are trees in this sense. However,
> the trees that arise in graphs are more general than binary and
> multiway trees, which have a fixed maximum number of child nodes. In a
> graph, a vertex in a tree can be connected to any number of other
> vertices, provided that no cycles are created.
>
> It's easy to figure out if a non-directed graph has cycles. If a graph
> with N nodes has more than N-1 edges, it must have cycles. You can
> make this clear to yourself by trying to draw a graph with N nodes and
> N edges that does not have any cycles.
>
> A topological sort must be carried out on a directed graph with no
> cycles. Such a graph is called a *directed acyclic graph*, often
> abbreviated DAG.

##### Java Code

> Here's the Java code for the topo() method, which carries out the
> topological sort:
>
> public void topo() // topological sort
>
> {
>
> int orig\_nVerts = nVerts; // remember how many verts
>
> while(nVerts \> 0) // while vertices remain,
>
> {
>
> // get a vertex with no successors, or -1 int currentVertex =
> noSuccessors();
>
> if(currentVertex == -1) // must be a cycle
>
> {
>
> System.out.println("ERROR: Graph has cycles"); return;
>
> }
>
> Topological Sorting with Directed Graphs 655
>
> // insert vertex label in sorted array (start at end)
> sortedArray\[nVerts-1\] = vertexList\[currentVertex\].label;
>
> deleteVertex(currentVertex); // delete vertex
>
> } // end while
>
> // vertices all gone; display sortedArray
> System.out.print("Topologically sorted order: "); for(int j=0;
> j\<orig\_nVerts; j++)
>
> System.out.print( sortedArray\[j\] ); System.out.println("");
>
> } // end topo
>
> The work is done in the while loop, which continues until the number
> of vertices is reduced to 0. Here are the steps involved:

1.  Call noSuccessors() to find any vertex with no successors.

2.  If such a vertex is found, put the vertex label at the end of
    sortedArray\[\] and delete the vertex from graph.

3.  If an appropriate vertex isn't found, the graph must have a cycle.

> The last vertex to be removed appears first on the list, so the vertex
> label is placed in sortedArray starting at the end and working toward
> the beginning, as nVerts (the number of vertices in the graph) gets
> smaller.
>
> If vertices remain in the graph but all of them have successors, the
> graph must have a cycle, and the algorithm displays a message and
> quits. If there are no cycles, the while loop exits, and the list from
> sortedArray is displayed, with the vertices in topo- logically sorted
> order.
>
> The noSuccessors() method uses the adjacency matrix to find a vertex
> with no successors. In the outer for loop, it goes down the rows,
> looking at each vertex. For each vertex, it scans across the columns
> in the inner for loop, looking for a 1. If it finds one, it knows that
> that vertex has a successor, because there's an edge from that vertex
> to another one. When it finds a 1, it bails out of the inner loop so
> that the next vertex can be investigated.
>
> Only if an entire row is found with no 1s do we know we have a vertex
> with no successors; in this case, its row number is returned. If no
> such vertex is found, --1 is returned. Here's the noSuccessors()
> method:
>
> public int noSuccessors() // returns vert with no successors
>
> { // (or -1 if no such verts)
>
> 656 **CHAPTER 13** Graphs
>
> boolean isEdge; // edge from row to column in adjMat for(int row=0;
> row\<nVerts; row++) // for each vertex,
>
> {
>
> isEdge = false; // check edges for(int col=0; col\<nVerts; col++)
>
> {
>
> if( adjMat\[row\]\[col\] \> 0 ) // if edge to
>
> { // another,
>
> isEdge = true;
>
> break; // this vertex
>
> } // has a successor
>
> } // try another
>
> if( !isEdge ) // if no edges,
>
> return row; // has no successors
>
> }
>
> return -1; // no such vertex
>
> } // end noSuccessors()
>
> Deleting a vertex is straightforward except for a few details. The
> vertex is removed from the vertexList\[\] array, and the vertices
> above it are moved down to fill up the vacant position. Likewise, the
> row and column for the vertex are removed from the adjacency matrix,
> and the rows and columns above and to the right are moved down and to
> the left to fill the vacancies. These tasks are carried out by the
> deleteVertex(), moveRowUp(), and moveColLeft() methods, which you can
> examine in the complete listing for topo.java (Listing 13.4). It's
> actually more efficient to use the adjacency-list representation of
> the graph for this algorithm, but that would take us too far afield.
>
> The main() routine in this program calls on methods, similar to those
> we saw earlier, to create the same graph shown in Figure 13.10. The
> addEdge() method, as we noted, inserts a single number into the
> adjacency matrix because this is a directed graph.
>
> Here's the code for main():
>
> public static void main(String\[\] args)
>
> {
>
> Graph theGraph = new Graph(); theGraph.addVertex('A'); // 0
>
> theGraph.addVertex('B'); // 1
>
> theGraph.addVertex('C'); // 2
>
> theGraph.addVertex('D'); // 3
>
> theGraph.addVertex('E'); // 4
>
> theGraph.addVertex('F'); // 5
>
> Topological Sorting with Directed Graphs 657
>
> theGraph.addVertex('G'); // 6
>
> theGraph.addVertex('H'); // 7
>
> theGraph.addEdge(0, 3); // AD theGraph.addEdge(0, 4); // AE
> theGraph.addEdge(1, 4); // BE theGraph.addEdge(2, 5); // CF
> theGraph.addEdge(3, 6); // DG theGraph.addEdge(4, 6); // EG
> theGraph.addEdge(5, 7); // FH theGraph.addEdge(6, 7); // GH
>
> theGraph.topo(); // do the sort
>
> } // end main()
>
> After the graph is created, main() calls topo() to sort the graph and
> display the result. Here's the output:
>
> Topologically sorted order: BAEDGCFH
>
> Of course, you can rewrite main() to generate other graphs.
>
> **The Complete** topo.java **Program**
>
> You've seen most of the routines in topo.java already. Listing 13.4
> shows the complete program.
>
> ***LISTING 13.4*** The topo.java Program
>
> // topo.java
>
> // demonstrates topological sorting
>
> // to run this program: C\>java TopoApp
>
> //////////////////////////////////////////////////////////////// class
> Vertex
>
> {
>
> public char label; // label (e.g. 'A')
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Vertex(char lab) // constructor

{ label = lab; }

> } // end class Vertex
>
> //////////////////////////////////////////////////////////////// class
> Graph
>
> {
>
> private final int MAX\_VERTS = 20;
>
> 658 **CHAPTER 13** Graphs
>
> ***LISTING 13.4*** Continued
>
> private Vertex vertexList\[\]; // list of vertices private int
> adjMat\[\]\[\]; // adjacency matrix
>
> private int nVerts; // current number of vertices private char
> sortedArray\[\];
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public Graph() // constructor
>
> {
>
> vertexList = new Vertex\[MAX\_VERTS\];
>
> // adjacency matrix adjMat = new int\[MAX\_VERTS\]\[MAX\_VERTS\];
>
> nVerts = 0;
>
> for(int j=0; j\<MAX\_VERTS; j++) // set adjacency for(int k=0;
> k\<MAX\_VERTS; k++) // matrix to 0
>
> adjMat\[j\]\[k\] = 0;
>
> sortedArray = new char\[MAX\_VERTS\]; // sorted vert labels
>
> } // end constructor

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void addVertex(char lab)
>
> {
>
> vertexList\[nVerts++\] = new Vertex(lab);
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void addEdge(int start, int end)
>
> {
>
> adjMat\[start\]\[end\] = 1;
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void displayVertex(int v)
>
> {
>
> System.out.print(vertexList\[v\].label);
>
> }

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void topo() // topological sort
>
> {
>
> int orig\_nVerts = nVerts; // remember how many verts
>
> while(nVerts \> 0) // while vertices remain,
>
> {
>
> // get a vertex with no successors, or -1 int currentVertex =
> noSuccessors();

if(currentVertex == -1) // must be a cycle

> Topological Sorting with Directed Graphs 659
>
> ***LISTING 13.4*** Continued
>
> {
>
> System.out.println("ERROR: Graph has cycles"); return;
>
> }
>
> // insert vertex label in sorted array (start at end)
> sortedArray\[nVerts-1\] = vertexList\[currentVertex\].label;
>
> deleteVertex(currentVertex); // delete vertex
>
> } // end while
>
> // vertices all gone; display sortedArray
> System.out.print("Topologically sorted order: "); for(int j=0;
> j\<orig\_nVerts; j++)
>
> System.out.print( sortedArray\[j\] ); System.out.println("");
>
> } // end topo
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> public int noSuccessors() // returns vert with no successors
>
> { // (or -1 if no such verts) boolean isEdge; // edge from row to
> column in adjMat
>
> for(int row=0; row\<nVerts; row++) // for each vertex,
>
> {
>
> isEdge = false; // check edges for(int col=0; col\<nVerts; col++)
>
> {
>
> if( adjMat\[row\]\[col\] \> 0 ) // if edge to

{ // another,

> isEdge = true;
>
> break; // this vertex
>
> } // has a successor
>
> } // try another
>
> if( !isEdge ) // if no edges,
>
> return row; // has no successors
>
> }
>
> return -1; // no such vertex
>
> } // end noSuccessors()

//
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

> public void deleteVertex(int delVert)
>
> {
>
> if(delVert != nVerts-1) // if not last vertex,
>
> 660 **CHAPTER 13** Graphs
>
> ***LISTING 13.4*** Continued
>
> { // delete from vertexList for(int j=delVert; j\<nVerts-1; j++)
>
> vertexList\[j\] = vertexList\[j+1\];
>
> // delete row from adjMat for(int row=delVert; row\<nVerts-1; row++)
>
> moveRowUp(row, nVerts);
>
> // delete col from adjMat for(int col=delVert; col\<nVerts-1; col++)
>
> moveColLeft(col, nVerts-1);
>
> }
>
> nVerts\--; // one less vertex
>
> } // end deleteVertex
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> private void moveRowUp(int row, int length)
>
> {
>
> for(int col=0; col\<length; col++) adjMat\[row\]\[col\] =
> adjMat\[row+1\]\[col\];
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> private void moveColLeft(int col, int length)
>
> {
>
> for(int row=0; row\<length; row++) adjMat\[row\]\[col\] =
> adjMat\[row\]\[col+1\];
>
> }
>
> //
> \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
>
> } // end class Graph
>
> //////////////////////////////////////////////////////////////// class
> TopoApp
>
> {
>
> public static void main(String\[\] args)
>
> {
>
> Graph theGraph = new Graph(); theGraph.addVertex('A'); // 0
>
> theGraph.addVertex('B'); // 1
>
> theGraph.addVertex('C'); // 2
>
> theGraph.addVertex('D'); // 3
>
> theGraph.addVertex('E'); // 4
>
> theGraph.addVertex('F'); // 5
>
> theGraph.addVertex('G'); // 6
>
> theGraph.addVertex('H'); // 7
>
> Connectivity in Directed Graphs 661
>
> ***LISTING 13.4*** Continued theGraph.addEdge(0, 3); // AD
> theGraph.addEdge(0, 4); // AE theGraph.addEdge(1, 4); // BE
> theGraph.addEdge(2, 5); // CF theGraph.addEdge(3, 6); // DG
> theGraph.addEdge(4, 6); // EG theGraph.addEdge(5, 7); // FH
> theGraph.addEdge(6, 7); // GH
>
> theGraph.topo(); // do the sort
>
> } // end main()

} // end class TopoApp

> ////////////////////////////////////////////////////////////////
>
> In the next chapter, we'll see what happens when edges are given a
> weight as well as a direction.

#### Connectivity in Directed Graphs

> We've seen how in a non-directed graph you can find all the vertices
> that are connected by doing a depth-first or breadth-first search.
> When we try to find all the connected vertices in a directed graph,
> things get more complicated. You can't just start from a randomly
> selected vertex and expect to reach all the other connected vertices.
>
> Consider the graph in Figure 13.15. If you start on A, you can get to
> C but not to any of the other vertices. If you start on B, you can't
> get to D, and if you start on C, you can't get anywhere. The
> meaningful question about connectivity is: What vertices can you reach
> if you start on a particular vertex?
>
> ***FIGURE 13.15*** A directed graph.
>
> 662 **CHAPTER 13** Graphs

##### The Connectivity Table

> You can easily modify the dfs.java program (Listing 13.1) to start the
> search on each vertex in turn. For the graph of Figure 13.15 the
> output will look something like this:
>
> AC BACE C DEC EC
>
> This is the connectivity table for the directed graph. The first
> letter is the starting vertex and subsequent letters show the vertices
> that can be reached (either directly or via other vertices) from the
> starting vertex.

##### Warshall's Algorithm

> In some applications it's important to find out quickly whether one
> vertex is reach- able from another vertex. Perhaps you want to fly
> from Athens to Murmansk on Hubris Airlines and you don't care how many
> intermediate stops you need to make. Is this trip possible?
>
> You could examine the connectivity table, but then you would need to
> look through all the entries on a given row, which would take O(N)
> time (where N is the average number of vertices reachable from a given
> vertex). But you're in a hurry; is there a faster way?
>
> It's possible to construct a table that will tell you instantly (that
> is, in O(1) time) whether one vertex is reachable from another. Such a
> table can be obtained by systematically modifying a graph's adjacency
> matrix. The graph represented by this revised adjacency matrix is
> called the *transitive closure* of the original graph.
>
> Remember that in an ordinary adjacency matrix the row number indicates
> where an edge starts and the column number indicates where it ends.
> (This is similar to the arrangement in the connectivity table.) A 1 at
> the intersection of row C and column D means there's an edge from
> vertex C to vertex D. You can get from one vertex to the other in one
> step. (Of course, in a directed graph it does not follow that you can
> go the other way, from D to C.) Table 13.6 shows the adjacency matrix
> for the graph of Figure 13.15.
>
> ***TABLE 13.6*** Adjacency Matrix

+---+---------+-------+-------+---------+---------+
|   | > **A** | **B** | **C** | > **D** | > **E** |
+===+=========+=======+=======+=========+=========+
| A | > 0     | 0     | 1     | > 0     | > 0     |
+---+---------+-------+-------+---------+---------+
| B | > 1     | 0     | 0     | > 0     | > 1     |
+---+---------+-------+-------+---------+---------+
| C | > 0     | 0     | 0     | > 0     | > 0     |
+---+---------+-------+-------+---------+---------+

> Connectivity in Directed Graphs 663

+-------------+--------------+-------------+---------+---------+---------+
| ***TABLE*** | > ***13.6*** | > Continued |         |
+=============+==============+=============+=========+=========+=========+
|             | **A**        | > **B**     | > **C** | > **D** | > **E** |
+-------------+--------------+-------------+---------+---------+---------+
| > D         | 0            | > 0         | > 0     | 0       | > 1     |
+-------------+--------------+-------------+---------+---------+---------+
| > E         | 0            | > 0         | > 1     | 0       | > 0     |
+-------------+--------------+-------------+---------+---------+---------+

> We can use *Warshall's algorithm* to change the adjacency matrix into
> the transitive closure of the graph. This algorithm does a lot in a
> few lines of code. It's based on a simple idea:
>
> If you can get from vertex L to vertex M, and you can get from M to N,
> then you can get from L to N.
>
> We've derived a two-step path from two one-step paths. The adjacency
> matrix shows all possible one-step paths, so it's a good starting
> place to apply this rule.
>
> You might wonder if this algorithm can find paths of more than two
> edges. After all, the rule only talks about combining two one-edge
> paths into one two-edge path. As it turns out, the algorithm will
> build on previously discovered multi-edge paths to create paths of
> arbitrary length. The implementation we will describe guarantees this
> result, but a proof is beyond the scope of this book.
>
> Here's how it works. We'll use Table 13.6 as an example. We're going
> to examine every cell in the adjacency matrix, one row at a time.

####### Row A

> We start with row A. There's nothing in columns A and B, but there's a
> 1 at column C, so we stop there.
>
> Now the 1 at this location says there is a path from A to C. If we
> knew there was a path from some vertex X to A, then we would know
> there was a path from X to C. Where are the edges (if any) that end at
> A? They're in column A. So we examine all the cells in column A. In
> Table 13.6 there's only one 1 in column A: at row B. It says there's
> an edge from B to A. So we know there's an edge from B to A, and
> another (the one we started with) from A to C. From this we infer that
> we can get from B to C in two steps. You can verify this is true by
> looking at the graph in Figure 13.15.
>
> To record this result, we put a 1 at the intersection of row B and
> column C. The result is shown in Figure 13.16a.
>
> The remaining cells of row A are blank.

####### Rows B, C, and D

> We go to row B. The first cell, at column A, has a 1, indicating an
> edge from B to A. Are there any edges that end at B? We look in column
> B, but it's empty, so we know that none of the 1s we find in row B
> will result in finding longer paths because no edges end at B.
>
> 664 **CHAPTER 13** Graphs

a)  y = 0

A B C D E

> A B C D E

b)  y = 4

> A B C D E
>
> A B C D E
>
> A to C and B to A so B to C
>
> ***FIGURE 13.16*** Steps in Warshall's algorithm.
>
> E to C and D to E so D to C
>
> Row C has no 1s at all, so we go to row D. Here we find an edge from D
> to E. However, column D is empty, so there are no edges that end on D.

####### Row E

> In row E we see there's an edge from E to C. Looking in column E we
> see the first entry is for the edge B to E, so with B to E and E to C
> we infer there's a path from B to C. However, it's already been
> discovered, as indicated by the 1 at that location.
>
> There's another 1 in column E, at row D. This edge from D to E plus
> the one from E to C imply a path from D to C, so we insert a 1 in that
> cell. The result is shown in Figure 13.16b.
>
> Warshall's algorithm is now complete. We've added two 1s to the
> adjacency matrix, which now shows which nodes are reachable from
> another node in any number of steps. If we drew a graph based on this
> new matrix, it would be the transitive closure of the graph in Figure
> 13.15.

##### Implementation of Warshall's Algorithm

> One way to implement Warshall's algorithm is with three nested loops
> (as suggested by Sedgewick; see Appendix B, "Further Reading"). The
> outer loop looks at each row; let's call its variable y. The loop
> inside that looks at each cell in the row; it uses vari- able x. If a
> 1 is found in cell (x, y), there's an edge from y to x, and the third
> (inner- most) loop is activated; it uses variable z.
>
> The third loop examines the cells in column y, looking for an edge
> that ends at y. (Note that y is used for rows in the first loop but
> for the column in the third loop.) If there's a 1 in column y at row
> z, then there's an edge from z to y. With one edge from z to y and
> another from y to x, it follows that there's a path from z to x, so
> you can put a 1 at (x, z). We'll leave the details as an exercise.

Questions 665

#### Summary

-   Graphs consist of vertices connected by edges.

-   Graphs can represent many real-world entities, including airline
    routes, electrical circuits, and job scheduling.

-   Search algorithms allow you to visit each vertex in a graph in a
    systematic way. Searches are the basis of several other activities.

-   The two main search algorithms are depth-first search (DFS) and
    breadth-first search (BFS).

-   The depth-first search algorithm can be based on a stack; the
    breadth-first search algorithm can be based on a queue.

-   A minimum spanning tree (MST) consists of the minimum number of
    edges necessary to connect all a graph's vertices.

-   A slight modification of the depth-first search algorithm on an
    unweighted graph yields its minimum spanning tree.

-   In a directed graph, edges have a direction (often indicated by an
    arrow).

-   A topological sorting algorithm creates a list of vertices arranged
    so that a vertex A precedes a vertex B in the list if there's a path
    from A to B.

-   A topological sort can be carried out only on a DAG, a directed
    acyclic (no cycles) graph.

-   Topological sorting is typically used for scheduling complex
    projects that consist of tasks contingent on other tasks.

-   Warshall's algorithm finds whether there is a connection, of either
    one or multiple edges, from any vertex to any other vertex.

#### Questions

> These questions are intended as a self-test for readers. Answers may
> be found in Appendix C.

1.  In a graph, an [ ]{.underline} connects two [ ]{.underline} .

2.  How do you tell, by looking at its adjacency matrix, how many edges
    there are in an undirected graph?

3.  In a game simulation, what graph entity corresponds to a choice
    about what move to make?

> 666 **CHAPTER 13** Graphs

4.  A directed graph is one in which

    a.  you must follow the minimum spanning tree.

    b.  you must go from vertex A to vertex B to vertex C and so on.

    c.  you can go in only one direction from one given vertex to
        another.

    d.  you can go in only one direction on any given path.

> **5.** If an adjacency matrix has rows {0,1,0,0}, {1,0,1,1},
> {0,1,0,0}, and {0,1,0,0}, what is the corresponding adjacency list?

6.  A minimum spanning tree is a graph in which

    a.  the number of edges connecting all the vertices is as small as
        possible.

    b.  the number of edges is equal to the number of vertices.

    c.  all unnecessary vertices have been removed.

    d.  every combination of two vertices is connected by the minimum
        number of edges.

7.  How many different minimum spanning trees are there in an undirected
    graph of three vertices and three edges?

8.  An undirected graph must have a cycle if

    e.  any vertex can be reached from some other vertex.

    f.  the number of paths is greater than the number of vertices.

    g.  the number of edges is equal to the number of vertices.

    h.  the number of paths is less than the number of edges.

9.  A [ ]{.underline} is a graph with no cycles.

10. Can a minimum spanning tree for an undirected graph have cycles?

11. True or False: There may be many correct topological sorts for a
    given graph.

12. Topological sorting results in

    i.  vertices arranged so the directed edges all go in the same
        direction.

    j.  vertices listed in order of increasing number of edges from the
        beginning vertex.

    k.  vertices arranged so A precedes B, which precedes C, and so on.

    l.  vertices listed so the ones later in the list are downstream
        from the ones earlier.

Programming Projects 667

13. What's a DAG?

14. Can a tree have cycles?

15. What evidence does the topo.java program (Listing 13.4) use to
    deduce that a graph has a cycle?

#### Experiments

> Carrying out these experiments will help to provide insights into the
> topics covered in the chapter. No programming is involved.

1.  Using the GraphN workshop applet, draw a graph with five vertices
    and seven edges. Then, without using the View button, write down the
    adjacency matrix for the graph. When you're done, push the View
    button to see if you got it right.

2.  A normal tic-tac-toe game is played on a 3×3 board, but for
    simplicity, think of a 2×2 tic-tac-toe game, in which a player needs
    only 2 Xs or 2 Os to win. Use the GraphN applet to create a graph
    corresponding to such a 2×2 game. Do you really need a depth of 4?

3.  Create a five-vertex adjacency matrix and insert 0s and 1s randomly.
    Don't worry about symmetry. Now, without using the View button,
    create the corre- sponding directed graph using the GraphD workshop
    applet. When you're done, push the View button to see if the graph
    corresponds to your adjacency matrix.

4.  In the GraphD workshop applet, see if you can create a graph with a
    cycle that the Topo routine cannot identify.

#### Programming Projects

> Writing programs to solve the Programming Projects helps to solidify
> your under- standing of the material and demonstrates how the
> chapter's concepts are applied. (As noted in the Introduction,
> qualified instructors may obtain completed solutions to the
> Programming Projects on the publisher's Web site.)

1.  Modify the bfs.java program (Listing 13.2) to find the minimum
    spanning tree using a breadth-first search, rather than the
    depth-first search shown in mst.java (Listing 13.3). In main(),
    create a graph with 9 vertices and 12 edges, and find its minimum
    spanning tree.

    Modify the dfs.java program (Listing 13.1) to use adjacency lists
    rather than an adjacency matrix. You can obtain a list by adapting
    the Link and LinkList classes from the linkList2.java program
    (Listing 5.2) in Chapter 5. Modify the

> 668 **CHAPTER 13** Graphs
>
> find() routine from LinkList to search for an unvisited vertex rather
> than for a key value.

3.  Modify the dfs.java program (Listing 13.1) to display a connectivity
    table for a directed graph, as described in the section
    "Connectivity in Directed Graphs."

    Implement Warshall's algorithm to find the transitive closure for a
    graph. You could start with the code from Programming Project 13.3.
    It's useful to be able to display the adjacency matrix at various
    stages of the algorithm's operation.

    The Knight's Tour is an ancient and famous chess puzzle. The object
    is to move a knight from one square to another on an otherwise empty
    chess board until it has visited every square exactly once. Write a
    program that solves this puzzle using a depth-first search. It's
    best to make the board size variable so that you can attempt
    solutions for smaller boards. The regular 8×8 board can take years
    to solve on a desktop computer, but a 5×5 board takes only a minute
    or so.

> Refer to the section "Depth-First Search and Game Simulations" in this
> chapter. It may be easier to think of a new knight being created and
> remaining on the new square when a move is made. This way, a knight
> corresponds to a vertex, and a sequence of knights can be pushed onto
> the stack. When the board is completely filled with knights (the stack
> is full), you win. In this problem the board is traditionally numbered
> sequentially, from 1 at the upper-left corner to 64 at the lower-right
> corner (or 1 to 25 on a 5×5 board). When looking for its next move, a
> knight must not only make a legal knight's move, it must also not move
> off the board or onto an already-occupied (visited) square. If you
> make the program display the board and wait for a keypress after every
> move, you can watch the progress of the algorithm as it places more
> and more knights on the board, and then, when it gets boxed in,
> backtracks by removing some knights and trying a different series of
> moves. We'll have more to say about the complexity of this problem in
> the next chapter.
